# Basic
-> Bản chất kích thước trong css
- margin collapse là hiện tượng bottom margin thẻ trên bị merge với top margin thẻ dưới => fix bằng cách dùng padding hoăc cho thành inline-block
- padding-top 100% lấy 1/3 phần height thẻ cha. VD: A height 600px chứa B có padding-top 100% thì B có padding top là 200px vì chia đều cho padding top, bottom, content height
- inline chiếm đủ nội dung và k thể set width height, block chiếm toàn bộ chiều ngang và có thể set. inline-block giống inline nhưng có thể set width height.
- width auto chiếm full remaining space k tính margin, khác với width 100% sẽ có kích thước = 100% width thẻ cha. Nếu nhiều thẻ auto sẽ chia đều.
Cách khác nếu muốn fillup remaining space là dùng flex-grow, fill-available
- Mọi trường hợp, min lớn hơn max sẽ lấy min. Vd min-height > max-height sẽ lấy min-height
- Bản chất về height:
height auto là default sẽ tự mở rộng theo kích thước content. Thường css reset cũng để thẻ body mặc định như v chứ k set height cố định.
Khi set 50% sẽ theo kích thước thẻ cha trực tiếp. Nếu thẻ cha trực tiếp k set height or auto theo thẻ con, thì bị loop, khiến thuộc tính height 50% invalid và coi như k có. 
VD thẻ cha có mỗi min-height:100vh; thẻ con height 50% sẽ k chạy vì height thẻ cha vẫn là auto tương tự như trên. 

-> Tổng kết dự án basic:
- Tạo dự án: parcel import npm; html thuần import cdn; react;
- Hosting: Github pages, netlify.
- Darkmode: scss dùng map; css thuần dùng var có thể set từ checkbox hoặc dùng JS set data-theme attribute cho thẻ body, hoặc viết thủ công như cách scss sau khi tạo ra; Dùng css relative color tạo color palette.
- Chia file: html thuần chia mỗi pages 1 file; css chia style chung và riêng từng pages ở các file riêng rồi import file css trực tiếp lẫn nhau được; scss cũng style chung từng file, từng pages @use các file chung đó, chia cả file components các thứ, cuối cùng quy hét về 1 file scss duy nhất @use tất cả để compile bằng 1 lệnh thôi, mọi pages đều phải script tới file chung đó dẫn đến style thừa nhưng chả sao.
- BEM: scss dùng &__container, css cũng vậy. Trong file css 1 pages có <section>__<subsection>__<content>, max là 4 level. CSS Selector 1 level thôi.
- Responsive: dùng css var với responsive hack grid flex, dùng clamp; Dùng @container > @media; scss dùng @mixin chia từng màn hình @media thuần và css hack.
- Routing chuyển pages: dùng thẻ a or window.location.href để chuyển page load lại mọi thứ, or mở tab mới; Dùng history.pushState + URLSearchParams cho đổi url mà k chuyển page; có thể prefetch trước file cho pages same site <link rel="prefetch" href="./page2.html">; Dùng view transition api; Dùng session storage lưu data các pages;



# BEM
BEM (Block-Element-Modifier) kbh dùng id mà chỉ có class và tên các class tuân theo chuẩn. Nested thì chỉ nên 1 cấp. BEM max 4 cấp
VD để biểu diễn item nằm trong khối block menu, thay vì:
  .menu { ... }
    .menu .item { ... }
    .menu .item.active { ... }
Ta dùng:
  .menu { ... }
    .menu__item { ... }
    .menu__item--active { ... }

VD: <a class="btn btn--orange" href="#">
  <span class="btn__price">$9.99</span>
  <span class="btn__text">Subscribe</span>
</a>
và file css: .btn { ... }
.btn--orange { ... } => -- có tính chất gì
.btn__price { ... } => __ là gì
.btn__text { ... }



# CSS reset
width default là auto tự full và k cần set 100% làm gì, height default tự theo content và chỉ cần set min-height 100dvh nếu cần footer dưới cùng thôi.

-> Phân biệt:
initial: lấy thông số kỹ thuật của css. VD display có default là inline sẽ khiến mọi thẻ thành inline kể cả các thẻ div => k dùng vì nhiều cái default rất ảo
unset: có parent thì lấy theo parent, nếu chưa từng set cho parent thì lấy initial value là thông sô kỹ thuật của css => k dùng
inherit: lấy giá trị thuộc tính kế thừa từ cha. Vì mọi thẻ đều có mọi thuộc tính, nếu cha k set sẽ dùng default value của browser. Chú ý default value của browser khác với default value của css property.
none: k set giá trị và coi như k có giá trị đó luôn, 1 vài css prop có giá trị này thôi.

-> Import css tự reset trước, rồi đến css của thư viện, sau đó là css cho component tuỳ chỉnh.
Bản chất: chia theo layer -> trong cùng cấp layer, style 1 thẻ con sẽ ghi đè style thẻ cha, style thẻ cha là body cũng mạnh hơn html vì cha gần hơn -> cùng là style thẻ đó thì style ngoài layer sẽ đè style layer con, cùng cấp layer mới chia theo specifility => Đó chính là lý do vì sao html là 0:0:1 nhưng lại k đè được :where là 0:0:0
VD thứ tự khi reset giả sử chỉ có 1 layer:
html => spec 0:0:1, là thuộc tính cha html của mọi thẻ, thường set style base mọi thẻ
:root => spec 0:1:0, là thuộc tính cha html của mọi thẻ, thường định nghĩa css var, k style (pseudo class)
body => spec 0:0:1, là thuộc tính cha body của mọi thẻ, thường dùng định nghĩa style cho body và mọi thẻ khác mà dùng biến trong :root
user agent stylesheet => cố định k thể sửa với từng thẻ
* => spec 0:0:0, set thuộc tính base cho mọi thẻ, thường để đè user agent stylesheet
:where(tag) => spec 0:0:0, set thuộc tính base cho 1 tag cụ thể
Trong react còn có #id là thẻ bao ứng dụng.



# Dùng @import trong css
- @import nhiều lần cùng 1 file sẽ lấy cái sau thôi, k sợ trùng.
- @import url("./2.css") layer(base); => nhét mọi code trong 1 file css trong 1 layer
- Phải để ở đầu file, nó sẽ chạy tuần tự và làm chậm tải trang => hạn chế dùng trong production mà nên bundle 1 file index.css duy nhất. Vd dùng parcel build.
Nếu được nên dùng <link rel="stylesheet" href="styles/reset.css"> sẽ chạy import nhiều file css song song nhưng vẫn đảm bảo thứ tự trong html nên k sao.

-> Nhanh:
Có thể chia layer
K dùng production vì tuần tự



# Dùng @scope và @layer
-> @scope selector k ảnh hưởng spec, selector bên trong giữ nguyên spec. Trong cùng 1 layer, nếu bên ngoài và trong scope đều cùng specifility, sẽ ưu tiên lấy trong scope
@scope có thể giới hạn style trong 1 phạm vi mà nested selector không làm được. VD @scope (article) to (aside) { } từ cha article đến con aside và k tính con.

VD2: @scope (.text) to (button.xxx) { // button.xxx k ảnh hưởng spec
  :scope { } // tương đương với & { } là root của @scope chính là .text
  p { color: red; }
  button { color: yellow; }
}
VD2: @scope (.text) to (button.xxx, a, p[class]) { } 
VD3: @scope (article) to (> figure) {} => áp dụng cho mọi con của article, trừ con trực tiếp là tag figure
VD4 scope lồng: @scope(aside) { @scope (article) { ... } }

:scope như 1 class selector duy nhất để tính spec, còn & thì tính spec như nested thế vào bth.
VD: @scope (main .text) to (button.xxx) {
  :scope img { } // (0, 1, 1)
}
@scope (main .text) to (button.xxx) {
  & img { } // (0, 1, 2) vì & thế vào thành "main .text img {}"
}

-> Có 3 loại layer theo thứ tự đè nhau: user agent styles -> user styles -> author styles
user agent style có sẵn browser k thể đổi. Có thể dùng @layer định nghĩa thêm các layer con trong author styles, còn style bth vẫn thuộc layer author styles và k nằm trong layer con nào.

Layer sau luôn đè layer trước, kể cả !important cũng k thể tác động, nên cần chú ý thứ tự import các layer.
VD: @layer framework, reset, base, layout, components; => để đầu file mới có tác dụng khai báo thứ tự, bên dưới set thế nào vẫn luôn tuân theo thứ tự này
=> Nếu lib css dùng layer riêng sẽ dễ custom hơn vì kể cả lib có dùng !important, vẫn có thể override với layer custom được import sau.

Trong cùng 1 layer thì style ngoài sẽ đè style trong layer con. 
@layer có thể lồng trong @layer khác và quy tắc vẫn tương tự.

--> scss dùng @layer như bth, nhưng nó phải dùng @use ở đầu nên k thể định nghĩa @layer trước nó được, buộc phải nhét @layer vào 1 file scss riêng rồi @use nó ở đầu để xuất hiện ở đầu
Case đặc biệt là @import có thể dùng bên trong @layer, nhưng @use thì không. VD fix với:
@use 'sass:meta';
@layer base, components, utilities;
@layer components {
  @include meta.load-css('components'); // Thế cho @use 'components'
}

-> Nhanh:
Các layer k thể can thiệp kể cả !important. Trong 1 layer thì style ngoài layer sẽ đè style trong layer
@layer phải khai báo thứ tự ở đầu. Sau đó muốn viết thứ tự như nào xuống dưới cũng được.



# Spec và CSS Selector
Cascade là khi cùng spec thì theo thứ tự định nghĩa. VD ta link file css sau <style> thì css trong file sẽ đè lên css trong tag <style>.
layer sau đè layer trước > cùng layer thì thẻ cha gần đè thẻ cha xa, style con đè style cha > cùng style con thì style bình thường đè style layer con -> cùng layer và cùng style con thì theo specifility -> cùng specifillity thì theo quy tắc @scope và cái sau đè cái trước
inline style > !important > style theo id > style class, pseudo-class, attributes > element and pseudo-element > universal selector(*)

-> Specifility (0,1,1) theo thứ tự là: Số ID selector; Số class / pseudo class / attribute selector; Element và số pseudo elements như :after, :first-letter
URL check spec: https://specificity.keegan.st/

VD1: pseudo-class :hover
attributes-selector img:not([alt]) 
pseudo-element: .test:before
VD2: dialog.hide 0:1:1 = dialog[open] 0:1:1 > .hide 0:1:0

-> Combinator:
space là descendant mọi cấp
>  child trực tiếp
~  mọi sibling sau
+  1 sibling ngay sau 

-> VD selector:
a[href$=".abc" i] => tag a có href kết thúc bằng .abc case insensitive
[href*="google.com"] => tag có href attribute chứa google.com ở bất kỳ đâu
:active => button, link đang được click
::selection => text được bôi đen
:visited X :link => :link là <a> chưa visit bao giờ
p:empty => thẻ p k có text bên trong 
:nth-last-of-type(2) => sibling cuối cùng thứ 2
p:lang(it) { } => thẻ p có lang là italia. VD: <p lang="it">Ciao bella!</p>
.grid > :nth-child(4n) => con trực tiếp trong grid mà thứ tự chia hết cho 4
p:only-child { } => thẻ p là con duy nhất của 1 thẻ khác 
::initial-letter = ::first-letter => tạo chữ đầu tiên to đùng như đầu bài báo article
X:before default ở top left, X:after default ở top right, nằm trong thẻ X
:target => style cho thẻ chứa id, khi được href tới id, từ 1 thẻ khác 

VD tạo checkbox với option light/dark mode thì: body:has(option[value="dark"]:checked){ --background: black; --text-color: white; }
VD ấn vào ảnh là phóng to ảnh, cck 1 button đóng ảnh css only. Thì click thẻ a ref tới ảnh và style img:target phóng to, khi close thì xoá target bằng href="#" k hợp lệ.
VD read more với CSS only: dùng 2 dùng label + checkbox + :checked để ẩn hiện text

--> Special navigate với thẻ a:
<a href="#"> => Invalid tự scrolls to the top of a document, or <a href="#top"> nếu k có thẻ id top
<a href=""> => Reloads the current page, preserving the search string but removing the hash string (if present)
<a href="."> => Reloads the current page, removing both the search and hash strings
<a href="?"> => Reloads the current page, removing both the search and hash strings (nhưng keeps `?`)
<a href="data:"> => Link to data URLs, like text fragments
<a href="video.mp4#t=10,20"> => Links chi tiết tới đoạn nào của media file

-> Pb:
- :is() sẽ lấy specificity của selector cao nhất bên trong và áp dụng cho tất cả, giúlip liệt kê gọn hơn. Còn :where() có spec là 0:0:0 cho css reset
:where(.parent) .child {} thì child vẫn giư specifility của nó là 0:1:0
VD: .example :is(h1, h2, .link) {} tương đương với .example h1, .example h2, .example .link {}
- :focus là chính thẻ đó focus. Còn :focus-within là khi bất cứ 1 thành phần bên trong nào của thẻ này được focus, bao gồm ấn tab thì đổi style thẻ này. 
:focus là chọn bởi chuột hoặc tabkey, :focus-visible là riêng TH chọn với tabkey
VD button show dropdown thì dùng :focus-within thay cho :focus để click vào item con thì button cũng k ẩn dropdown, chứ kp chỉ được ấn vào thẻ dropdown cha.
VD click chuột vào 1 phần tử trong list thì đổi style đơn giản: từng item thêm tabIndex={index}, trong css bắt sự kiện thẻ đó :focus r chỉnh style thoải mái. 

-> Nhanh: 
Spec 
4 combinator
light/dark mode, phóng to ảnh với css only, readmore
Có thể special navigate với thẻ a
:is và :where
:focus và :focus-within, dùng :focus với tabIndex



# Dùng font
TrueType Fonts (TTF): TrueType là định dạng font phổ biến cho các hệ điều hành Mac OS và Windows.
OpenType Fonts (OTF): OpenType là một định dạng được phát triển dựa trên nền tảng của TrueType.
Web Open Font Format (WOFF): là một TrueType nhưng nhẹ hơn và được W3C khuyến khích dùng
Web Open Font Format (WOFF 2.0): là một bản nén tuyệt vời hơn WOFF 1.0.
Embedded OpenType Fonts (EOT): EOT là một hình thức nén ít dùng của OpenType
SVG Fonts: là chữ biến hóa như ảnh graphic. 
Còn có material icons là icons viết dạng tag html

-> Thêm font mới:
- Dùng @import url(<remote url>); để import có trực tiếp font-family trong css, k dùng được với local url.
- Set font từ local file:
@font-face {
  font-family: MyFont;
  src: url(sansation_light.woff2) format("woff2"),
       url(sansation_light.woff) format("woff"); // Browser k support woff2 tự chuyển sang woff, hỗ trợ hết r nên k cần thiết
  font-weight: 100;
}
h2 {
  font-family: MyFont, sans-serif; // K tìm thấy MyFont sẽ dùng font sans-serif mặc định của browser
}
- Nên dùng 1 font file chuẩn và style tự set. Nếu buộc có nhiều style chia font-file riêng, phải thêm font-style font-weight để pb, dùng đúng style sẽ tự lấy đúng font
VD dùng cùng tên font nhưng style khác nhau:
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-Bold-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-BoldItalic-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: italic;
}
Sử dụng nó tự dùng đúng font tương ứng:
body { font-family: "DroidSerif", Georgia, serif; }
h1 { font-weight: bold; } // Cả 2 font cùng có styles sẽ lấy font đầu tiên
em { font-style: italic; }
strong em {
  font-weight: bold;
  font-style: italic;
}
Short hand nhiều url:
@font-face {
  font-family: 'Klavika';
  src: url(../fonts/Klavika-Regular.otf) format('truetype') font-weight-normal,
       url(../fonts/Klavika-Bold.otf) format('truetype') font-weight-bold,
       url(../fonts/Klavika-Bold-Italic.otf) format('truetype') font-italic font-weight-bold;
}

--> Variable fonts cho phép đổi thuộc tính cùng 1 font file, k fix cứng font-size, font-weight, italic => nên luôn dùng
Khi tải font chú ý font-weight fix cứng thì k nên dùng. Variable font thì FE chỉ cần tải 1 file rồi tự style thoải mái.
VD roboto là static font, roboto_flex là variable font

-> Web safe font: Có các font chạy trên linux ok nhưng sang window bị lệch dòng, phải sửa thẳng vào file ttf bằng FontForge mất tg. Web safe font là các font chạy mượt với mọi browser và hđh. Nó k đảm bảo lúc nào cũng khả dụng nên phải thêm fallback fonts nếu dùng.
URL: https://www.w3schools.com/cssref/css_websafe_fonts.php
URL: https://www.w3schools.com/cssref/css_fonts_fallbacks.php

-> Các thuộc tính:
- text-transform: uppercase; => viết hoa input của người dùng, luôn dùng thay cho JS
- font-systhesis => bỏ, default auto tự cho phép browser giả style khi font k hỗ trợ. 
Chỉ cần đảm bảo k bị lỗi hiển thị là đươc. Nếu thêm style mà text k đổi thì là do font k hỗ trợ và browser cũng k giả style được.
- text-rendering => default auto browser tự quyết định cân bằng optimizeSpeed, optimizeLegibility, hay độ chính xác hình học (geometricPrecision)
optimizeLegibility là giúp vc chữ hiển thị dễ đọc, phân biệt "f l i" bằng cách in với kích thước hơi khác biệt 1 chút cho người dùng tránh nhầm
=> Để thế nào cũng được, nếu k sợ nhầm chữ thì để optimizeSpeed
- font-smooth => luôn để always là luôn tối ưu smooth cho các thiét bị
Dùng kèm -webkit-font-smoothing: auto/none/antialiased/subpixel-antialiased (nét chữ sắc nhất) => MacOs
-moz-osx-font-smoothing: auto/grayscale => Firefox MacOS 
- font-display => Chỉ định cách hiển thị font khi chưa tải xong. default auto. 
block: text sẽ bị ẩn nhưng vẫn chiếm k gian (tối đa 3 giây) trong khi chờ font tải xong, sau đó sẽ hiển thị với font mong muốn.
swap: text hiển thị ngay lập tức bằng font dự phòng, sau đó thay thế bằng font mong muốn khi tải xong => luôn dùng css reset

-> Font size clamp:
Màn hình luôn được chia thành 100 vw và vh. VD màn hình là 1460px thì 1vw sẽ tương ứng với 14.6px
clamp(a, b, c); lấy 1 giá trị trong khoảng a và c. Nó ss lấy min(b,c) là x rồi lấy max(a, x) trả ra kết quả. Nên dùng min, max, clamp thay thế width, max/min-width.
URL: https://clamp.font-size.app
VD màn hình dưới 700px có font-size là 16px, sau đó tăng dần tuyến tính lên 1px mỗi 100px tăng lên cho đến max là 22px => font-size: clamp(16px, 1vw + 9px, 22px);
Khi 700px, nó sẽ là clamp(16px, 16px, 22px) thì lấy 16px. Font size tuyến tính tăng lên 1300px thì clamp(16px, 22px, 22px) thì lấy 22px

--> Gợi ý:
Màn hình break point: 500 - 1300 - 1900 => đặt ở 2 mốc 500 và 1300 là được
1) Màn hình lớn: text thường 16px, chữ to 20px, title 24px, chữ khổng lồ 48px, button 16px
Màn hình mobile: text thường 14px, chữ to 16px, title 20px, chữ khổng lồ 36px, button 14px 
2) Màn hình lớn: text siêu bé 12px, text thường 14px, title 16px, chữ khổng lồ 40px, button 14px
Màn hình mobile: text thường 12px, title 14px, chữ khổng lồ 20px, button 14px

-> Color font thêm màu. Tut: https://www.youtube.com/watch?v=VpZSMq2ajDE
URL web check màu color font support: https://wakamaifondue.com/
@font-palette-values --identifier {
  font-family: Bixa;
  base-palette: 3; // trong web từ trên xuống là các palette font hỗ trợ
  override-colors: 0 rgba(0,0,0,1), 2 red; // trong web từ trái sang là các color index để override
}
.my-class {
  font-palette: --identifier;
}

-> K dùng px vì browser đổi font-size và px sẽ override browser setting. Khi font-size tăng, nhiều nơi khác cũng nên tăng. 
Với kích thước bth như @media hay padding margin nên dùng rem, font-size cũng dùng rem. Với spacing liên quan đến text mới dùng em. 
VD box-shadow dùng px thoải mái vì chả liên quan đến font. Hoặc ảnh hay cái gì k phụ thuộc vào font-size mà cố định ở mọi màn hình thì để px.

-> Custom chữ trang trí:
-webkit-text-stroke: 1px black; => text-stroke tạo 1 đường viền ngoài cho svg, mà font thực chất là svg nên tạo viền cho font. Thường kết hợp thêm với text-shadow.
paint-order: stroke fill; => stroke được vẽ trước r mới fill màu lên tạo chữ đẹp hơn là để mặc định
Còn có text-fill kiểm soát màu > color

-> Nhanh:
- Thêm font remote với @import, local với @font-face. Dùng variables font k phải định nghĩa từng style. Web safe font, fallback font.
- font size clamp
- Có thể custom màu color font
- Dùng rem với kc phụ thuộc font, nếu kc liên quan đến text thì dùng em.
- Dùng text-stroke + text-shadow + paint-order tạo chữ đẹp



# Đơn vị trong CSS
-> Đơn vị tuyệt đối chỉ đúng trên các thiết bị độ phân giải cao như máy in, còn trên laptop và di động có thể sai khác. VD 1in = 96px = 2.54cm

-> Relative Units
em: tương đối so với font-size của phần tử cha
*rem (root em): Giống em, nhưng là tương đối với phần tử gốc <html>, hoặc theo setting browser nếu k set.
ex: Tương đối so với chiều cao chữ "x" của font hiện tại.
ch: Chiều rộng của ký tự "0" trong font đang dùng
*vw: Tương đối 1% width của kích thước cửa sổ trình duyệt (viewport).
*vh: Tương đối 1% height của kích thước cửa sổ trình duyệt (viewport).
vmin Relative to 1% dựa trên chiều nhỏ hơn của trình duyệt. VD điện thoại xoay dọc thì vmin sẽ là 1% của height
vmax Relative to 1% dựa trên chiều lớn hơn của trình duyệt
*%: Có giá trị tương đối so với phần tử cha.
=> Tức browser default 1rem = 16px or setting browser, nên set :root là 1rem or default luôn, các thẻ khác cũng dùng rem nhưng font to hay nhỏ set với dùng clamp là xong.

--> Các đơn vị đặc biệt cho mobile: lvh, dvh, svh, svw 
vh là chiều cao cơ bản, k tính toolbar.
lvh là chiều cao lớn nhất khi k có toolbar, svh là chiều cao nhỏ nhất khi k có toolbar
dvh là chiều cao dynamic tự thay đổi khi toolbar ẩn hoặc hiện => luôn dùng thay vh khi ứng dụng có chạy trên mobile

-> Nhanh:
Dùng rem em (px khi klq tới font) và dvh



# Private custom variable
VD click chuột là đổi màu vài thẻ thì nên dùng css var và đổi giá trị var thay vì gán lại style từng thẻ, tốt hơn cả việc gán class. Có thể dùng để tạo theme khác nhau.

-> Trong dự án lớn, nên dùng fallback var + kế thừa + private custom var. 
Lưu ý chỉ đè private var tối đa 1-2 lần thôi, k đè nh lần.
VD: <div class="container">
  <div class="hello">
    <button>Hello</button>
    <p>Hello</p>
  </div>
  <div class="hi">
    <button>Hi</button>
    <p>Hi</p>
  </div>
  <div class="bye">
    <button>Bye</button>
    <p>Bye</p>
  </div>
</div>

Cách làm ngu:
.hello button {
  color: red;
}
.hello p {
  box-shadow: 1px 1px 1px red;
}
.hi button {
  color: blue;
}
.hi p {
  box-shadow: 1px 1px 1px yellow;
}
.bye .button {
  color: green;
}
.bye p {
  box-shadow: 1px 1px 1px red;
}

Best practice là dùng private custom variables
.container {
  --_shadow: var(--shadow, red);
  --_color--text: var(--color, var(--color-text, red));
}
.container button {
  color: var(--_color--text);
}
.container p {
  box-shadow: 1px 1px 1px var(--_shadow);
}
.hi {
  --_shadow: yellow;
  --_color--text: blue;
}
.bye {
  --_color--text: green;
}
=> Nó giúp giảm số lượng css selector. Nhìn custom var, ta hiểu ngay là biến định nghĩa trong container thay vì tìm trên :root. 

-> @property trong css houdini giúp khai báo biến css type safe, nên dùng với animation.
Bản chất @property là khai báo biến và nó trở thành 1 thuộc tính (property) của css class đó luôn.
VD: @property --rotation {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}
.box {
  --rotation: 60deg;
  transform: rotate(var(--rotation));
  transition: --rotation 1s ease-in-out;
}
=> Transition trực tiếp biến --rotation được vì nó như 1 thuộc tính của class r.



# Metadata SEO
***Mọi tag trong <head>: https://github.com/joshbuchea/HEAD

-> Config thường dùng:
<title>Title</title>
<meta name="description" content="Test setup website">
<meta name="keywords" content="test,setup"/>
<link rel = "canonical" href = "http://example.com/"/> => 1 web có nhiều url dẫn tới cùng 1 nội dung, gg không biết url nào nên hiển thị trên kết quả tìm kiếm. Luôn dùng thẻ canonical trỏ tới url gốc để thông báo cho search engine URL này là trang chính.
<link rel="preload" as="image" href="./logo.svg"/> => ưu tiên preload
<link rel="icon" href="./logo.svg"/>

<meta property = "og:type" content = "article" /> => hay content="website"
<meta property = "og:title" content = "TÊN TIÊU ĐÊ HOẶC TRANG WEB" />
<meta property = "og:description" content = "MÔ TẢ CỦA TRANG NỘI DUNG" />
<meta property = "og:image" content = "./assets/logo.svg" />
<meta property = "og:image:alt" content="Collection Image"/>
<meta property = "og:url" content = "PERMALINK" />
<meta property = "og:site_name" content = "TÊN TRANG WEB" />
<meta property = "og:locale" content="en_US"/>

<meta name = "twitter:title" content = "TÊN TIÊU ĐỀ HOẶC TRANG WEB"> => ghi đè og:title vì og là thẻ chung, các thẻ từng nền tảng sẽ ghi đè og
<meta name = "twitter:description" content = ”"MÔ TẢ TRANG NỘI DUNG">
<meta name = "twitter:image" content = "LINK TO IMAGE">
<meta name = "twitter:site" content = "USERNAME">
<meta name = "twitter:creator" content = "@ USERNAME">

VD khi có nhiều lang:
<link href="https://opensea.io" hrefLang="en" rel="alternate"/>
<link href="https://opensea.io/zh-CN" hrefLang="zh-CN" rel="alternate"/>
<link href="https://opensea.io/zh-TW" hrefLang="zh-TW" rel="alternate"/>
<link href="https://opensea.io/de-DE" hrefLang="de-DE" rel="alternate"/>

<meta name="viewport" content="width=device-width, initial-scale=1.0"> => luôn có thẻ như này để cho phép người dùng zoom-in text, điều này phù hợp với những người thị lực yếu vào website, họ sẽ phải dùng các tool giúp zoom to trang web để nhìn rõ, VD CTRL+ của browser. Có thể custom: 
<meta name="viewport" content="user-scalable=yes"/> => cho phép người dùng sử dụng các tool zoom cho trang web
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=1"/> => chỉ cho max scale đến 200%
<meta name="viewport" conent="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/> => k cho zoom vì sợ break design
=> 1 số thiết bị có tính năng zoom text only, nhưng nếu text zoom to mà layout k zoom sẽ break design

-> Tối ưu SEO:
- Dùng đủ alt cho image
- Nên dùng senmatic element tốt cho SEO vì tạo cấu trúc nội dung rõ ràng hơn cho search engine hiểu:
header và footer ở đầu cuối page; figure chứa img và figcaption khi cần ảnh có chú thích; nav tạo navigation; aside tạo content related indirect to main; main chứa các article; article có các section; section có detail, detail có content bth và 1 thẻ summary; <mark> để highlight important text
Các thẻ heading h1 h2 chỉ nên dùng cho heading chứ k chủ động dùng để tạo big text vì search engine dùng heading để đánh index cho nội dung page
1 số thẻ đặc biệt như <time> biểu diễn thời gian. VD: <time datetime="2008-02-14 20:00"> thì thời gian trong attribute này sẽ được dịch sang machine-redable format và browser có thể thêm date này vào reminder của user's calendar nếu có và search engine cũng cho kết quả search thông minh hơn.
- Mỗi thẻ h1, h2 nên có id để có url # ref tới vị trí đó nhanh, k giúp SEO nhưng UX tốt hơn:
document.querySelectorAll("h2").forEach(function(el) {
  if (!el.hasAttribute("id")) {
    el.setAttribute("id", el.textContent.replaceAll(/[^a-z]/gi, ''));
  }
});

-> Preload ảnh:
<link rel="preload" as="image" href="/static/images/logos/opensea.svg"/>
<link rel="preload" as="image" imagesrcset="
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=640 640w, 
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=750 750w,
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=828 828w,
" imagesizes="100vw"/>
Có thể preload 1 ảnh cố định, preload 1 file hay preload ảnh nào trong list tuỳ theo kích thước màn hình. 
VD ở đây imagesrcset có 3 bức ảnh có 3 chiều rộng khác nhau và imagesizes chỉ rằng ảnh sẽ chiếm full màn. Tuỳ kích thước màn, browser tự chọn 1 trong 3 ảnh phù hợp kích thước để tải trước và cache lại. Mọi chỗ trong web sử dụng đúng url ảnh đã cache sẽ lấy luôn từ cache ra, nên thường kết hợp với srcset của <img>

-> <link rel="prefetch" href="products.html">
Preload chỉ dùng cho page hiện tại, session hiện tại, với tài nguyên cần gấp. Chỉ nên preload ít để tránh page tải lâu.
Prefetch chỉ chạy khi browser rảnh và thường query tài nguyên cho next page k cần dùng ngay. Thời gian cache sẽ theo Cache-Control, or browser hard refresh cũng tải lại.
Trong quá trình dùng web, tag này được add bằng JS cũng khiến browser tự prefetch url.

-> Google bot tự đánh chỉ mục với mọi trang web mà nó truy cập được, trừ khi có robots.txt hay thẻ meta robots cản nó => thường để robots.txt default or k cần. Dùng khi có trang k cần đánh index thì đỡ tốn crawl budget cho các trang kqtr.
VD1 robots.txt có tác dụng trong toàn page, chỉ cần đặt file này vào cùng file gốc index.html:
User-agent: *
Disallow: /page2.html
=> Googlebot đọc mọi pages trừ page2.html
VD2 <meta name = "robots" content = "noindex, nofollow"> => Không lập chỉ mục hay không theo dõi các liên kết từ page này.
<meta name = "robots" content = "index, follow"> => Có lập chỉ mục và theo dõi các liên kết từ trang này 
VD3: cho robots.txt cản pages2, nhưng trong pages 2 lại dùng thẻ meta robots cho phép index, thì googlebot gặp robots.txt sẽ bỏ qua pages2 luôn và chưa kịp thấy thẻ meta nên k đánh index

-> Sitemap: robots.txt là file kiểm soát quá trình crawl của search engine, còn sitemap.xml giúp search engine đánh chỉ mục dễ hơn sẽ SEO tốt hơn.
Sitemap chứa thông tin về các url cần crawl và cấu trúc nội dung giúp dễ đánh chỉ mục hơn với web có nội dung dài.
Tạo sitemap.xml đặt cùng index.html, thêm cả robots.txt để gg biết, host lên, đăng ký sitemap với Google Search Console theo dõi thống kê để biết mà cải thiện SEO.
=> Web phức tạp nhiều content thì nên có vì giúp crawl dễ hơn

-> Nhanh:
Config thường dùng về canonical, og, language
Dùng senmatic element, dùng h1 h2 kèm id.
Preload ảnh, prefetch file.
robots.txt và sitemap.xml => đọc qua



# Speculation rules
URL: https://www.youtube.com/watch?v=LEF4UaM5m4U
- Speculationrules cho prefetch và prerender trong html cho tốc độ siêu tốc. Chỉ cần thêm 1 tag script là xong.
prefetch chỉ tải html, prerender sẽ tải hết và chạy cả js bên trong, fetch cả các API GET nếu có để client chỉ cần render ra.
- Trong browser tab application có speculation rules hiển thị các trang đã được prefetch hay prerender.
- Khác với <link rel="prefetch> luôn prefetch ngay thì speculation rules có option eagerness kiểm soát nhiều hơn.
- eagerness mặc định là immediate tức page load là tải ngay prefetch luôn, nếu prerender sẽ tải hết tài nguyên, sẽ k ổn vì page lớn có quá nhiều file.
eager không khác immediate là mấy, cũng tải nhưng k vội. eager và immediate giới hạn tải 50 pages trước thôi. Chú ý mỗi file html tải trước sẽ là 1 files, chưa tính các tài nguyên bên trong.
moderate y hệt nhưng giới hạn max 2 pages, phải hover vào link hay scroll gần tới mới prefech. VD hover vào 3 đường link thì đường link đầu sẽ bị stale.
conservative cũng max 2 page nhưng user phải click vào link mới prefetch, nên chỉ lợi được 1 tí.
=> Có thể kết hợp page bth thì load moderate, page khác hay vào hơn thì load immediate.
- Việc prerender sẽ exec code JS và chạy trước các API GET luôn sẽ rất nguy hiểm. VD trang logout prerender execute code luôn là toang. 
Có nhiều cách fix như để request post thay vì GET để logout.
- Khi prerender sẽ gửi request kèm 1 header đặc biệt. VD nếu setup analytics thì k được tính số lần tải pages mà phải check vào pages k ở trạng thái prerender mới được.
Giải pháp là check khi thực sự vào 1 pages được prerender mới chạy analytics:
if(document.prerendering) { // true khi được tải bằng prerender
  document.addEventListener( "prerenderingchange", // event phát ra khi đổi trạng thái từ prerender sang k prerender nữa, VD khi thực sự access 1 pages đã được prerender
    func, { once: true }
  );
} else { func(); }
- Speculation rules k dùng reactjs vì nó là CSR. NextJS có prefetch sẵn rồi nhưng vẫn có thể dùng bằng cách thêm <script> nếu muốn kiểm soát

-> Nhanh:
Speculation rules là prerender mới exec hết code JS bên trong.
Option eagerness giúp kiểm soát prefetch/prerender, prerender cẩn thận exec hết api GET bên trong
Có thể check page tải là prerender hay vào bth.



# Random css
random(min, max, step)
random(min, max)
random(--per-element, min, max) => tái sử dụng nhiều nơi, mỗi nơi sẽ có 1 giá trị random độc lập



# a11y
Dùng thẻ a navigate thay vì button sẽ tốt cho a11y và SEO hơn. Single page thì dùng <a href="#idofelement"/>

-> Các thẻ chi tiết luôn dán nhãn, nhất là các thẻ chỉ có icon k có text mô tả:



Dùng với aria-label được: <button aria-label="Tìm kiếm">
Dùng với aria-labeledby khi cần 1 hoặc nhiều thẻ khác làm nhãn cho thẻ hiện tại. VD:
<p id="label1">Giỏ hàng:</p>
<p id="label2">Bạn có 3 sản phẩm.</p>
<div role="region" aria-labelledby="label1 label2">
  <!-- Nội dung -->
</div>

-> Để có a11y tốt khi dùng tab, đảm bảo ấn tab và mũi tên là có thể navigate được.
Cách dùng aria cho tabs: https://www.w3.org/WAI/ARIA/apg/patterns/tabs/

role="tablist", role="presentation", tabindex, role="tab", role="tabpanel"
Thuộc tính role sẽ loại bỏ ý nghĩa senmatic của thẻ, VD role="presentation" cho thẻ li chỉ định rằng phần tử có mục đích trình bày (decorative), không mang ý nghĩa semantic hay chức năng trong ngữ cảnh hiện tại, tức thẻ li không còn biểu hiện cho list nữa và sẽ bị bỏ qua trong accessibility tree, screen reader sẽ không đọc hoặc thông báo về nó

Mặc định ấn key tab sẽ navigate qua mọi thẻ a trên page. Nếu dùng tabindex="-1" cho 1 thẻ sẽ bị bỏ qua khi nhảy tab. Nếu dùng tabindex="0" cho các thẻ khác như div thì nó sẽ nhảy vào cả các thẻ đó. Điều này tiện cho việc ấn key tab vào 1 tab, và ấn key tab tiếp sẽ vào content của tab kể cả div đó chứ k nhảy qua
Set bằng JS, ta cho mọi tab k active có tabindex="-1", tab đang active và nội dùng của nó có tabindex="0"

Thuộc tính hidden k chỉ ẩn thẻ đi mà cũng ẩn nó khỏi accessibility tree, tương tự display none. Còn visibility: hidden chỉ ẩn trên UI mà k ẩn trên accessibility tree. 
VD dùng display none / hidden + aria-hidden="false" => k hoạt động, sẽ ẩn khỏi tree. Dùng visibility hidden + aria-hidden="false" ok UI k có mà a11y vẫn hđ

aria-selected="true" bảo screen reader biết hiện đang ở tab nào, nó cũng tác động vào style tag nào là tag đang được chọn

aria-controls k nên dùng, nếu muốn thêm thông tin mô tả cho tab thì có thể dùng: aria-describedby="idofelement" và dùng 1 thẻ <div id="idofelement" aria-hidden="false" style="visibility:hidden;"></div> để thêm nếu cần. Nội dung của thuộc tính này được sử dụng khi ngừoi dùng vào tab đó và screen reader đọc nó lên cho ngừoi dùng nghe.

Ấn key left right để switch tab thì phải tự custom tạo hàm riêng thao tác với DOM thôi. Bắt sự kiện keydown.
Điều đặc biệt là khi ta add event keydown cho tabContainer thì chỉ khi ấn tab focus vào tabContainer thì keydown của nó mới bắt chứ ngoài màn hình gõ sẽ k ảnh hưởng

-> Tạo tab html thuần
- Mỗi tab nên ở cùng pages và k chuyển pages. Vì chỉ đổi tab nhưng mọi phần code html chung lại phải copy ra nhiều file.
Cũng phải lưu lại vị trí scroll với các state data khác vào sessionStorage, trước khi chuyển, và khi page onload phải lấy lại data rất rối.
- Đơn giản có thể viết nội dung tab hết 1 file rồi xử lý JS để display none hay hiện ra khi ngừoi dùng ấn vào tab
- Để chuyển tab có thể dùng label checkbox để bắt và hiển thị content bằng HTML CSS thuần, hoặc dùng JS luôn được. Có thể animation content hiện ra ok.
Có thể tạo animation slide từ 2 hướng khi chuyển tab, buộc phải dùng JS khi đó để xác định hướng cho animation, mỗi animation 1 keyframe riêng.
- Có thể dùng window.history.pushState để đổi url mà k chuyển page, kèm xử lý onload. Để khi chuyển page sẽ đổi url, gõ url vào sẽ hiển thị đúng đang là tab nào.
- Dùng kèm view transition api là thành animation đỉnh chóp

-> Nhanh chỉ cần set: aria-label, aria-labelledby, aria-describedby, aria-hidden, aria-selected, aria-controls, aria-current, aria-autocomplete (kèm input autocomplete), title, alt, role, aria-expanded
Icon thì nên có aria-hidden hoặc mô tả bằng aria label cho tag bao nó
aria-controls xác định quan hệ điều khiển, phần tử này điều khiển phần tử khác. Vd 1 button điều khiển dialog, menu, tab panel. Dùng label for để toggle thì k cần
VD: <button aria-controls="idofdialog">. Tương tự aria-expanded cho button ấn button là mở rộng gì đó, cập nhật bằng JS khi mở và đóng là true và false, nó thể hiện trạng thái hiện tại của dialog

--> Bộ 3 aria-errormessage, aria-invalid dùng cho thẻ input khi bị lỗi, aria-required báo input này k thể để trống:
<input id="email" type="email" aria-invalid="true" aria-errormessage="email-error" aria-required="true">
<span id="email-error" role="alert">Email không hợp lệ</span>
Bộ 3 aria-controls, aria-expand và aria-haspopup cho button thể hiện có menu hay danh sách thả hay hộp thoại:
<button aria-haspopup="dialog" aria-controls="login-dialog">
  Đăng nhập
</button>
<div id="login-dialog" role="dialog" hidden>
  <p>Vui lòng nhập thông tin đăng nhập.</p>
</div>
Bộ 2 aria-selected và aria-multiselectable báo có thể chọn nhiều options:
<ul role="listbox" aria-multiselectable="true">
  <li role="option" aria-selected="true">Mục 1</li>
  <li role="option" aria-selected="false">Mục 2</li>
  <li role="option" aria-selected="true">Mục 3</li>
</ul>
aria-readonly là 1 phần tử chỉ đọc k thể tương tác:
<label for="username">Tên đăng nhập:</label>
<input id="username" type="text" aria-readonly="true" value="user123">

-> pointer-events: none; sẽ cản sự kiện của 1 thẻ. VD ứng dụng navigation bar đang ở tab .active thì ấn vào sẽ k load lại chính trang hiện tại nữa có thể dùng.

-> Trong devtool browser có Elements Accessibility tool

-> Dùng ul li a header h1 p nav main article section aside footer




# Xử lý image
URL: https://bennettfeely.com/clippy/ => kích thước vẫn thế nhưng hiển thị cut ảnh clip-path
URL: https://www.youtube.com/watch?v=oWXm5n-Zi38 => thực sự học master clip-path
URL: https://css-generators.com/svg-to-css/ => convert hàm path thành hàm shape dùng cho clip-path trong css. Shape y hệt nhưng friendly hơn thôi.
URL: https://yqnn.github.io/svg-path-editor/ => linh động hơn

=> Ứng dụng tạo diamond grid: https://www.youtube.com/watch?v=A5GXdjEOvos&list=WL&index=98

-> Vì để phòng khi ta dùng ảnh low res load trong background-image. Nên kết hợp với: 
<link rel="preload" as=image href="./lowresimage.png" fetchpriority=high>
Thẻ <img> nên luôn set width height ngay trong nó để tránh layout shift, kèm với background-image low res.

-> Có multiple background image. background-size background-image background-repeat background-color (dùng kèm background image được sẽ nằm ở dưới)
background-position kiểu vị trí x,y của ảnh trùng với vị trí x,y nào của khung. VD center center hay 0 0 là tâm ảnh trùng tâm khung hay 0,0 của ảnh trùng 0,0 của khung. background-image hiện trong phạm vi content, nếu dịch tràn ra ngoài sẽ k dịch chuyển trừ khi cho repeat hoặc background-size lớn 

background: <background-color> <background-image> <background-position> / <background-size> <background-repeat> <background-attachment> <background-origin> <background-clip>;
VD: background: red url('image.jpg') center / cover no-repeat fixed padding-box content-box;

background-origin xác định vị trí của background image theo content. 
background-clip text => sẽ lồng background image vào trong text, buộc phải bỏ màu của text mới hiển thị ảnh, color or -webkit-text-fill-color: transparent; => giải quyết vđ k set gradient color cho text color đc
background-blend-mode chỉ có tác dụng khi có màu chồng lên nhau: https://www.w3schools.com/cssref/playdemo.php?filename=playcss_background-blend-mode
background-attachment: scroll mặc định là trôi theo page scroll bar; local là trôi theo scrollbar của content; fixed là background fix k trôi, tạo parallax

background-repeat space tương tự repeat nhưng repeat bị cắt khi ra ngoài phạm vi vì kích thước content k thể luôn chia hết cho kích thước background được. Còn space sẽ xếp mà k bị cắt, khoảng trống thừa ra sẽ chia đều giữa các ảnh

VD: background-origin apply cho cả background-color và background-image, k thể chỉnh riêng hay chia từng image

-> Các thuộc tính image filter: https://www.w3schools.com/css/tryit.asp?filename=trycss_ex_images_filters

-> Layer mask: mask là shorthand của mọi thuộc tính mask-* trong css
Dùng style cho 1 thẻ để tạo 1 lớp hiệu ứng bên trên thẻ đó. VD hiển thị bức ảnh theo phần ảnh của 1 bức ảnh khác, ta cho bức ảnh khác đó lên 1 lớp bên trên.
VD mask-image: linear-gradient(black, transparent);
VD mask: url(masks.svg#star) 0 0/50px 50px no-repeat; => đặt mask tại vị trí 0 0 từ top left và width height mask là 50px 50px, lấy thẻ có id là star trong hình svg
VD mask: url(masks.svg#star) left / 16px repeat-y; => element là mask ở phía bên trái với width 16px. Mask position phải xác định 2 giá trị như left top, mặc định nếu chỉ set 1 giá trị thì giá trị còn lại sẽ là center
VD Mask mờ 2 bên thẻ:
mask: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, black 20%, black 80%, rgba(0, 0, 0, 0) 100%);
-webkit-mask: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, black 20%, black 80%, rgba(0, 0, 0, 0) 100%);
Còn có mask composite

-> Setup image:
Setup ảnh object-fit contain, object-position center center, min-width width aspect-ratio, border-radius, overflow hidden

--> Dùng onError check ảnh lỗi thì hiển thị ảnh lỗi mặc định chứ k show hình lỗi xấu.
HTML có thẻ object show mọi loại media, nếu bị lỗi sẽ tự show thẻ con của thẻ object rất hay => ít dùng vì kp chuyên cho ảnh.
onLoad check ảnh tải xong => có thể dùng ẩn spinner nếu dùng 1 thẻ spinner riêng hay lấy kích thước ảnh sau khi tải xong.

VD: <img src="invalid_link" onerror="this.onerror=null;this.src='https://placeimg.com/200/300/defaultiamge';" >
Việc dùng this.onerror=null chống lỗi infinity loop. Lỗi này xảy ra ở 1 số trình duyệt khi chính ảnh để ta fix lại bị lỗi xong lại chạy onerror lại lỗi và cứ lặp vô tận
Nếu sợ lỗi infinite loop, thì có thể set 1 bức ảnh backup onerror local đảm bảo luôn tồn tại là được => ***nếu sợ lỗi mạng, dùng base64 cho blur image đảm bảo ảnh đó sẽ luôn exist.

--> Dùng lib: Khi làm với react thì onError k hỗ trợ mọi browser nên thư viện react-lazy-load-image-component sẽ lo điều đó với mọi browser
Thuộc tính PlaceholderSrc của LazyLoadImage nhận 1 ảnh kích thước nhỏ để hiển thị ra trước khi ảnh lớn được load. Ta có thể giảm độ phân giải ảnh bằng các công cụ chỉnh sửa để thế vào, thêm effect="blur" để làm mờ ảnh placeholder được
Lib react-progressive-graceful-image rất phù hợp dùng được thay thế cho tag object của html hiển thị ảnh placeholder, nếu ảnh lỗi thì chỉ hiển thị placeholder mặc định

--> Lazy loading ảnh: thuộc tính loading="lazy"/"eager" có sẵn của html

--> Ảnh nên nhét vào 1 container có aspect ratio và width responsive: có thể set contain và hiện trong khung, hoặc cover theo 1 trong 2 chiều, hiện ở tâm
Luôn set min-width min-height cho ảnh giảm layoutshift khi load xong

-> Ưu tiên dùng ảnh SVG để tránh bị mờ khi zoom lớn: svg dùng đồ họa vector có animation. Có thể tách file html riêng và cho vào <img>, or nhúng trực tiếp néu cần style.
SVG Sprites là pp gom các ảnh từng phần vào 1 file duy nhất và chỉnh vị trí cho chuẩn. Thay vì server nhận nhiều request từng tấm ảnh nhỏ thì chỉ cần 1 bức SVG là được
Có nhiều tool giúp vẽ tay SVG: https://topdev.vn/blog/svg-la-gi/

-> Các pp tạo ảnh mờ làm placeholder thay vì 1 màu xám hoặc 1 ảnh default hoặc skeleton loading:
- Tạo ảnh mờ mà ta có sẵn thì thu nhỏ r phóng to là xong
- Ảnh người dùng nhập có thể dùng BlurHash - lib giúp tạo ảnh mờ từ 1 ảnh khác, paste ảnh vào và lấy ra hash làm mờ.
- Data URL là 1 cách load ảnh bằng code với base64. Khi nhúng ảnh base64 vào code, tốc độ transfer ảnh tới client sẽ nhanh hơn nhưng trên mobile lại chậm hơn vì ngốn CPU render ảnh. Khi nhúng src http thì web phải fetch lần nữa tới src đó nên có thể lâu hơn nhưng k bị ngu trên mobile
1 cách khác là load image blur với base64, giảm chất lượng và chuyển sang base64 bằng tool khác, image thực thì để link url bth
Web chuyển ảnh thành data uri dạng mờ không cần dùng thư viện blur hash: https://blurred.dev/
- Cloudinary cung cấp url giúp tải ảnh blur nhẹ hơn của 1 image. 1 cách generate blur dynamic image.
VD URL gốc: https://res.cloudinary.com/hieucuopbien123/image/upload/v1688738028/eokcgjfzuedo2oobnzzb.png
Làm mờ nhẹ hơn: https://res.cloudinary.com/hieucuopbien123/image/upload/e_blur:100/v1688738028/eokcgjfzuedo2oobnzzb.png
Làm mờ kèm grayscale nhẹ hơn nữa: https://res.cloudinary.com/hieucuopbien123/image/upload/e_blur:1000,q_1,f_auto/v1688738028/eokcgjfzuedo2oobnzzb.png
Full tut custom: https://cloudinary.com/blog/low_quality_image_placeholders_lqip_explained#the_javascript_options_for_generating_lqips
Cloudinary cũng có cách giảm kích thước ảnh tối đa mà k mất chất lượng: https://cloudinary.com/blog/adaptive_browser_based_image_format_delivery

-> Tối ưu nén ảnh:
Các bức ảnh tĩnh đều nên cho qua tinyPNG / imagemin để giảm tải kích thước trước r mới lưu vào server.
Dùng định dạng WebP or AVIF sẽ giảm kích thước 30% so với jpg
Hoặc dùng cloudinary hay thư viện browser-image-compression để compress ảnh khi người dùng upload trước r mới lưu vào server.
Các framework như NextJS cung sẵn khi ta cho optimized true trong file config, nó còn optimize theo kích thước màn hình
Có thể tự chuẩn bị sẵn các bức ảnh khác nhau thủ công và cho load theo kích thước màn hình => có thư viện react giúp

-> Dùng <picture> tự đổi ảnh tùy vào kích thước màn hình mà k cần css hay js. <source> chỉ cung url, còn lại vẫn dùng tag image để chèn ảnh vào
VD: <picture class="image_container">
  <source media="(min-width:650px)" srcset="https://www.w3schools.com/tags/img_pink_flowers.jpg" type="image/jpg">
  <img src="" alt="" onerror="this.onerror=null;this.src='base64image';" loading="lazy">
</picture>

-> K dùng ảnh gif bị nặng hơn video rất nhiều. Dùng với các ảnh nhỏ muốn lặp vô hạn mà k cần media player thì ok => éo bh cần
K thì nên dùng APNG hơn


img src="image-400.jpg"
     srcset="image-400.jpg 400w, 
             image-800.jpg 800w, 
             image-1200.jpg 1200w"
     sizes="(max-width: 600px) 400px, 
            (max-width: 900px) 800px, 
            1200px"
     alt="Mô tả ảnh">





# Dùng scroll
Cơ bản tạo scrollbar trong 1 box: cho box là inline-block, white-space nowrap, overflow-x auto, set width không được fit-content mà responsive màn hình, thẻ con bên trong phải set minWidth bằng kích thước của box.
Tức chỉ cần cho container kích thước nhỏ hơn content và set overflow có scrollbar là được.
=> refer tới "Projects / Tinkerbellgarden"

overflow: clip; kết hợp với overflow-clip-margin: 30px; để kiểm soát overflow vẫn tràn ra ngoài mà k chiếm thêm kích thước

-> Custom style scrollbar: https://css-tricks.com/custom-scrollbars-in-webkit/
URL: https://www.w3schools.com/howto/howto_css_custom_scrollbar.asp
K dùng kèm scrollbar-width thin được mà set trong shadow dom, k sẽ lỗi

-> Để nhảy đến 1 vị trí trên trang html: đặt id rồi tại thẻ nào ta dùng tag a href đến #đó là được
scroll-behavior: smooth hay auto để trượt đến hay nhảy đến

-> overscroll-behavior: khi 2 scroll lồng nhau, cục bên trong scroll tới đích mà vẫn lăn tiếp chuột ở cục trong thì cục ngoài sẽ scroll (scroll chaining), contain để cản. Trên điện thoại tự có bounce effect, none để cản thêm bounce effect.

-> Có thể ẩn thanh scrollbar nhưng vẫn giữ nguyên chức năng

-> Dùng scroll-snap
- scroll-snap-type: x mandatory; xác định hướng và kiểu scroll. proximity là scroll tới sát mép card mới tự scroll vào đúng vị trí card nếu k sẽ lơ lửng, mandatory là trình duyệt tự snap theo từng điểm scroll mọi lúc theo cách ta dùng scroll-snap-align 
- scroll-snap-align là từng item sẽ có vị trí như nào với container bao nó. VD center là điểm giữa item trùng điểm giữa container, tương tự start và end. Điểm giữa của chiều nào tùy thuộc type dùng x hay y
- scroll-snap-stop: là khi lướt quá nhanh sẽ luôn dừng ở từng element(always) hay cho lướt qua(normal)
- Đôi khi ta k muốn chuẩn kiểu item hiển thị đúng ở 3 vị trí mà hiển thị ở hơi mé bên trái cách 1 vài pixel cơ thì:
scroll-padding dùng ở container sẽ cho mọi item bên trong được quyền hiển thị cách mép 1 khoảng bnh
scroll-margin dùng ở từng item sẽ cho phép cụ thể 1 item nào được phép hiển thị cách mép bnh
=> dùng được 4 chiều left right top down. Thường để kích thước container chia hết cho kích thước card bên trong

-> Scrollbar nên tạo chuẩn 1 thẻ con chứ body và html nên để overflow hidden cho dễ customize về sau:
- Khi scroll các thẻ liên quan, sẽ k ảnh hưởng đến scrollbar các thẻ khác, chứ scroll thẻ body sẽ ép mọi thẻ scroll
- Style chuẩn trong 1 phạm vi nhất định

-> K thể tạo được scrollbar có background transparent, chỉ cố tạo tạo background theo màu thẻ body thôi.
K nên dùng loading bar ngang: fetch API thì k nên vì mỗi component là loading độc lập; scroll thì phải đặt trong tag content và position fixed theo màn hình vì ta k scroll thẻ body; nếu chuyển page thì loading ngang thì k được vì MPA sẽ k thể tính được



# Xử lý màu
Tool sinh code gradient: https://angrytools.com/gradient/

-> Gradient css có 3 loại: linear kéo từ 1 phía sang 1 phía, radial kéo từ 1 điểm lan ra xung quanh, conic-gradient
--> Chú ý dùng background gradient thì truyền vào background chứ kp background-color
VD: background: linear-gradient(direction, color1, color2, color3, color4, ...);
VD: radial-gradient(circle closest-corner at 100px 100px, red 10%, yellow 20%, pink 10%); 
shape là circle, elipse (default, bóp méo theo khung bên ngoài)
size có thể là closest-side, farthest-side(default), closest-corner, farthest-corner at ... để set kích thước => tức màu cuối của radient chạm cạnh nào của box bao nó thì dừng
--> repeating-linear-gradient

-> Các cách lấy màu: rgba(255,0,0,0.5); rgb(255,0,0); hsl(0, 1005, 50%), hsla(0,100%,10%,0.3); #ffffff; dùng tên trực tiếp red, yellow
hsl thì hue có giá trị từ 0 đến 360, 0 và 360 cùng là đỏ.
color-mix giúp mix 2 màu trong không gian màu nào

-> mix-blend-mode: difference; => giúp đổi màu tương phản cực mạnh, nên dùng mọi lúc khi cần màu đổi ngay lập tức khi background đổi mà k sợ trùng màu bị ẩn đi
backdrop-filter: blur(5px); => style cho area trong phạm vi element nhưng đằng sau element => tạo glass morphism

-> Còn có sự sai lệch về màu sắc khi dùng browser khác nhau, đặc biệt là Safari so với Webkit. 
Ta k nên giả định 2 màu là giống nhau ở 1 thẻ so với 1 bức ảnh hay video. VD: video có màu nền là #f12312 vì ta dùng devtool để lấy màu => ta k thể dùng 1 thẻ cũng có màu #f12312 và giả định rằng 2 màu giống nhau được, đặt video bên cạnh thẻ kia sẽ thấy khác màu ở 1 số browser khác.

Có những màu đẹp có sẵn được support chuẩn ở mọi browser nên dùng: https://www.w3schools.com/cssref/css_colors.php

-> gradient nhìn đẹp hơn khi dùng không gian màu oklch thêm vào đầu
VD: linear-gradient(in oklch, red, blue);

-> Dùng relative color
:root {
  --clr-primary-rgb: 255 120 0;
  --clr-primary: rgb(var(--clr-primary-rgb));

  --clr-secondary-rgb: 0 255 25;
  --clr-secondary: rgb(var(--clr-secondary-rgb));
}
Dùng đổi opacity:
background: rgb(var(-clr-primary-rgb) / .5); => k chạy nhé, muốn tạo relative phải dùng from

--> Cách trên phức tạp, tạo 2 biến cho mỗi màu. Có thể dùng from tạo màu từ 1 màu khác và custom:
hsl(from #ff0000 / 0.5); => giảm opacity đi 0.5
hsl(from red h s calc(l - 20) / 0.5); => lấy màu đỏ và giảm light đi 20
hsl(from var(--clr-primary) h s 20%); => đổi rgb sang hsl, sau đó map thông số h và s, còn light set là 20%
rgb(from #ffff r g g / 0.5); => tương tự nhưng lấy màu green làm màu blue
oklch(from red calc(l * .5) calc(c * .1) h / 0.5); => oklch() là hàm tạo màu như lch() nhưng màu sắc cân bằng hơn. lightness, chroma (như saturation), hue.

--> Dùng color-mix
color: color-mix(in lab, black, currentColor); => currentColor sẽ lấy thuộc tính color của thẻ hiện tại và ở case này làm tối màu đó đi, k set sẽ lấy theo cha, rồi tạo ra màu này
VD ở light background cần chữ màu tối hơn, dark background cần chữ màu sáng hơn. Dù ta đã set đen trắng cho text rồi nhưng cần text có màu khác. Ta dùng:
color: color-mix(in lab, currentColor, red 70%); => giả sử chữ đỏ sẽ tự có màu đỏ đậm đỏ nhạt tuỳ bg cho đúng

linear-gradient cũng dùng được currentColor, dùng được mọi nơi cho màu

# Dùng conic gradient tạo hình zigzag 
.loader {
  height: 47px; /* control the size */
  aspect-ratio: 5;
  background:
    conic-gradient(from 135deg at top,#000 90deg,#0000 0) top,
    conic-gradient(from 135deg at top,#0000 90deg,#000 0) bottom;
  background-size: 20% 50%;
  background-repeat: repeat-x;
}



# Dùng zIndex
Bản chất: Thẻ A có z-index là 1, thẻ B có z-index là 2 thì thẻ A luôn nằm dưới thẻ B, kể cả thẻ A có children z-index là 100 thì tất cả đều dưới thẻ B thôi
Best practice là để tất cả cùng z-index thì cái sau đè cái trước. Đến khi cần TH cái sau nhỏ hơn cái trước mới phải specific. Thẻ có zIndex nên luôn set position relative để tránh lỗi

K dùng opacity với z-index vì opacity làm giảm z-index của thẻ bên trong nó



# Dùng position 
-> Position absolute sẽ xếp vị trí so với thẻ cha relative đầu tiên của nó, nếu k có thì sẽ là thẻ body, thẻ absolute cũng thành inline block.
position absolute nếu ta set cả 4 giá trị thì nó bắt đầu ảnh hưởng đến kích thước của thẻ, tự kéo dãn cho vừa hcn đó đó là khi kích thước k set.
Thường dùng kết hợp transform để dịch ra đâu theo vị trí cố định, rồi dịch tiếp theo kích thước relative của nó

-> Relative là thay đổi vị trí so với bình thường bao nhiêu, vẫn chiếm không gian

-> Sticky thì vật sẽ ở vị trí bth, nhưng khi scroll quá thì sẽ stick vào thẻ parent relative đầu tiên của nó, k thì sẽ theo màn hình. Nếu thẻ parent scroll hết thì k stick nữa

-> Fixed là cố định cũng là set các vị trí so với các cạnh của màn hình và fixed mãi ở đó luôn, thường dùng cho mobile menu.
VD A chứa thẻ B, mà B có position fixed thì sẽ căn fixed theo window nhưng nếu thêm translateZ(0) cho thẻ A thì thẻ B sẽ fix theo thẻ A chứ k fix theo window nx.



# Float => k dùng
Float khiến 1 thẻ block thành inline không chiếm height và trôi sang 2 bên. Các thẻ khác vẫn hiện cùng dòng và né width nó ra.
clear: both => khiến thẻ float chiếm height, các thẻ khác k thể ở cùng dòng với nó nữa

-> VD thẻ div chỉ có các thẻ float bên trong thì height thẻ div đó là 0 vì thẻ float k chiếm height của cha nó mà
ClearFix trong CSS giúp thẻ cha mang kích thước của thẻ con kể cả dùng float, chỉ cần cho 1 thẻ con dưới float để kéo dài cha quá float là được.
VD: .clearfix:after{
  content: ".";
  clear: both;
  display: block;
  width: 0px;
  height: 0px;
}






# Dùng content-visibility
Khi vào 1 page, mặc định browser tải resource, tạo DOM và layout, render paint cả page ra màn hình, dù viewport chỉ hiển thị 1 phần. Nó khiến page lớn load hiện lần đầu tiên bị lâu, và cũng lag khi resize.

content-visibility visible là default

-> hidden
display none ẩn hết khỏi DOM và a11y tree. hidden attribute của html tag y như display none.
content-visibility hidden cũng ẩn hết, k thể tương tác hay search. Nhưng nó k xóa DOM, giữ state giúp ẩn và hiện lại rất nhanh.
visibility hidden cũng ẩn, k thể tương tác và k xóa DOM. Nhưng nó lại vẫn chiếm diện tích
opacity 0 dường như chỉ ẩn phần nhìn, vẫn tương tác đươc.

visibility hidden kết hợp aria-hidden="false" k hoạt động, nó vẫn ưu tiên ẩn
Thay vì kết hợp visibility hidden với position absolute để k chiếm diện tích, ta nên ưu tiên dùng content-visibility hidden cho tooltip các thứ ok hơn.

-> auto: thẻ sẽ k được paint lên màn hình cho đến khi xuất hiện gần viewport. Mặc định là nó paint cả page.
Để browser paint content, nó phải calculate layout trước. Thẻ có auto sẽ k tính layout khi chưa vào viewport nên phải đi kèm contain-intrinsic-size: auto 600px; để dùng kích thước tạm trước khi thẻ được paint. Thường set contain-intrinsic-size width là auto tự scale full chứ k fix cứng để k bị tràn màn hình nhỏ.
Khi scroll xuống và paint thẻ đó, kích thước thực tế sẽ bị thay vào gây jump scrollbar nhưng chấp nhận. K nên dùng khi kích thước thẻ ảnh hướng lớn đến layout thôi.
K nên dùng auto cho các thẻ quá lớn để tránh scroll nhanh paint thẻ đó k kịp gây khoảng trắng, nên chia chunk nhỏ tốt hơn.

-> contain trong css xác định 1 thẻ có containment không, mặc định là none là k có giới hạn gì.
contain: paint; => đảm bảo mọi thứ bên trong 1 thẻ k thể paint ra ngoài thẻ đó
contain: size; => đảm bảo mọi thứ bên trong 1 thẻ sẽ k ảnh hưởng đến kích thước thẻ đó. Vì bth kích thước thẻ cha tự kéo dài theo kích thước con, nhưng ở đây thì không.
contain: layout; => đảm bảo thẻ bên trong k ảnh hưởng đến layout các thẻ khác và ngược lại.
Có thể kết hợp contain: layout paint size; 
=> Dùng contain sẽ giảm tải cho browser khi tính toán layout hay paint ra màn hình.
=> Thẻ có content-visibility auto sẽ tự có contain layout tức thẻ bên trong k thể break layout ra bên ngoài



# Có thể custom cursor:
C1: là cho cursor none rồi tự custom 1 thẻ ảnh khác cho transform theo mousemove. Có thể custom event mouse down thì phóng to ảnh, mouse up thì ảnh về bth
=> Việc custom cursor như v k ổn k nên dùng vì text, input, button đôi khi cần các hình khác nhau thì custom sẽ phức tạp với từng thẻ
C2: là dùng cursor: url(<base64>) 8 8, auto; // Tham số 2 là dự phòng nếu browser k hỗ trợ hình ảnh  
Tự set cursor như nào ở các thẻ khác nhau, k custom gì khác được, chỉ thay đổi được cách hiển thị
URL: https://css-tricks.com/next-level-css-styling-for-cursors/ => dùng C2 fallback cho C1 khi browser k hỗ trợ JS. Check touch screen và k enable js thì dùng cursor C2 thôi.
URL: https://custom-cursor.com/ => lấy ảnh cursor free



# Master border radius: outer radius = inner radius + distance giữa 2 border (border-width) => tự tạo nếu cần 1 thẻ có boder radius trong thẻ khác
border-radius: https://9elements.github.io/fancy-border-radius/
Dùng border-image
Shorthand border-radius: 10% 30% 50% 70%;



# Flexbox
Chú ý dùng width fit-content kết hợp với flex thì vô dụng. Vi mục đích khi sử dụng flex là kích thước của thẻ cha lớn hơn các thẻ con và flex sẽ xếp con bên trong cha.
Dùng kèm flex-grow và flex-shrink, order. Dùng align-self để chỉnh con ở start hay end so với cha là flexbox. VD cha cho align-item center để mọi con ra giữa, nhưng có vài con mà muốn ở 2 bên vẫn dùng align-self chỉnh được

-> Nhanh: flex: 2 2 10%; // grow shrink basis 
flex: 2 2; // grow shrink
flex: 2 // = 2 1 0%
=> flex shrink default 1, flex grow default 0, flex-basis 0% nên khi thu nhỏ nó tự k bị tràn vì có flex-shrink.
flex-flow: row wrap;
place-content: center space-between; /* align-content: center; justify-content: space-between; */
place-items: center stretch; /* align-items: center; justify-items: stretch; */ => k có stretch
place-self: start end; /* align-self: start; justify-self: end; */ => có thể stretch, trong phạm vi ô to
=> align-items, jusitfy-content, align-content cho flex
=> 1 điểm khác biệt lớn của place-items và place-self là place-items dùng cho container bao ngoài, place self là dùng cho từng phần tử được. place-self chỉ cần dùng cho grid

-> Dùng text-align và margin 0 auto để căn giữa nếu có thể. Còn có text-align justify cho text hiện đẹp

-> Dùng display flex thì thẻ có thuộc tính đó trở thành block chiếm cả dòng rồi ta set vị trí các con. Còn inline-flex thì thẻ cha thành thẻ inline thôi, xếp con bên trong.

-> flex-basis => ref tới "Responsive css"
Flexbox gặp vấn đề là chỉnh size của cell dựa vào kích thước item bên trong, shrink hay grow cũng thế. Grid tốt hơn vì chỉnh size của cell dựa vào kích thước các cell bên ngoài set từ trước.
VD https://www.youtube.com/watch?v=Ns12ALe8aqI&list=WL => 2 flexbox có content bên trong khác nhau sẽ có tốc độ shrink content khác nhau. 
Để fix: phải dùng flex-basis khiến các thẻ content cố gắng đạt được 1 mốc width thì sẽ giống nhau. Các thẻ có thể shrink hay grow xác định chuẩn là xong
=> Nếu cần chia chuẩn cột cho các hàng, nên dùng grid, còn chỉ cần xuống dòng bth thì dùng flex responsive. Flex k xử lý trước trường hợp row cuối cùng k full

Các phần tử trong flex sẽ mở rộng theo kích thước của chính các phần tử đó. Nhưng nếu mọi phần tử trong 1 flexbox đều được set flex-grow, thì kích thước từng cái sẽ chia theo tỷ lệ đó luôn (trong 1 hàng chứ các hàng khác nhau sẽ k tự dóng thẳng như grid) => Cách để chia tỉ lệ phần tử trong flexbox. Chú ý là tỉ lệ phần tử k tính padding, nếu item có padding sẽ to hơn bth.

-> Mở rộng thuộc tính display
inline-flex, inline-grid

Nhận 2 param thì 1 là style ngoài, 2 là style trong và các thẻ trong nó.
inline-flex = inline flex
flex = block flex
block = block flow
none = none
inline-block = inline flow-root

Param 2 có thể là flow-root tạo block formatting content k bị margin collapse, còn lại như default flow: https://www.youtube.com/watch?v=JY0FN71vCbw
display contents dùng để khiến 1 thẻ như là biến mất khỏi DOM nhưng ta vẫn css selector từ nó để style cho thẻ con được => ít dùng
display list-item khi muốn 1 thẻ hoạt động như 1 item trong list ul li dù k có. 
Tương tự display table khi muốn hoạt động như table. VD display table-column sẽ k hiện nếu thẻ này k nằm trong 1 table => ít dùng



# Dùng display grid
CSS grid galaxy layout khá dễ: https://uxdesign.cc/css-grid-with-galaxy-layout-figma-886a935b9649
Giống flexbox nhưng custom chia vị trí từng ô tốt hơn.
Grid master: https://css-tricks.com/snippets/css/complete-guide-grid/?fbclid=IwAR0hXkP7RHqFTVbuRnF-Vau0VqkVig1dQn6gpfa80ig3bMo7mPzW0m6DdpM
Playground: https://flexboxlabs.netlify.app/grid
Grid làm container: https://ryanmulligan.dev/blog/layout-breakouts/

-> grid-gap: 10px; là kc giữa các ô. Có column-gap, row-gap
gap/grid-gap: 1rem 3rem; => vertical 1rem, horizontal 3rem để ý khi dùng flex-wrap

-> grid-template-columns: 10% 10% 10%; là chia 3 thẻ bên trong làm 3 cột, một cột chiếm 10%. 
grid-template-columns: 1fr 1fr 1fr; hoặc (auto auto auto) cx là 3 cột bằng nhau. Hoặc repeat(3, 1fr) viết lặp
grid-template-rows: 300px 100px; => row1 cao 300px, row2 cao 100px, các row sau kích thước mặc định k fix
grid-template-columns: repeat(3, minmax(200px, 1fr));

-> grid-column / grid-row là 1 phần tử chiếm bnh cột và hàng. Vd: grid-row: 1 / span 2; là item này bắt đầu từ row1 và kéo dài 2 row

-> grid-auto-rows sẽ set kích thước chiều cao mặc định cho row mói được thêm vào, nếu ta k set bằng grid-template-rows cho nó thì sẽ lấy cái này; Tương tự grid-auto-columns

-> grid-template-areas để sắp xếp các item vào grid theo label. Kết hợp grid-area khi responsive đổi vị trí area.

-> grid-area còn là short của grid column và grid row. VD:
VD grid-area: 2 / 1 / span 2 / span 3; => thẻ ở row 2 column 1 kéo dài 2 rows 3 column
VD grid-area: 1 / 2 / 3 / 4; => tương đương với grid-row-start: 1; grid-column-start: 2; grid-row-end: 3; grid-column-end: 4; => Kéo dài từ row1->row2, col2->col3

-> grid-auto-flow: column; ưu tiên xếp hết từng col trước. 
grid-auto-flow: row dense; => vẫn xếp đầy row nhưng fill vào các chỗ trống trước đó nếu đủ, điều này làm mất thứ tự

-> grid có thể dùng cho 1D layout để tạo khi các cột đều bằng nhau => tốt hơn flexbox. Dùng flex box khi cần các item theo kích thước riêng của chúng
Chỉ cần dùng {
  grid-auto-flow: column; // để nó xếp trong 1 hàng
  grid-auto-columns: 1fr; // để các phần tử mới thêm vào grid đều cùng kích thước nhau
}
- flexbox có thể dùng cho 2D layout, chỉ cần set flex wrap, khác với grid là có thể để các cột không cùng kích thước nhau, cứ có kích thước đúng của nó là được
 
-> grid-template-columns có thể tự định nghĩa grid line names để dùng trong các trường khác
Dùng grid là container được: browser -> Elements -> Layout -> show line names để thấy grid line names
URL: https://www.youtube.com/watch?v=c13gpBrnGEw

-> Căn giữa phần tử cuối cùng của grid: 
Dùng flex box căn giữa ok nhưng sẽ full width, nếu ta set max-width chứ k full width thì khi màn hình co chỉ còn 1 column muốn full lại k được nx. Nếu k muốn như vậy thì dùng grid
Có thể tạo kim tự tháp card bằng grid bằng cách tương tự

-> Dùng grid-template-areas thay thế position absolute vì nó có thể tự chồng các element lên nhau và lấy kích thước của thẻ to nhất
K dùng display none vì nó làm mất thẻ thì k tự lấy kích thước thẻ to nhất, k dùng opacity 0 vì nó gộp aria text các thẻ lại, dùng visibility hidden ok nhất vì vẫn chiếm k gian và có ẩn aria-text.
Visibility hidden + position absolute = display none => sai vì visibility hidden vẫn chiếm chỗ trong layout
visibility khi transition vẫn được, chỉ là hiện hay ẩn chứ k như opacity nhưng nó vẫn chờ đúng thời gian transition

-> Tạo masonry css với grid



# Responsive chuẩn với grid layout + @container query
Dùng grid layout hoặc flex để chia bố cục, dùng kèm @container query để style các items
VD: 1 grid hiện nhiều cards. Khi 1 hàng hiện càng ít thẻ thì card có ảnh sẽ mang style thay đổi 
.grid-auto-fit {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(min(30ch, 100%), 1fr));
  container: grid-auto-fit / inline-size;
}
.card:has(> img) {
  // Giả sử mỗi card dài 30ch
  // Khi tăng lên 2 card 1 hàng, thẻ chứa ảnh chiếm cả 1 hàng
  @container grid-auto-fit (inline-size > calc(30ch * 2 + 1rem)) { // Chú ý k dùng được css var
    grid-column: span 2;

    display: grid;
    grid-template-columns: subgrid;
    gap: 0;

    > img {
      grid-column: 2;
      grid-row: 1 / 4;
    }
  }

  // Khi tăng lên 4 card 1 hàng, thẻ chứa ảnh chiếm 2 hàng 2 cột
  @container grid-auto-fit (inline-size > calc(30ch * 4 + 3rem)) {
    grid-column: span 2;
    grid-row: span 2;
    > :not(img) {
      grid-column: 1 / -1; => cách khéo léo để bảo chiếm tất cả, thay vì phải viết 1 số span cụ thể
    }
    > img {
      grid-column: 1 / -1;
      grid-row: 1;
    }
  }
}



# -> text-shadow và box-shadow: https://html-css-js.com/css/generator/box-shadow/ 
drop-shadow theo hình dạng ảnh có nền transparent, nó cũng theo màu của hình nếu k xác định màu
Dùng box-shadow lồng nhau trong 1 thẻ có thể gom nhiều thẻ trừu tượng thành 1: https://www.youtube.com/watch?v=20QiX8rmHnU

box-shadow có thể tạo hình background phức tạp với animation bằng cách dùng inset lồng nhiều màu đè ở các vị trí khác nhau, màu sau sang trái đè lên màu trước đó.
URL: https://frontendmasters.com/blog/expanding-css-shadow-effects/ 




# Trick responsive flexbox grid
Xếp flex-basis trước, nếu các thẻ flex-basis k đủ cho 1 dòng sẽ xuống dòng theo flex-wrap. Sau đó mới tính grow, shrink. Do đó có thể lợi dụng flex-basis để kiểm soát số cột

VD grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); Tự xếp column fit vào ô với kích thước 200px nếu có thể. Có thể dãn lớn hơn 200px. Nhỏ hơn 200px thì xuống dòng.
minmax nếu max nhỏ hơn min thì lấy min. minmax chỉ dùng trong cssgrid.
1fr đơn vị phân số fraction chia tỉ lệ nhưng bản thân nó k theo kích thước bất cứ container nào cả, chỉ là tỉ lệ các item. Bth nó kiểu max 100% ấy. Nếu cố điền 1fr trong 1 đơn vị yêu cầu kích thước cụ thể sẽ hoạt động k như mong muốn, hay invalid property.
repeat là hàm trong css có sẵn. Thường dùng là repeat(số/auto-fill/auto-fit, số); Tức là auto-fit và auto-fill là giá trị của repeat chứ klq gì đến grid. Mục số là điền số chứ đừng điền 1fr, có thể dùng minmax(200px,1fr) để full width mà max width.
Nếu display grid, các item mà k set grid-column hay grid-row, nó sẽ mặc định 1 item là 1 ô. K set kích thước thì 1 ô chiếm cả row, tức chỉ có 1 cột
Grid có điểm đặc biệt là theo grid. Dòng trên có cột width như nào thì dòng dưới phải có cột width như vậy. Nếu k muốn v thì dùng flex. Muốn height các cột bằng nhau thì set grid-template-rows 1fr hết

-> Kỹ thuật responsive:
1) Tạo dương cực lớn hay âm cực lớn ở 1 mốc.
Lấy 100% - absolute unit và so sánh với mốc mong muốn rồi *999 => kết hợp min max kiểu lớn hơn 200px thì lấy dương vô cực, nhỏ hơn thì lấy 200px
2) Max số cột: Dựa vào tính chất xếp k đủ thì tự giảm cột xuống dòng rồi mới xét shrink hay grow. 
Ta cố tình cho min-width 100% / 4 + 0.1% => kbh 1 row có 4 cột được vì k đủ width, buộc dùng 3 cột kéo dãn là max

VD: grid-template-columns: repeat(auto-fill, minmax(<min-width 1 column>, 1fr));

VD chỉ muốn bo góc ở màn hình lớn:
.card {
  border-radius: max(0px, min(8px, calc((100vw - 4px - 100%)*9999)));
}
=> 100vw là kích thước screen, 100% là kích thước container. Nếu kích thước container gần như bằng với kích thước screen sẽ thành max(0px,min(8px,âm vô cực)) = 0px. Nếu kích thước container không bằng với màn hình (vì màn hình lớn ta cho container nhỏ ra giữa thôi) thì thành max(0px,min(8px,dương vô cực)) = 8px
Tức if(!mobile) borderRadius=0px else borderRadius=8px

=>***Cứ tưởng tượng màn hình lớn và màn hình nhỏ thì min max width là gì là chơi dược thôi



# Responsive css
Test responsive phải chú ý cả TH VD điện thoại xoay ngang, width có thể gấp 3 lần height và height cực kỳ nhỏ.

-> Dùng @media:
@media not|only mediatype and (mediafeature and|or|not mediafeature) { CSS-Code; }
với mediatype là: all / print / screen
media feature là: color, color-index, max-device-aspect-ratio, min-height, min-device-width, min-device-pixel-ratio, resolution, orientation (portrait/landscape)
orientation portrait/landscape => vì điện thoại xoay ngang và điện thoại xoay khác nhau, k thể chỉ @media theo mỗi width. Mở rộng với min-aspect-ratio

VD: @media (min-width: 100px) {} => tương đương @media all and (min-width: 100px) {}
VD: @media (min-device-width: 100px) {} => thì kích thước tính cả thanh công cụ và thanh cuộn => k dùng
VD: @media only screen and (max-width: 480px) and (min-width: 320px){ } => kích thước từ 320->480 của màn hình máy tính or smartphone
VD: @media only print { } => chỉ cho máy in
VD: @media (100px <= width <= 300px) {} => luôn dùng
VD: @media only screen and (max-width: 100px) and (orientation: landscape), screen and (min-width: 100px) {} => Áp dụng cho các thiết bị màn hình có width nhỏ hơn 100px và chiều rộng lớn hơn chiều cao, k bao gồm thiết bị đọc màn hình hay in ấn, đồng thời áp dụng cho mọi loại thiết bị hiển thị bao gồm cả in ấn và thiết bị đọc màn hình nếu width lớn hơn 100px
Có thể responsive từ thẻ link, kiểu chia mỗi màn 1 file css. VD <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">
=> Các thuộc tính và responsive các kích thước cơ bản: https://freetuts.net/su-dung-media-css-tao-responsive-cho-website-660.html

--> @media (prefers-color-scheme: dark) { } là khi user setting dark mode trong phần mềm sử dụng or thay đổi user-agent (light/dark/no-references) => k cần thiết
--> @media (prefers-reduced-motion) {} là khi user setting giảm thiểu animation cho web. Setting này của browser để web ít animation cho đỡ lag.

--> K dùng được css var trong @media. VD @media screen and (max-width: --mobile-size){} => sai ngay
Dùng sass thì vẫn được vì nó phân tích cú pháp và paste vào tại thời điểm compile. CSS thuần thì có package postcss-css-variables giúp làm điều đó.

-> Có thể responsive bằng JS với event resize, k sợ browser k hỗ trợ @media 
Dùng @supports (display: grid) and (not (display: inline-grid)) { } để check browser có hỗ trợ thuộc tính nào không. VD dùng để check nếu k hỗ trợ thì in ra đoạn text "Browser not support this feature!" và display none phần nào sử dụng.

-> Container query: xử lý case đôi khi màn hình nhỏ dần mà kích thước container lại tăng
URL: https://www.youtube.com/watch?v=rrLAg7xNERA
container-type: size là lấy theo 2 chiều, inline-size là lấy theo 1 chiều ngang thôi. Kích thước container theo chiều được lấy defines kích thước của content.
@container tự tìm container bao ngoài đúng là parent đầu tiên, dùng thêm container-name nếu muốn rõ ràng hơn.
Dùng đơn vị 50cqw để set kích thước theo width của container, nếu k có container sẽ dùng như vw
container: main / inline-size; => shorthands container-name / container-type
=> Chốt: Dùng container-name chỉ cần set cho phần tử cha, tự dùng container gần nhất bao nó, 50cqw.

->***Có thể responsive tương đối với grid, k cần biết con số cụ thể px để style thủ công nữa
- flex-basis: set kích thước initial cho flex item và item tự điều chỉnh sau. Set là 0 thì item tự mang kích thước nhỏ nhất fit content. Nếu các item set là auto thì chia đều nhau. Nếu set quá container luôn thì item sẽ max có thể trong giới hạn container thôi. 
VD: container 100px, item1 50px, item2 30px. Nếu set flexbasis item1 là 1000px thì nó chỉ tới 70 thôi, nếu set flexbasis item1 là 10px thì nó mang width là 50px để hiển thị đầy đủ item
Các thẻ cố gắng mang kích thước đó, phần space thừa sẽ được chia ra. Các thẻ mở rộng tuỳ vào flex-grow. Nếu container nhỏ hơn thì lại co theo tỉ lệ dựa vào flex-shrink
- clamp(min,value,max): browser set giá trị là value, nếu value nhỏ hơn min sẽ set là min, lớn hơn max sẽ set là max. Value ở giữa thường là relative.
- auto-fit: grid sẽ cố gắng "điền đầy" không gian bằng cách dãn phần tử => nên dùng auto-fill hơn vì nó cố điền nhiều cột nhất có thể. Khi chỉ có 1 hàng sẽ thấy rõ.
- minmax(min,max): container bao nó nhỏ hơn min, lấy min; container bao nó lớn hơn max, lấy max; container nằm giữa, lấy container; Tức nó set gom max-width, min-width thôi.
=> Kết hợp hàm calc có thể kết hợp relative và absolute, điều này đủ mạnh để thay thế media query.

VD: Chỉ cần grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); là đã tự responsive chia cột, nếu mỗi phần tử k thể lớn hơn 100px sẽ tự giảm 1 cột
auto-fit hết container, cố gắng fit full width với các phần tử hiện tại khi chỉ có 1 row
auto-fill những cột còn lại, thì sẽ lấy min width và cố gắng tưởng tượng còn nhiều cột khác xép vào
VD: (200px - 100%)*999  là check nếu container lớn hơn 200px sẽ trả ra số âm cực bé, và ngược lại là dương cực lớn
VD flexbox có 2 tag con, tag con sẽ tự hiện lên nếu mang kích thước đủ: https://www.youtube.com/watch?v=LEkFckg7sfw
.with-sidebar {
  --main-min-width: 45ch;
  --sidebar-size: 250px;
  --gap: 2rem;

  display: flex;
  gap: var(--gap);
  flex-wrap: wrap;
}
.with-sidebar > * {
  flex-grow: 1;
}
.with-sidebar > :first-child {
  flex-grow: 999;
  flex-basis: calc(
    ((var(--main-min-width) - (100% - var(--sidebar-size) - var(--gap))) * 9999)
  ); // Tức flex-basis xếp trước vào vị trí, k đủ sẽ đẩy thẻ xuống (flex-basis là NN xuống dòng), sau đó mới tính flex-grow, flex-shrink các thứ
  // Nếu vừa có flex-basis, vừa có flex-grow, nó vẫn chỉ cố grow đến mức đạt được flex-basis thì thôi, chứ đạt r sẽ k grow quá nữa làm gì
} 
.with-sidebar > :last-child {
  flex-basis: var(--sidebar-size);
}
VD code mẫu grid nhảy cột từ 1 tới 4:
.columns {
  /* user setting */
  --min-column-size: 200px;
  --column-count: 4;
  --gap: 2rem;
  
  /* calculations */
  --breakpoint: calc(var(--min-column-size) * var(--column-count) + (var(--gap) * (var(--column-count) - 1)) );
  --column-size: calc((100% / var(--column-count)) - var(--gap));
  
  display: grid;
  gap: var(--gap);
  
  grid-template-columns: repeat(
    auto-fit, 
    minmax(
      min(max(var(--column-size), (100% - var(--breakpoint)) * -999 ), 100%), // tức màn > 4 thẻ thì column size bth, màn < 4 thẻ thì column size full width
      1fr)
    );
}
Có code mẫu tăng dần cột từ 1 tới 1 số chỉ định

-> Thêm max-width 100% cho ảnh vì website luôn tự responsive co các item lại rồi => css reset 
Tư duy responsive: kích thước ta set k cố định mà để cho browser tự set vì nó tự co item khi nó co lại. Ta chỉ cần set, min max để giới hạn k được nhỏ hay lớn hơn bao nhiêu thôi
Tối ưu @media query, vd muốn màn lớn thì 2 col, màn nhỏ thì 1 col. Mà mặc định grid là 1 col, nên ta để mặc định 1 col, @media min-width thì set 2 cols. Chứ mặc định set 2cols, sau màn nhỏ lại phải chỉnh thì phải sửa grid-template-columns 2 lần lận => thường thì media query toàn dùng min-width



# Dùng attr trong css
attr(data-name); mặc định là string chỉ dùng trong content
Bh có thể dùng với mọi kiểu trừ image url, Vd dùng với color: attr(data-color type(<color>), gray);
URL list các type: https://una.im/advanced-attr/

Thường ta style cho 1 thẻ hoàn toàn từ css. Chỉ dùng data-attribute khi có các thuộc tính của thẻ hỗ trợ cho việc truy cập từ JS or CSS. 
- Lúc trước có giải pháp chia sẻ biến giữa html, css, js là dùng custom property:
<div style="--color: red"></div>
element.style.setProperty("--color", "red")
- data-attribute tương tự nhưng dễ thao tác hơn với JS, cũng tiện hơn nhiều TH:
<div data-color-to-show="red"></div>
element.dataset.colorToShow = "red"

Check: 
@supports (x: attr(x type(*))) {
  .warning {
    display: none;
  }
}

-> type(<custom-ident>) là 1 custom identifier có thể trỏ tới id 1 thẻ
Nên dùng đặt tên cho view-transition-name nhanh chóng

-> Tạo tooltip: Dùng thuộc tính title của các thẻ p, div để hover có tooltip sẵn
Dùng title tốt hơn dùng style css :after content: attr(data-image-to-show);

Nếu phải dùng id, cũng nên thay bằng data-* hơn vì lỡ 1 thẻ muốn duplicate ra chỗ khác khi responsive sẽ bị trùng id chỉ dược ở 1 thẻ.

# Tạo tooltip
--> Tự custom vd tooltip cho thẻ a: cho thẻ a relative bao thẻ b absolute có visibility là hidden -> style hover a thì visibility của b là visible
visibility vẫn chiếm không gian nhưng k nhìn thấy hay tương tác, dùng với position absolute để thành k chiếm kg.



# Tạo responsive marquee css only
URL: https://frontendmasters.com/blog/infinite-marquee-animation-using-modern-css/

- offset: path() giúp định nghĩa 1 đường đi, và offset-path sẽ chỉ định vị trí trên path đó theo %. Dùng offset để di chuyển object theo 1 path với offset-distance.
- Dùng shape thay cho path vì shape có thể kết hợp với css function phức tạp
VD: path("M100 100 h200"); tương đương với shape(from 100px 100px, hline by 200px);
- sibling-count() là hàm đếm có bao nhiêu sibling là các thẻ cùng là con trực tiếp của thẻ cha của hiện tại.
- VD offset: shape(from calc(var(--image-size)/-2) 50%, hline by calc(sibling-count() * var(--image-size))); 
=> bắt đầu từ sát bên trái ngoài màn hình, 1 đường ngang dài bằng kích thước số lượng element
- Để ảnh start lần lượt nhau, ta cho animation delay số âm



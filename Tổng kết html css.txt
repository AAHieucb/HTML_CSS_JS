# Basic
text-shadow và box-shadow: https://html-css-js.com/css/generator/box-shadow/ 
Có sẵn quốc kỳ của mọi quốc gia trên thế giới bằng css: https://dev.to/j471n/i-made-all-countries-flags-using-html-css-4cnc
https://www.flaticon.com => trang cho lấy icon miễn phí(có cả icon động) chỉ với điều kiện thêm thẻ div này vào mã nguồn: <div>Icons made by <a href="https://www.freepik.com/" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div>

Có thể custom cursor
CSS nesting có sẵn rồi
***popovertarget và popover giúp 1 thẻ hiện khi click và ẩn khi click ra ngoài, éo cần js phức tạp nữa, tạo popover css thuần

-> Master border radius: outer radius = inner radius + distance giữa 2 border
border-radius: https://9elements.github.io/fancy-border-radius/

-> Margin collapse: hiện tượng bottom margin thẻ trên bị merge với top margin thẻ dưới => fix bằng cách dùng padding

-> Hack CSS: -webkit của chrome, -moz của firefox dùng bởi các rendering engines khác nhau. 
Cũng có thể dùng cho thuộc tính kiểu height: -moz-fit-content;

-> Biến trong css định nghĩa với -- trong 1 tag chỉ dùng được trong tag đó và tag con của nó, truy cập với var()
VD Click chuột là đổi màu 1 vài thẻ: nên dùng css var trong :root và đổi giá trị khi click là được.

-> Lỗi zIndex: Thẻ A có z-index là 1, thẻ B có z-index là 2 thì thẻ A luôn nằm dưới thẻ B, kể cả thẻ A có children z-index là 100 thì tất cả đều dưới thẻ B thôi
K dùng opacity với z-index vì opacity làm giảm z-index của thẻ bên trong nó
zIndex k hđ với position static, cần set rõ khi dùng.

padding-top: 100%; lấy 1/3 phần height thẻ cha. VD: A height 600px chứa B có padding-top: 100% thì B có padding top là 200px vì chia đều cho padding top, bottom, content height

-> resize: both; direction: ltr; => biến mọi thẻ thành resizable
contenteditable => biến mọi thẻ thành editable nhưng khá xấu
Dùng <dialog> có sẵn
Dùng thuộc tính title của các thẻ p, div để hover có tooltip sẵn
ul li, ol li, dl dt dd
Emphasis marks dùng cho các ngôn ngữ có thanh âm để biểu hiện tính cao hay trầm của âm tiết. Có none, open, dot, circle, triangle, seseam, 1 <character> bất kỳ
Tag video chứa tag source. VD: preload="auto,metadata,none", metadata là xem đến đâu load đến đấy, trong khi auto là load entire video luôn. 
Thuộc tính inert đặc biệt trong html, khi dùng sẽ vô hiệu hóa mọi tương tác của người dùng với các tag.



# Custom thẻ input
Input bth k có autocomplete, nhưng nếu thêm id="email/name" sẽ có autocomplete tự động. Có thể custom vẫn dùng id nhưng bỏ autocomplete bằng cách thêm: aria-autocomplete="list"

-> Nếu muốn có 1 group input radio chỉ cho chọn 1 thì phải đặt chung trường name với nhau

-> input type number custom nút spin button, trỏ vào shadow DOM với: input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button
Nó có thuộc tính -webkit-appearance ta chỉnh là none chẳng hạn thì nó sẽ k hiện
K an toàn vì dùng -webkit, với browser khác nên dùng type text và lọc thủ công sẽ chuẩn hơn



# CSS Selector
-> Cùng độ ưu tiên thì lấy cái set sau: !important > inline style > style theo id > style class, pseudo-class, attributes > element and pseudo-element > universal selector(*)
VD: style theo pseudo-class: .test:hover { }
style theo attributes: div[id=test] { }
style theo pseudo-element: .test:before { }
VD: a[href$=".abc" i]  /  [href*="google.com"]  /  img:not([alt]) 

-> space  là descendant
>  child
~  mọi sibling sau
+  1 sibling ngay sau 

-> Vd 1 thẻ a mà có cả 4 thuộc tính thì phải viết css đúng thứ tự sự kiện nếu k sẽ k có hiệu ứng:link/:visited -> :selection -> :hover -> :active (click chuột)

input:checked/:disabled/:enabled/:required => khi input buộc nhập giá trị 
input:optional/:read-only X :read-write/:valid X :invalid/:out-of-range tức khi lỗi out-of-range thì mang style css gì X :in-range

Pb :focus là chính thẻ đó được focus, :focus-within là khi bất cứ 1 thành phần bên trong nào của thẻ này bị focus thì thẻ này sẽ mang style nào
Pb: :is(<>) thì cho độ ưu tiên cao nhất là 100 còn :where(<>) với cú pháp giống hệt cho độ ưu tiên thấp nhất là 0 như dùng cho css reset

p:empty là khi thẻ p k có text bên trong thì có style như nào
:target là kiểu phần tử target khi bị href tới thì mang style gì. VD: <p><a href="#news1">Đến nội dung số 1</a></p> <p id="news1"><b>Nội dung số 1</b></p>
:nth-last-of-type(2) => sibling cuối cùng thứ 2
p:lang(it) { } => thẻ p có lang là italia. VD: <p lang="it">Ciao bella!</p>
div:nth-child(n) => thẻ div là con thứ n
p:only-child { } => thẻ p là con duy nhất của 1 thẻ khác 
initial-letter tương đương selector ::first-letter giúp tạo chữ đầu tiên to đùng như đầu bài báo article
::focus-visible giúp bắt TH button bị click hay chọn bởi tab key

-> X:before và X:after như 1 thẻ khác nằm bên trong X có kích thước fit content, k có content thì mặc định là 0 0.
before hiện ở left 0 top 0 của thẻ, after ở top right, kp hiện đằng trc vị trí thẻ hiện tại mà nó chiếm vị trí thẻ và đẩy text thẻ ra sau nó
VD cho x là relative và before là absolute thì vị trí thẻ before sẽ tính theo thẻ x

-> VD Event click chuột vào 1 phần tử trong list thì đổi style đơn giản: Từng item thêm tabIndex={index}, trong css bắt sự kiện thẻ đó ::focus r chỉnh style thoải mái. 

VD tính năng readmore với CSS only: dùng 2 cái radio button cho 2 dòng Read more và Read less để trigger thông qua label r style css :checked để ẩn hiện dòng text 



# Flexbox
Chú ý dùng width fit-content kết hợp với flex thì vô dụng. Vi mục đích khi sử dụng flex là kích thước của thẻ cha lớn hơn các thẻ con và flex sẽ xếp con bên trong cha.
Dùng kèm flex-grow và flex-shrink, order
Dùng align-self để chỉnh con ở start hay end so với cha là flexbox. VD cha cho align-item center để con ra giữa, nhưng có vài con mà muốn ở 2 bên vẫn dùng align-self chỉnh được

-> Dùng text-align và margin 0 auto để căn giữa nếu có thể. Còn có text-align justify cho text hiện đẹp

-> Dùng display flex thì thẻ có thuộc tính đó trở thành block chiếm cả dòng rồi ta set vị trí các con. Còn inline-flex thì thẻ cha thành thẻ inline thôi, xếp con bên trong.

-> flex-basis => ref tới "Responsive css"



# Dùng position 
-> Position absolute sẽ xếp vị trí so với thẻ cha relative đầu tiên của nó, nếu k có thì sẽ là thẻ body, thẻ absolute cũng thành inline block.
position absolute nếu ta set cả 4 giá trị thì nó bắt đầu ảnh hưởng đến kích thước của thẻ, tự kéo dãn cho vừa hcn đó đó là khi kích thước k set.

-> Relative là thay đổi vị trí so với bình thường bao nhiêu, vẫn chiếm không gian

-> Sticky thì vật sẽ ở vị trí bth, nhưng khi scroll quá thì sẽ dính màn hình theo vị trí top left ta set. Phạm vi là trong 1 thẻ relative khác hoặc body, nếu thẻ relative scroll hết sẽ trôi cả sticky.

-> Fixed là cố định cũng là set các vị trí so với các cạnh của màn hình và fixed mãi ở đó luôn, thường dùng cho mobile menu.
VD A chứa thẻ B, mà B có position fixed thì sẽ căn fixed theo window nhưng nếu thêm translateZ(0) cho thẻ A thì thẻ B sẽ fix theo thẻ A chứ k fix theo window nx.



# Dùng font
TrueType Fonts (TTF): TrueType là định dạng font phổ biến cho các hệ điều hành Mac OS và Windows.
OpenType Fonts (OTF): OpenType là một định dạng được phát triển dựa trên nền tảng của TrueType.
Web Open Font Format (WOFF): là một TrueType nhưng nhẹ hơn và được W3C khuyến khích dùng
Web Open Font Format (WOFF 2.0): là một bản nén tuyệt vời hơn WOFF 1.0.
SVG Fonts/Shapes: SVG Fonts giúp hiển thị văn bản giống như một hình ảnh Graphic.
Embedded OpenType Fonts (EOT): EOT là một hình thức nén ít dùng của OpenType

-> Dùng text-transform: uppercase; => luôn dùng k cần JS
Dùng text-size-adjust => bỏ vì ta tự set font-size responsive chứ k cần control thuật toán điều chỉnh kích thước văn bản của trình duyệt trên điện thoại nữa

-> Định nghĩa font mớ css
@font-face{
  font-family: MyFont;
  src: url(sansation_light.woff);
  font-weight: 100;
}
h2{
  font-family: MyFont;
}
font-family thì nếu browser k support font đầu sẽ chuyển dần sang các font sau
Or dùng @import url(<>); trong css để thêm font chữ vào đầu tiên.

-> Dùng font-systhesis
Browser giả style khi font k hỗ trợ, nhiều lúc giả style bị lỗi hiển thị. Nếu dùng style mà text k đổi thì có thể do font k hỗ trợ và browser cũng k giả style được.
font-systhesis quyết định browser có giả style hay không, nếu set là none thì chữ luôn hiện đúng nếu có, k có style thì hiện dạng mặc định chứ k giả => Thường luôn cho phép giả

-> Dùng text-rendering
Có: optimizeSpeed, optimizeLegibility, geometricPrecision, auto (phụ thuộc vào browser)
optimizeLegibility là giúp vc chữ hiển thị dễ đọc, phân biệt "f l i" bằng cách in với kích thước hơi khác biệt 1 chút cho người dùng tránh nhầm
=> Thực tế cái này để thế nào cũng được, người đọc chữ nếu k sợ nhầm thì cứ optimizeSpeed nếu cần vì trông chữ nó chả khác biệt mấy

-> Dùng font-smooth: xử lý antialias khi render font
Dùng kèm -webkit-font-smoothing: auto/none/antialiased/subpixel-antialiased(nét chữ sắc nhất) => MacOS Webkit
-moz-osx-font-smoothing: auto/grayscale => Firefox MacOS 

-> Font size tự động đổi theo kích thước màn hình:
min và max trong css giúp lấy min và max của giá trị gì, khi kết hợp với kích thước relative sẽ rất mạnh
Màn hình luôn được chia thành 100 vw và vh. VD màn hình là 1460px thì 1vw sẽ tương ứng với 14.6px
clamp(a, b, c); là hàm của css giúp lấy 1 giá trị trong khoảng a và c. Nó ss lấy min(b,c) là x rồi lấy max(a, x) trả ra kết quả. 

VD ta muốn màn hình dưới 700px có font-size là 16px, sau đó tăng dần tuyến tính lên 1px mỗi 100px tăng lên cho đến max là 22px => font-size: clamp(16px, 1vw + 9px, 22px);
Khi 700px, nó sẽ là clamp(16px, 16px, 22px) thì lấy 16px. Font size tuyến tính tăng lên 1300px thì clamp(16px, 22px, 22px) thì lấy 22px
Vd muốn màn hình tăng đến đúng 1500px thì fontsize mới là 22px ta chỉ cần giải phương trình là được

Or dùng generator: https://clamp.font-size.app => đổi rem ở vị trí đầu và vị trí thứ 3 thành px để tránh nhiều case bị sai

-> Web safe font: 
Có các font chạy trên linux ok nhưng sang window bị lệch dòng. Có các tool giúp chỉnh sửa thẳng vào file ttf để fix font như FontForge nhưng khá mất tg
Web safe font là các font luôn chạy mượt với mọi browser và mọi hđh thường có sẵn trong browser. Nhưng k đảm bảo các web safe font lúc nào cũng khả dụng => Viết CSS thêm fallback fonts là các font dự phòng cho browser:
https://www.w3schools.com/cssref/css_websafe_fonts.php?fbclid=IwAR2s3BCKKc8rKHr4fKOYp8P2VFVtBj94Moc0fd0auwBP-Mzwv_riCy8FeE8
https://www.w3schools.com/cssref/css_fonts_fallbacks.php

-> Dùng color font: Font được style đẹp sẵn



# Dùng float:
Float khiến 1 thẻ block thành inline không chiếm height và trôi sang 2 bên. Các thẻ khác vẫn hiện cùng dòng và né width nó ra.
clear: both => khiến thẻ float chiếm height, các thẻ khác k thể ở cùng dòng với nó nữa

-> VD thẻ div chỉ có các thẻ float bên trong thì height thẻ div đó là 0 vì thẻ float k chiếm height của cha nó mà
ClearFix trong CSS giúp thẻ cha mang kích thước của thẻ con kể cả dùng float, chỉ cần cho 1 thẻ con dưới float để kéo dài cha quá float là được.
VD: .clearfix:after{
  content: ".";
  clear: both;
  display: block;
  width: 0px;
  height: 0px;
}



# Dùng display grid
Giống flexbox nhưng custom vị trí từng ô tốt hơn. Kích thước từng ô, hàng, cột, thứ tự sắp xếp item vào ô, khoảng cách các ô, strech hay co lại.
Grid master: https://css-tricks.com/snippets/css/complete-guide-grid/?fbclid=IwAR0hXkP7RHqFTVbuRnF-Vau0VqkVig1dQn6gpfa80ig3bMo7mPzW0m6DdpM

-> grid-gap: 10px; là kc giữa các ô. Có column-gap, row-gap

-> grid-template-columns: 10% 10% 10%; là chia 3 thẻ bên trong làm 3 cột, một cột chiếm 10%. 
grid-template-columns: 1fr 1fr 1fr; hoặc (auto auto auto) cx là 3 cột bằng nhau. Hoặc repeat(3, 1fr) viết lặp
grid-template-rows: 300px 100px; => row1 cao 300px, row2 cao 100px, các row sau kích thước mặc định k fix

-> grid-auto-columns set default size cho các column trong grid container; grid-auto-rows set default size cho rows trong container

-> VD grid-area: 2 / 1 / span 2 / span 3; => thẻ ở row 2 column 1 kéo dài 2 rows 3 column
VD grid-area: 1 / 1 / 2 / 2; tương đương với grid-row-start: 1; grid-column-start: 1; grid-row-end: 2; grid-column-end: 2;

grid-template-area để sắp xếp các item vào grid theo label.

-> grid-column / grid-row là 1 phần tử chiếm bnh cột và hàng. Vd: grid-row: 1 / span 2; là item này bắt đầu từ row1 và kéo dài 2 row

-> Mặc định các thẻ được sắp xếp vào ô từ trái sang phải và từ trên xuông dưới. grid-auto-flow có thể thay đổi điều này bằng cách ưu tiên xếp đầy row trước hay column trước: row là xếp đầy row theo thứ tự; row dense là vẫn xếp đầy row nhưng fill vào các chỗ trống trước đó nếu đủ, điều này làm mất thứ tự; dense là fill bất cứ ô nào vừa là vô
URL: https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-rows

-> Phân biệt: place-items: end center; => là kết hợp của align-items end và justify-items center
place-content: end space-between; => là kết hợp của align-content end và justify-content space-between



# Responsive css
Test responsive phải chú ý cả TH VD điện thoại xoay ngang, width có thể gấp 3 lần height và height cực kỳ nhỏ.

-> color-scheme: light/normal/dark sẽ tự đổi màu đen trắng mà k cần set màu thủ công, dùng ở :root để đổi tất cả.

-> Dùng @media:
@media not|only mediatype and (media feature) { CSS-Code; }
với mediatype là: all / print / screen
media feature là: min-aspect-ratio, color, color-index, max-device-aspect-ratio, min-height, min-device-width, min-device-pixel-ratio, orientation, resolution

VD: @media only screen and (max-width: 480px) and (min-width: 320px){ } => kích thước từ 320->480 của màn hình máy tính or smartphone
VD: @media only print { } => chỉ cho máy in
Có thể responsive từ thẻ link, kiểu chia mỗi màn 1 file css. VD <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">
=> Các thuộc tính và responsive các kích thước cơ bản: https://freetuts.net/su-dung-media-css-tao-responsive-cho-website-660.html

--> @media (prefers-color-scheme: dark) { } là khi user setting dark mode trong phần mềm sử dụng or thay đổi user-agent => k cần thiết
--> @media (prefers-reduced-motion) {} là khi user setting giảm thiểu animation cho web. Setting này của browser để web ít animation cho đỡ lag.

--> K dùng được css var trong @media. VD @media screen and (max-width: --mobile-size){} => sai ngay
Dùng sass thì vẫn được vì nó phân tích cú pháp và paste vào tại thời điểm compile. CSS thuần thì có package postcss-css-variables giúp làm điều đó.

-> Có thể responsive bằng JS với event resize, k sợ browser k hỗ trợ @media 
Dùng @supports (display: grid) and (not (display: inline-grid)) { } để check browser có hỗ trợ thuộc tính nào không. VD dùng để check nếu k hỗ trợ thì in ra đoạn text "Browser not support this feature!" và display none phần nào sử dụng.

-> Container query: xử lý case đôi khi màn hình nhỏ dần mà kích thước container lại tăng

->***Có thể responsive tương đối với grid, k cần biết con số cụ thể px để style thủ công nữa
- flex-basis: set kích thước initial cho flex item và item tự điều chỉnh sau. Set là 0 thì item tự mang kích thước nhỏ nhất fit content. Nếu các item set là auto thì chia đều nhau. Nếu set quá container luôn thì item sẽ max có thể trong giới hạn container thôi. 
VD: container 100px, item1 50px, item2 30px. Nếu set width item1 là 1000px thì nó chỉ tới 70 thôi, nếu set width item1 là 10px thì nó mang width là 50px để hiển thị đầy đủ item
Các thẻ cố gắng mang kích thước đó, phần space thừa sẽ được chia ra. Các thẻ mở rộng tuỳ vào flex-grow. Nếu container nhỏ hơn thì lại co theo tỉ lệ dựa vào flex-shrink
- clamp(min,value,max): browser set giá trị là value, nếu value nhỏ hơn min sẽ set là min, lớn hơn max sẽ set là max. Value ở giữa thường là relative.
- auto-fit: grid sẽ cố gắng "điền đầy" không gian bằng cách nhét nhiều cột hoặc hàng hơn nếu có đủ không gian. Nếu k đủ không gian sẽ điều chỉnh kích thước các phần tử bth
- minmax(min,max): container bao nó nhỏ hơn min, lấy min; container bao nó lớn hơn max, lấy max; container nằm giữa, lấy container; Tức nó set gom max-width, min-width thôi.
=> Kết hợp hàm calc có thể kết hợp relative và absolute, điều này đủ mạnh để thay thế media query.

VD: (200px - 100%)*999  là check nếu container lớn hơn 200px sẽ trả ra số âm cực bé, và ngược lại là dương cực lớn
VD flexbox có 2 tag con, tag con sẽ tự hiện lên nếu mang kích thước đủ: https://www.youtube.com/watch?v=LEkFckg7sfw
.with-sidebar {
  --main-min-width: 45ch;
  --sidebar-size: 250px;
  --gap: 2rem;

  display: flex;
  gap: var(--gap);
  flex-wrap: wrap;
}
.with-sidebar > * {
  flex-grow: 1;
}
.with-sidebar > :first-child {
  flex-grow: 999;
  flex-basis: calc(
    ((var(--main-min-width) - (100% - var(--sidebar-size) - var(--gap))) * 9999)
  );
}
.with-sidebar > :last-child {
  flex-basis: var(--sidebar-size);
}
VD code mẫu grid nhảy cột từ 1 tới 4:
.columns {
  /* user setting */
  --min-column-size: 200px;
  --column-count: 4;
  --gap: 2rem;
  
  /* calculations */
  --breakpoint: calc(var(--min-column-size) * var(--column-count) + (var(--gap) * (var(--column-count) - 1)) );
  --column-size: calc((100% / var(--column-count)) - var(--gap));
  
  display: grid;
  gap: var(--gap);
  
  grid-template-columns: repeat(
    auto-fit, 
    minmax(
      min(max(var(--column-size), (100% - var(--breakpoint)) * -999 ), 100%), 
      1fr)
    );
}
Có code mẫu tăng dần cột từ 1 tới 1 số chỉ định



# Animation basic
Tìm animation đủ loại => search #topcsseffects trong youtube kênh hơn 1000 video chỉ giới thiệu css animation

-> transition: [thuộc tính chuyển động] [thời gian chuyển động] [thời gian delay] [kiểu chuyển động];
Đổi trạng thái cho các thuộc tính liên quan đến số và màu, VD background-image k có tác dụng nhưng có thể fake chỉ bằng cách animate opacity các ảnh
VD: transition: all 1s 0.5s ease-in; hoặc transition: width 2s, height 2s, transform 2s;

transition k dùng được với width hay các giá trị k rõ như auto
VD có thể set padding 0 -> unset, fontSize 0 -> unset, scaleY(0) -> scaleY(1)
Trong React ta dùng style={appear ? {fontSize: "unset"} : {fontSize: 0, padding: 0, opacity: 0}} + transition là được
pointer-events => sự kiện xử lý ở JS nhưng có thể set css để k cho thẻ bắt sự kiện nữa được

-> animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-direction] [animation-fill-mode] [animation-play-state];
animation-duration là thời gian từ lúc bắt đầu cho đến khi kết thúc
animation-delay là thời gian chờ trước khi hiệu ứng bắt đầu chạy
animation-iteration-count dùng số or infinite, số float cho ra animation dừng giữa chừng
animation-direction thì normal là đi về phía trước, reverse là về phía sau, alternate làm chuyển động được quay ngược lại kiểu 5s đầu là 0%->100% và 5s sau là 100%->0%, alternate-reverse ngược lại với alternate
animation-fill-mode: Khi kết thúc animation, nếu để none or k set gì thì mặc định dùng style ban đầu khi animation k thực thi, nếu set forwards sẽ dùng giá trị khung cuối, backwards dùng giá trị khung hình chính ở đầu animation (lúc 0%); both là hòa trộn forward và backwards; 
animation-play-state: paused hay running
=> Lưu ý để đảm bảo animation liên tiếp nhau k kiểu bị ngắt quãng thì nên setup sao cho giá trị mặc định lúc 0% bằng với giá trị lúc 100% để làm vô tận mượt hơn

VD animation: name(hello) duration(2s) timing(linear) delay(2s) inter-count(infinite) direction(alternate/normal)
=> animation còn có SVG, ảnh động, 3D. URL full: https://viblo.asia/p/tap-tanh-tim-hieu-css-animation-bai-1-transition-4dbZNprL5YM 

-> animation-timeline giúp control thuộc tính animation phụ thuộc vào hành động của user hoàn toàn bằng css. VD chỉ khi scroll thì animation mới chạy, tạo parallax

-> Vd hover button to ra: 
Nếu có thể, nên cho button to sẵn và scale nhỏ lại, hover thì trở về kích thước ban đầu
Nếu không, cách tốt nhất là scale(1.2) lên và bị mờ. Để fix:
- will-change: transform; sẽ đưa gợi ý cho browser biết sẽ thay đổi như nào để optimize, hạn chế dùng vì browser xử lý expensive có thể gây lag.
- backface-visibility: hidden; chặn hiển thị mặt sau giúp giảm mờ.

-> Animate svg khi hover: các tag svg dùng đc animation css như bth, dùng cho các thẻ path hay g bên trong để animate 1 phần của icon cũng được luôn
Khi đó ta gán id cho nó, set animation-play-state là paused mặc đinh, khi hover vào thì đổi lại thành running là ok



# Xử lý image
URL: https://bennettfeely.com/clippy/ => kích thước vẫn thế nhưng hiển thị cut ảnh

-> Có multiple background image. Chỉ cần 4 thuộc tính: background-size (object-fit), background-image, background-repeat, background-position
background-position kiểu vị trí x,y của ảnh trùng với vị trí x,y nào của khung. VD center center hay 0 0 là tâm ảnh trùng tâm khung hay 0,0 của ảnh trùng 0,0 của khung

background-origin xác định vị trí của background image theo content. 
background-clip text => sẽ lồng background image vào trong text, buộc phải bỏ màu của text mới hiển thị ảnh, color: transparent;
background-blend-mode chỉ có tác dụng khi có màu chồng lên nhau: https://www.w3schools.com/cssref/playdemo.php?filename=playcss_background-blend-mode
background-attachment: scroll mặc định là trôi theo scroll bar; local là trôi theo scrollbar của content; fixed là background fix k trôi, tạo parallax

-> Các thuộc tính image filter: https://www.w3schools.com/css/tryit.asp?filename=trycss_ex_images_filters

-> Layer mask: mask là shorthand của mọi thuộc tính mask-* trong css
Dùng style cho 1 thẻ để tạo 1 lớp hiệu ứng bên trên thẻ đó. VD hiển thị bức ảnh theo phần ảnh của 1 bức ảnh khác, ta cho bức ảnh khác đó lên 1 lớp bên trên.
VD mask-image: linear-gradient(black, transparent);
VD mask: url(masks.svg#star) 0 0/50px 50px no-repeat; => đặt mask tại vị trí 0 0 từ top left và width height mask là 50px 50px
VD mask: url(masks.svg#star) left / 16px repeat-y; => element là mask ở phía bên trái với width 16px. Mask position phải xác định 2 giá trị như left top, mặc định nếu chỉ set 1 giá trị thì giá trị còn lại sẽ là center

-> Image placeholder
Dùng thẻ img có width và height bằng kích thước ảnh, nếu k rõ thì dùng minWidth minHeight để luôn có placeholder. 
Cbi sẵn 1 bức ảnh default để lỗi thì show ra. Dùng bg color xám cho thẻ img để ảnh chưa có thì hiển thị 1 màu xám, hoặc tìm cách show skeleton. Có thể dùng background-image của tag image để làm ảnh default.
Dùng border radius thẻ div bao ngoài img kèm overflow hidden
Dùng onLoad và onError, VD check ảnh lỗi thì hiển thị ảnh lỗi mặc định chứ k show hình lỗi xấu.
HTML có thẻ object show mọi loại media, nếu bị lỗi sẽ tự show thẻ con của thẻ object rất hay => ít dùng vì kp chuyên cho ảnh.

VD: <img src="invalid_link" onerror="this.onerror=null;this.src='https://placeimg.com/200/300/animals';" >
Việc dùng this.onerror=null chống lỗi infinity loop. Lỗi này xảy ra ở 1 số trình duyệt khi chính ảnh để ta fix lại bị lỗi xong lại chạy onerror lại lỗi và cứ lặp vô tận
Nếu sợ lỗi infinite loop, thì có thể set 1 bức ảnh backup onerror local đảm bảo luôn tồn tại là được. 

--> onLoad, onError k hỗ trợ mọi browser nên thư viện react-lazy-load-image-component sẽ lo điều đó với mọi browser
Thuộc tính PlaceholderSrc của LazyLoadImage nhận 1 ảnh kích thước nhỏ để hiển thị ra trước khi ảnh lớn được load. Ta có thể giảm độ phân giải ảnh bằng các công cụ chỉnh sửa để thế vào, thêm effect="blur" để làm mờ ảnh placeholder được
--> Lib react-progressive-graceful-image rất phù hợp dùng được thay thế cho tag object của html hiển thị ảnh placeholder, nếu ảnh lỗi thì chỉ hiển thị placeholder mặc định

-> Lazy loading ảnh: thuộc tính loading="lazy"/"eager" có sẵn của html

-> Ưu tiên dùng ảnh SVG để tránh bị mờ khi zoom lớn: svg dùng đồ họa vector có animation.
SVG Sprites là pp gom các ảnh từng phần vào 1 file duy nhất và chỉnh vị trí cho chuẩn. Thay vì server nhận nhiều request từng tấm ảnh nhỏ thì chỉ cần 1 bức SVG là được
Có nhiều tool giúp vẽ tay SVG: https://topdev.vn/blog/svg-la-gi/



# Xử lý màu
Tool sinh code gradient: https://angrytools.com/gradient/

-> Gradient css có 3 loại: linear kéo từ 1 phía sang 1 phía, radial kéo từ 1 điểm lan ra xung quanh, conic-gradient
--> Chú ý dùng background gradient thì truyền vào background chứ kp background-color
VD: background: linear-gradient(direction, color1, color2, color3, color4, ...);
VD: radial-gradient(circle closest-corner at 100px 100px, red 10%, yellow 20%, pink 10%); 
shape là circle, elipse (default, bóp méo theo khung bên ngoài)
size có thể là closest-side, farthest-side(default), closest-corner, farthest-corner at ... để set kích thước

-> Các cách lấy màu: rgba(255,0,0,0.5); rgb(255,0,0); hsl(0, 1005, 50%), hsla(0,100%,10%,0.3); #ffffff; dùng tên trực tiếp red, yellow
hsl thì hue có giá trị từ 0 đến 360, 0 và 360 cùng là đỏ.
color-mix giúp mix 2 màu trong không gian màu nào

-> mix-blend-mode: difference; => giúp đổi màu tương phản cực mạnh, nên dùng mọi lúc khi cần màu đổi ngay lập tức khi background đổi mà k sợ trùng màu bị ẩn đi
backdrop-filter: blur(5px); => style cho area trong phạm vi element nhưng đằng sau element

-> Còn có sự sai lệch về màu sắc khi dùng browser khác nhau, đặc biệt là Safari so với Webkit. 
Ta k nên giả định 2 màu là giống nhau ở 1 thẻ so với 1 bức ảnh hay video. VD: video có màu nền là #f12312 vì ta dùng devtool để lấy màu => ta k thể dùng 1 thẻ cũng có màu #f12312 và giả định rằng 2 màu giống nhau được, đặt video bên cạnh thẻ kia sẽ thấy khác màu ở 1 số browser khác.

Có những màu đẹp có sẵn được support chuẩn ở mọi browser nên dùng: https://www.w3schools.com/cssref/css_colors.php



# Other:
-> Nguồn ảnh free: https://www.pexels.com/ ảnh và video chất lượng
https://unsplash.com/ ảnh đa dạng hơn, có cả thông tin máy chụp, tiêu cự, ống kính

-> Vd Tạo tooltip cho thẻ a: cho thẻ a relative bao thẻ b absolute có visibility là hidden -> style hover a thì visibility của b là visible
visibility vẫn chiếm không gian nhưng k nhìn thấy, dùng với position absolute để thành k chiếm kg

Vd Tạo navigation thì dùng ul list thẻ a: Cho text-decoration là none và :hover vào thì đổi thành gì, :active tức link hiện tại đang được chọn thì style như thế nào. Dùng list-style-type: none; cho list. Navigation bar dọc thì li dùng display:block, navigation bar ngang ta dùng thẻ li có display: inline;

VD Tạo stack card khi scroll: Cơ chế là cho position sticky với padding top để các thẻ k bị scroll đi mất mà luôn đính ở 1 chỗ như v
Để tạo animation phức tạp khi scroll, dùng JS sửa 1 biến --scroll là được: https://css-tricks.com/books/greatest-css-tricks/scroll-animation/

-> WebComponent: https://www.freecodecamp.org/news/write-components-that-work-in-any-framework có thể tạo ra các tag html thuần để dùng được ở mọi framework.
Google có tool Lit giúp tạo web component dễ hơn. React19 cũng hỗ trợ webcomponent dễ dàng hơn r.

1 tag html thuần gồm: - HTML <template> là tag đặc biệt mà nội dung k được render trực tiếp mà phải được copy rồi mới render ra
- Shadow DOM là phần css k bị ảnh hưởng khi người dùng global style các thẻ. Dev dùng k thể custom shadow DOM. VD nut pause start trong <video>
Có thể enable google devtool để nhìn thấy shadow DOM của các thẻ

-> Dừng:
{ display: list-item; list-style-position: inside; } để hiển thị thẻ dạng list. Còn có display: table;
Tạo polygon responsive thuần: https://css-tricks.com/hexagons-and-beyond-flexible-responsive-grid-patterns-sans-media-queries/
View transition API giúp chuyển trạng thái mượt như app bth. Full tut: https://developer.chrome.com/docs/web-platform/view-transitions/

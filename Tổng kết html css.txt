# Basic
https://uiverse.io/ => tổng hợp component UI bằng html thuần*
https://gsap.com/ => thư viện UI mạnh
https://www.flaticon.com => icon động
https://dev.to/j471n/i-made-all-countries-flags-using-html-css-4cnc => cờ bằng css thuần

https://css-generators.com/ => tool css, tạo các shape dị

-> Bản chất kích thước trong css
- margin collapse là hiện tượng bottom margin thẻ trên bị merge với top margin thẻ dưới => fix bằng cách dùng padding hoăc cho thành inline-block
- padding-top 100% lấy 1/3 phần height thẻ cha. VD: A height 600px chứa B có padding-top 100% thì B có padding top là 200px vì chia đều cho padding top, bottom, content height
- inline chiếm đủ nội dung và k thể set width height, block chiếm toàn bộ chiều ngang và có thể set. inline-block giống inline nhưng có thể set width height.
- width auto chiếm full remaining space k tính margin, khác với width 100% sẽ có kích thước = 100% width thẻ cha. Nếu nhiều thẻ auto sẽ chia đều.
Cách khác nếu muốn fillup remaining space là dùng flex-grow
- Mọi trường hợp, min lớn hơn max sẽ lấy min. Vd min-height > max-height sẽ lấy min-height
- Bản chất về height:
height auto là default sẽ tự mở rộng theo kích thước content. Thường css reset cũng để thẻ body mặc định như v chứ k set height cố định.
Khi set 50% sẽ theo kích thước thẻ cha trực tiếp. Nếu thẻ cha trực tiếp k set height or auto theo thẻ con, thì bị loop, khiến thuộc tính height 50% invalid và coi như k có. 
VD thẻ cha có mỗi min-height:100vh; thẻ con height 50% sẽ k chạy vì height thẻ cha vẫn là auto tương tự như trên. 

-> Tổng kết dự án basic:
- Tạo dự án: parcel import npm; html thuần import cdn; react;
- Hosting: Github pages, netlify.
- Darkmode: scss dùng map; css thuần dùng var có thể set từ checkbox hoặc dùng JS set data-theme attribute cho thẻ body, hoặc viết thủ công như cách scss sau khi tạo ra; Dùng css relative color tạo color palette.
- Chia file: html thuần chia mỗi pages 1 file; css chia style chung và riêng từng pages ở các file riêng rồi import file css trực tiếp lẫn nhau được; scss cũng style chung từng file, từng pages @use các file chung đó, chia cả file components các thứ, cuối cùng quy hét về 1 file scss duy nhất @use tất cả để compile bằng 1 lệnh thôi, mọi pages đều phải script tới file chung đó dẫn đến style thừa nhưng chả sao.
- BEM: scss dùng &__container, css cũng vậy. Trong file css 1 pages có <section>__<subsection>__<content>, max là 4 level. CSS Selector 1 level thôi, chia với @layer và @scope
- Responsive: dùng css var với responsive hack grid flex, dùng clamp; Dùng @container > @media; scss dùng @mixin chia từng màn hình @media thuần và css hack
- Routing chuyển pages: chuyển page load lại mọi thứ, có thể prefetch trước file cho pages same site <link rel="prefetch" href="./page2.html">; Dùng history.pushState + URLSearchParams cho đổi url mà k chuyển page, dùng thẻ a or window.location.href để thực sự chuyển pages; Dùng view transition api; Dùng session storage lưu data các pages;



# BEM
BEM (Block-Element-Modifier) kbh dùng id mà chỉ có class và tên các class tuân theo chuẩn. Nested thì chỉ nên 1 cấp.
VD để biểu diễn item nằm trong khối block menu, thay vì:
  .menu { ... }
    .menu .item { ... }
    .menu .item.active { ... }
Ta dùng:
  .menu { ... }
    .menu__item { ... }
    .menu__item--active { ... }

VD: <a class="btn btn--orange" href="#">
  <span class="btn__price">$9.99</span>
  <span class="btn__text">Subscribe</span>
</a>
và file css: .btn { ... }
.btn--orange { ... } => -- có tính chất gì
.btn__price { ... } => __ là gì
.btn__text { ... }



# CSS reset
width default là auto tự full và k cần set 100% làm gì, height default tự theo content và chỉ cần set min-height 100dvh nếu cần footer dưới cùng thôi.

-> Phân biệt:
initial: lấy thông số kỹ thuật của css. VD display có default là inline sẽ khiến mọi thẻ thành inline kể cả các thẻ div => k dùng vì nhiều cái default rất ảo
unset: có parent thì lấy theo parent, nếu chưa từng set cho parent thì lấy initial value là thông sô kỹ thuật của css => k dùng
inherit: lấy giá trị thuộc tính kế thừa từ cha. Vì mọi thẻ đều có mọi thuộc tính, nếu cha k set sẽ dùng default value của browser. Chú ý default value của browser khác với default value của css property.
none: k set giá trị và coi như k có giá trị đó luôn, 1 vài css prop có giá trị này thôi.

-> Import css tự reset trước, rồi đến css của thư viện, sau đó là css cho component tuỳ chỉnh.
Bản chất: chia theo layer -> cùng layer thì style thẻ đó sẽ ghi đè style thẻ cha, style thẻ cha là body cũng mạnh hơn html vì cha gần hơn -> cùng là style thẻ đó thì mới chia theo specifility => Đó chính là lý do vì sao html là 0:0:1 nhưng lại k đè được :where là 0:0:0
VD thứ tự khi reset giả sử chỉ có 1 layer:
html => spec 0:0:1, là thuộc tính cha html của mọi thẻ, thường set style base mọi thẻ
:root => spec 0:1:0, là thuộc tính cha html của mọi thẻ, thường định nghĩa css var, k style
body => spec 0:0:1, là thuộc tính cha body của mọi thẻ, thường dùng định nghĩa style cho body và mọi thẻ khác mà dùng biến trong :root
user agent stylesheet => cố định k thể sửa với từng thẻ
* => spec 0:0:0, set thuộc tính base cho mọi thẻ, thường để đè user agent stylesheet
:where(tag) => spec 0:0:0, set thuộc tính base cho 1 tag cụ thể
Trong react còn có #id là thẻ bao ứng dụng.



# Dùng @import trong css
- @import nhiều lần cùng 1 file sẽ lấy cái sau thôi, k sợ trùng.
- @import url("./2.css") layer(base); => nhét mọi code trong 1 file css trong 1 layer
- Phải để ở đầu file, nó sẽ chạy tuần tự và làm chậm tải trang => chỉ dùng cho dev, trong production nên bundle lại thành 1 file index.css duy nhất và minify nó thôi. Vd dùng parcel build.
Nếu được nên dùng <link rel="stylesheet" href="styles/reset.css"> sẽ chạy song song nhưng vẫn đảm bảo thứ tự trong html nên k sao.

-> Nhanh:
Có thể chia layer
K dùng production vì tuần tự



# Dùng @scope và @layer
-> @scope selector k ảnh hưởng spec, selector bên trong giữ nguyên spec. Trong cùng 1 layer, nếu bên ngoài và trong scope đều cùng specifility, sẽ ưu tiên lấy trong scope
@scope có thể giới hạn style trong 1 phạm vi mà nested selector không làm được. VD @scope (article) to (aside) { } từ cha article đến con aside và k tính con.

VD2: @scope (.text) to (button.xxx) { // button.xxx k ảnh hưởng spec
  :scope { } // tương đương với & { } là root của @scope chính là .text
  p { color: red; }
  button { color: yellow; }
}
VD2: @scope (.text) to (button.xxx, a, p[class]) { } 
VD3: @scope (article) to (> figure) {} => áp dụng cho mọi con của article, trừ con trực tiếp là tag figure
VD4 scope lồng: @scope(aside) { @scope (article) { ... } }

:scope như 1 class selector duy nhất để tính spec, còn & thì tính spec như nested thế vào bth.
VD: @scope (main .text) to (button.xxx) {
  :scope img { } // (0, 1, 1)
}
@scope (main .text) to (button.xxx) {
  & img { } // (0, 1, 2) vì & thế vào thành "main .text img {}"
}

-> Có 3 loại layer theo thứ tự đè nhau: user agent styles -> user styles -> author styles
user agent style có sẵn browser k thể đổi. Có thể dùng @layer định nghĩa thêm các layer con trong author styles, còn style bth vẫn thuộc layer author styles và k nằm trong layer con nào.

Layer sau luôn đè layer trước, kể cả !important cũng k thể tác động, nên cần chú ý thứ tự import các layer.
VD: @layer framework, reset, base, layout, components; => để đầu file mới có tác dụng khai báo thứ tự, bên dưới set thế nào vẫn luôn tuân theo thứ tự này
=> Nếu lib css dùng layer riêng sẽ dễ custom hơn vì kể cả lib có dùng !important, vẫn có thể override với layer custom được import sau.

Trong cùng 1 layer thì style ngoài sẽ đè style trong layer con. 
@layer có thể lồng trong @layer khác và quy tắc vẫn tương tự.

--> scss dùng @layer như bth, nhưng nó phải dùng @use ở đầu nên k thể định nghĩa @layer trước nó được, buộc phải nhét @layer vào 1 file scss riêng rồi @use nó ở đầu để xuất hiện ở đầu
Case đặc biệt là @import có thể dùng bên trong @layer, nhưng @use thì không. VD fix với:
@use 'sass:meta';
@layer base, components, utilities;
@layer components {
  @include meta.load-css('components'); // Thế cho @use 'components'
}

-> Nhanh:
Các layer k thể can thiệp kể cả !important. Trong 1 layer thì style ngoài layer sẽ đè style trong layer
@layer phải khai báo thứ tự ở đầu. Sau đó muốn viết thứ tự như nào xuống dưới cũng được.



# Spec và CSS Selector
Cascade là khi cùng spec thì cái sau sẽ đè lên cái trước. VD ta link file css sau <style> thì css trong file sẽ đè lên css trong tag <style>.
layer sau đè layer trước > cùng layer thì style con đè style cha > cùng style con thì theo specifility -> cùng specifillity thì theo quy tắc @scope và cái sau đè cái trước
!important > inline style > style theo id > style class, pseudo-class, attributes > element and pseudo-element > universal selector(*)

-> Specifility (0,1,1) theo thứ tự là: Số ID selector; Số class / pseudo class / attribute selector; Element và số pseudo elements như :after, :first-letter
URL check spec: https://specificity.keegan.st/

VD1: pseudo-class :hover
attributes-selector img:not([alt]) 
pseudo-element: .test:before
VD2: dialog.hide 0:1:1 = dialog[open] 0:1:1 > .hide 0:1:0

-> Combinator:
space là descendant mọi cấp
>  child trực tiếp
~  mọi sibling sau
+  1 sibling ngay sau 

-> VD selector:
a[href$=".abc" i] => tag a có href kết thúc bằng .abc case insensitive
[href*="google.com"] => tag có href attribute chứa google.com ở bất kỳ đâu
:active => button, link đang được click
::selection => text được bôi đen
:visited X :link => :link là <a> chưa visit bao giờ
p:empty => thẻ p k có text bên trong 
:nth-last-of-type(2) => sibling cuối cùng thứ 2
p:lang(it) { } => thẻ p có lang là italia. VD: <p lang="it">Ciao bella!</p>
.grid > :nth-child(4n) => con trực tiếp trong grid mà thứ tự chia hết cho 4
p:only-child { } => thẻ p là con duy nhất của 1 thẻ khác 
::initial-letter = ::first-letter => tạo chữ đầu tiên to đùng như đầu bài báo article
X:before default ở top left, X:after default ở top right, nằm trong thẻ X
:target => style cho thẻ chứa id, khi được href tới id, từ 1 thẻ khác 

VD tạo checkbox với option light/dark mode thì: body:has(option[value="dark"]:checked){ --background: black; --text-color: white; }
VD ấn vào ảnh là phóng to ảnh, click 1 button đóng ảnh css only. Thì click thẻ a ref tới ảnh và style img:target phóng to, khi close thì xoá target bằng href="#" k hợp lệ.
VD read more với CSS only: dùng 2 dùng label + checkbox + :checked để ẩn hiện text

-> Pb:
- :is() sẽ lấy specificity của selector mạnh nhất bên trong, giúp liệt kê gọn hơn. Còn :where() có spec là 0:0:0 cho css reset
:where(.parent) .child {} thì child vẫn giư specifility của nó là 0:1:0
VD: .example :is(h1, h2, .link) {} tương đương với .example h1, .example h2, .example .link {}
- :focus là chính thẻ đó focus. Còn :focus-within là khi bất cứ 1 thành phần bên trong nào của thẻ này được focus, bao gồm ấn tab thì đổi style thẻ này. 
:focus là chọn bởi chuột hoặc tabkey, :focus-visible là riêng TH chọn với tabkey
VD button show dropdown thì dùng :focus-within thay cho :focus để click vào item con thì button cũng k ẩn dropdown, chứ kp chỉ được ấn vào thẻ dropdown cha.
VD click chuột vào 1 phần tử trong list thì đổi style đơn giản: từng item thêm tabIndex={index}, trong css bắt sự kiện thẻ đó :focus r chỉnh style thoải mái. 

-> Nhanh: 
Spec 
4 combinator
light/dark mode, phóng to ảnh với css only, readmore
:is và :where
:focus và :focus-within, dùng :focus với tabIndex



# Dùng font
TrueType Fonts (TTF): TrueType là định dạng font phổ biến cho các hệ điều hành Mac OS và Windows.
OpenType Fonts (OTF): OpenType là một định dạng được phát triển dựa trên nền tảng của TrueType.
Web Open Font Format (WOFF): là một TrueType nhưng nhẹ hơn và được W3C khuyến khích dùng
Web Open Font Format (WOFF 2.0): là một bản nén tuyệt vời hơn WOFF 1.0.
Embedded OpenType Fonts (EOT): EOT là một hình thức nén ít dùng của OpenType
SVG Fonts: là chữ biến hóa như ảnh graphic. 
Còn có material icons là icons viết dạng tag html

-> Thêm font mới:
- Dùng @import url(<remote url>); để dùng trực tiếp font-family trong css, k dùng được với local url.
- Fallback font:
@font-face {
  font-family: MyFont;
  src: url(sansation_light.woff2) format("woff2"),
       url(sansation_light.woff) format("woff"); // Browser k support woff2 tự chuyển sang woff
  font-weight: 100;
}
h2 {
  font-family: MyFont, sans-serif; // K tìm thấy MyFont sẽ dùng font sans-serif mặc định của browser
}
- Nên dùng 1 font file chuẩn và style tự set. Nếu buộc có nhiều style chia font-file riêng, phải thêm font-style font-weight để pb, dùng đúng style sẽ tự lấy đúng font
VD dùng cùng tên font nhưng style khác nhau:
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-Bold-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-BoldItalic-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: italic;
}
Sử dụng nó tự dùng đúng font tương ứng:
body { font-family: "DroidSerif", Georgia, serif; }
h1 { font-weight: bold; } // Cả 2 font cùng có styles sẽ lấy font đầu tiên
em { font-style: italic; }
strong em {
  font-weight: bold;
  font-style: italic;
}
Short hand nhiều url:
@font-face {
  font-family: 'Klavika';
  src: url(../fonts/Klavika-Regular.otf) format('truetype') font-weight-normal,
       url(../fonts/Klavika-Bold.otf) format('truetype') font-weight-bold,
       url(../fonts/Klavika-Bold-Italic.otf) format('truetype') font-italic font-weight-bold;
}

--> Variable fonts cho phép đổi thuộc tính cùng 1 font file, k fix cứng font-size, font-weight, italic => nên luôn dùng
Khi tải font chú ý font-size fix cứng thì k nên dùng. Variable font thì FE chỉ cần tải 1 file rồi tự style thoải mái.
VD roboto là static font, roboto_flex là variable font

-> Web safe font: Có các font chạy trên linux ok nhưng sang window bị lệch dòng, phải sửa thẳng vào file ttf bằng FontForge mất tg. Web safe font là các font chạy mượt với mọi browser và hđh. Nó k đảm bảo lúc nào cũng khả dụng nên phải thêm fallback fonts nếu dùng.
URL: https://www.w3schools.com/cssref/css_websafe_fonts.php
URL: https://www.w3schools.com/cssref/css_fonts_fallbacks.php

-> Các thuộc tính:
- text-transform: uppercase; => viết hoa input của người dùng, luôn dùng thay cho JS
- font-systhesis => bỏ, default auto tự cho phép browser giả style khi font k hỗ trợ. 
Chỉ cần đảm bảo k bị lỗi hiển thị là đươc. Nếu thêm style mà text k đổi thì là do font k hỗ trợ và browser cũng k giả style được.
- text-rendering => default auto browser tự quyết định cân bằng optimizeSpeed, optimizeLegibility, hay độ chính xác hình học (geometricPrecision)
optimizeLegibility là giúp vc chữ hiển thị dễ đọc, phân biệt "f l i" bằng cách in với kích thước hơi khác biệt 1 chút cho người dùng tránh nhầm
=> Để thế nào cũng được, nếu k sợ nhầm chữ thì để optimizeSpeed
- font-smooth => luôn để always là luôn tối ưu smooth cho các thiét bị
Dùng kèm -webkit-font-smoothing: auto/none/antialiased/subpixel-antialiased (nét chữ sắc nhất) => MacOs
-moz-osx-font-smoothing: auto/grayscale => Firefox MacOS 
- font-display => Chỉ định cách hiển thị font khi chưa tải xong. default auto. 
block: text sẽ bị ẩn nhưng vẫn chiếm k gian (tối đa 3 giây) trong khi chờ font tải xong, sau đó sẽ hiển thị với font mong muốn.
swap: text hiển thị ngay lập tức bằng font dự phòng, sau đó thay thế bằng font mong muốn khi tải xong => luôn dùng css reset

-> Font size clamp:
Màn hình luôn được chia thành 100 vw và vh. VD màn hình là 1460px thì 1vw sẽ tương ứng với 14.6px
clamp(a, b, c); lấy 1 giá trị trong khoảng a và c. Nó ss lấy min(b,c) là x rồi lấy max(a, x) trả ra kết quả. Nên dùng min, max, clamp thay thế width, max/min-width.
URL: https://clamp.font-size.app
VD màn hình dưới 700px có font-size là 16px, sau đó tăng dần tuyến tính lên 1px mỗi 100px tăng lên cho đến max là 22px => font-size: clamp(16px, 1vw + 9px, 22px);
Khi 700px, nó sẽ là clamp(16px, 16px, 22px) thì lấy 16px. Font size tuyến tính tăng lên 1300px thì clamp(16px, 22px, 22px) thì lấy 22px

--> Gợi ý:
Màn hình break point: 500 - 1300 - 1900 => đặt ở 2 mốc 500 và 1300 là được
1) Màn hình lớn: text thường 16px, chữ to 20px, title 24px, chữ khổng lồ 48px, button 16px
Màn hình mobile: text thường 14px, chữ to 16px, title 20px, chữ khổng lồ 36px, button 14px 
2) Màn hình lớn: text siêu bé 12px, text thường 14px, title 16px, chữ khổng lồ 40px, button 14px
Màn hình mobile: text thường 12px, title 14px, chữ khổng lồ 20px, button 14px

-> Color font thêm màu. Tut: https://www.youtube.com/watch?v=VpZSMq2ajDE
URL web check màu color font support: https://wakamaifondue.com/
@font-palette-values --identifier {
  font-family: Bixa;
  base-palette: 3; // trong web từ trên xuống là các palette font hỗ trợ
  override-colors: 0 rgba(0,0,0,1), 2 red; // trong web từ trái sang là các color index để override
}
.my-class {
  font-palette: --identifier;
}

-> K dùng px vì browser đổi font-size và px sẽ override browser setting. Khi font-size tăng, nhiều nơi khác cũng nên tăng. 
Với kích thước bth như @media hay padding margin nên dùng rem, font-size cũng dùng rem. Với spacing liên quan đến text, nên dùng em. 
VD box-shadow dùng px thoải mái vì chả liên quan đến font. Hoặc ảnh hay cái gì k phụ thuộc vào font-size mà cố định ở mọi màn hình thì để px.

-> Custom chữ trang trí:
-webkit-text-stroke: 1px black; => text-stroke tạo 1 đường viền ngoài cho svg, mà font thực chất là svg nên tạo viền cho font. Thường kết hợp thêm với text-shadow.
paint-order: stroke fill; => stroke được vẽ trước r mới fill màu lên tạo chữ đẹp hơn là để mặc định
Còn có text-fill kiểm soát màu

-> Nhanh:
- Thêm font với @import hoặc @font-face. Dùng variables font k phải định nghĩa từng style.
- font size clamp
- Có thể custom màu color font
- Dùng rem với kc phụ thuộc font, nếu kc liên quan đến text thì dùng em.
- Dùng text-stroke + text-shadow + paint-order tạo chữ đẹp



# Đơn vị trong CSS
-> Đơn vị tuyệt đối chỉ đúng trên các thiết bị độ phân giải cao như máy in, còn trên laptop và di động có thể sai khác. VD 1in = 96px = 2.54cm

-> Relative Units
em: tương đối so với font-size của phần tử cha
*rem (root em): Giống em, nhưng là tương đối với phần tử gốc <html>, hoặc theo setting browser nếu k set.
ex: Tương đối so với chiều cao chữ "x" của font hiện tại.
ch: Chiều rộng của ký tự "0" trong font đang dùng
*vw: Tương đối 1% width của kích thước cửa sổ trình duyệt (viewport).
*vh: Tương đối 1% height của kích thước cửa sổ trình duyệt (viewport).
vmin Relative to 1% dựa trên chiều nhỏ hơn của trình duyệt. VD điện thoại xoay dọc thì vmin sẽ là 1% của width
vmax Relative to 1% dựa trên chiều lớn hơn của trình duyệt
*%: Có giá trị tương đối so với phần tử cha.
=> Nên set kích thước theo rem, em, và responsive font-size theo rem, tất cả sẽ theo setting browser là font size gốc.

--> Các đơn vị đặc biệt cho mobile: lvh, dvh, svh, svw 
vh là chiều cao cơ bản, k tính toolbar.
lvh là chiều cao lớn nhất khi k có toolbar, svh là chiều cao nhỏ nhất khi k có toolbar
dvh là chiều cao dynamic tự thay đổi khi toolbar ẩn hoặc hiện => luôn dùng thay vh khi ứng dụng có chạy trên mobile

-> Nhanh:
Dùng rem em (px khi klq tới font) và dvh



# Private custom variable
VD click chuột là đổi màu 1 vài thẻ thì nên dùng css var và đổi giá trị var thay vì gán lại style từng thẻ. Đổi màu css var để tạo các theme khác nhau được.

-> Trong dự án lớn, nên dùng fallback var + kế thừa + private custom var. 
VD: <div class="container">
  <div class="hello">
    <button>Hello</button>
    <p>Hello</p>
  </div>
  <div class="hi">
    <button>Hi</button>
    <p>Hi</p>
  </div>
  <div class="bye">
    <button>Bye</button>
    <p>Bye</p>
  </div>
</div>

Cách làm ngu:
.hello button {
  color: red;
}
.hello p {
  box-shadow: 1px 1px 1px red;
}
.hi button {
  color: blue;
}
.hi p {
  box-shadow: 1px 1px 1px yellow;
}
.bye .button {
  color: green;
}
.bye p {
  box-shadow: 1px 1px 1px red;
}

Best practice là dùng private custom variables
.container {
  --_shadow: var(--shadow, red);
  --_color--text: var(--color, var(--color-text, red));
}
.container button {
  color: var(--_color--text);
}
.container p {
  box-shadow: 1px 1px 1px var(--_shadow);
}
.hi {
  --_shadow: yellow;
  --_color--text: blue;
}
.bye {
  --_color--text: green;
}
=> Nó giúp giảm số lượng css selector. Nhìn custom var, ta hiểu ngay là biến định nghĩa trong container thay vì tìm trên :root. Chỉ đè private var 1 lần thôi, k đè nh lần.

-> @property trong css houdini giúp khai báo biến css type safe, nên dùng với animation.
Bản chất @property là khai báo biến và nó trở thành 1 thuộc tính (property) của css class đó luôn.
VD: @property --rotation {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}
.box {
  --rotation: 60deg;
  transform: rotate(var(--rotation));
  transition: --rotation 1s ease-in-out;
}
=> Transition trực tiếp biến --rotation được vì nó như 1 thuộc tính của class r, dùng css bình thường phải dùng transition all 1s linear mới được.



# Metadata SEO
***URL tag trong <head>: https://github.com/joshbuchea/HEAD

-> Config thường dùng:
<title>Title</title>
<meta name="description" content="Test setup website">
<meta name="keywords" content="test,setup"/>
<link rel = "canonical" href = "http://example.com/"/> => 1 web có nhiều url dẫn tới cùng 1 nội dung, gg không biết url nào nên hiển thị trên kết quả tìm kiếm. Luôn dùng thẻ canonical trỏ tới web gốc để thông báo cho search engine URL này là trang chính và tránh lập chỉ mục với URL của các trang trùng lặp khác
<link rel="preload" as="image" href="./logo.svg"/> => ưu tiên preload
<link rel="icon" href="./logo.svg"/>

<meta property = "og:type" content = "article" /> => hay "website"
<meta property = "og:title" content = "TÊN TIÊU ĐÊ HOẶC TRANG WEB" />
<meta property = "og:description" content = "MÔ TẢ CỦA TRANG NỘI DUNG" />
<meta property = "og:image" content = "./assets/logo.svg" />
<meta property = "og:image:alt" content="Collection Image"/>
<meta property = "og:url" content = "PERMALINK" />
<meta property = "og:site_name" content = "TÊN TRANG WEB" />
<meta property = "og:locale" content="en_US"/>

<meta name = "twitter:title" content = "TÊN TIÊU ĐỀ HOẶC TRANG WEB"> => ghi đè og:title vì og là thẻ chung, các thẻ từng nền tảng sẽ ghi đè og
<meta name = "twitter:description" content = ”"MÔ TẢ TRANG NỘI DUNG">
<meta name = "twitter:image" content = "LINK TO IMAGE">
<meta name = "twitter:site" content = "USERNAME">
<meta name = "twitter:creator" content = "@ USERNAME">

Khi có nhiều lang:
<link href="https://opensea.io" hrefLang="en" rel="alternate"/>
<link href="https://opensea.io/zh-CN" hrefLang="zh-CN" rel="alternate"/>
<link href="https://opensea.io/zh-TW" hrefLang="zh-TW" rel="alternate"/>
<link href="https://opensea.io/de-DE" hrefLang="de-DE" rel="alternate"/>

--> <meta name="viewport" content="width=device-width, initial-scale=1.0"> => luôn có thẻ này để cho phép người dùng zoom-in text, điều này phù hợp với những người thị lực yếu vào website, họ sẽ phải dùng các tool giúp zoom to trang web để nhìn rõ, VD CTRL+ của browser. Có thể custom: 
<meta name="viewport" content="user-scalable=yes"/> => cho phép người dùng sử dụng các tool zoom cho trang web
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=1"/> => chỉ cho max scale đến 200%
<meta name="viewport" conent="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/> => k cho zoom vì sợ break design
=> 1 số thiết bị có tính năng zoom text only, nhưng nếu text zoom to mà layout k zoom sẽ break design

-> Tối ưu SEO:
- Dùng đủ alt cho image
- Nên dùng senmatic element tốt cho SEO vì tạo cấu trúc nội dung rõ ràng hơn cho search engine hiểu:
header và footer ở đầu cuối page; figure chứa img và figcaption khi cần ảnh có chú thích; nav tạo navigation; aside tạo content related indirect to main; main chứa các article; article có các section; section có detail, detail có content bth và 1 thẻ summary; <mark> để highlight important text
Các thẻ heading h1 h2 chỉ nên dùng cho heading chứ k chủ động dùng để tạo big text vì search engine dùng heading để đánh index cho nội dung page
1 số thẻ đặc biệt như <time> biểu diễn thời gian. VD: <time datetime="2008-02-14 20:00"> thì thời gian trong attribute này sẽ được dịch sang machine-redable format và browser có thể thêm date này vào reminder của user's calendar nếu có và search engine cũng cho kết quả search thông minh hơn.
- Mỗi thẻ h1, h2 nên có id để có url # ref tới vị trí đó nhanh, k giúp SEO nhưng UX tốt hơn:
document.querySelectorAll("h2").forEach(function(el) {
  if (!el.hasAttribute("id")) {
    el.setAttribute("id", el.textContent.replaceAll(/[^a-z]/gi, ''));
  }
});

-> Preload ảnh:
<link rel="preload" as="image" href="/static/images/logos/opensea.svg"/>
<link rel="preload" as="image" imagesrcset="
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=640 640w, 
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=750 750w,
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=828 828w,
" imagesizes="100vw"/>
Có thể preload 1 ảnh cố định, preload 1 file hay preload ảnh nào trong list tuỳ theo kích thước màn hình. 
VD ở đây imagesrcset có 3 bức ảnh có 3 chiều rộng khác nhau và imagesizes chỉ rằng ảnh sẽ chiếm full màn. Tuỳ kích thước màn, browser tự chọn 1 trong 3 ảnh phù hợp kích thước để tải trước và cache lại. Mọi chỗ trong web sử dụng đúng url ảnh đã cache sẽ lấy luôn từ cache ra, nên thường kết hợp với srcset của <img>

-> <link rel="prefetch" href="products.html">
Preload chỉ dùng cho page hiện tại, session hiện tại, với tài nguyên cần gấp. Chỉ nên preload ít để tránh page tải lâu.
Prefetch chỉ chạy khi browser rảnh và thường query tài nguyên cho next page k cần dùng ngay. Thời gian cache sẽ theo Cache-Control, or browser hard refresh cũng tải lại.
Trong quá trình thao tác, tag này được add bằng JS cũng khiến browser tự prefetch url.

-> Google bot tự đánh chỉ mục với mọi trang web mà nó truy cập được, trừ khi có robots.txt hay thẻ meta robots cản nó => thường để robots.txt default or k cần. Dùng khi có trang k cần đánh index thì đỡ tốn crawl budget cho các trang kqtr.
VD1 robots.txt có tác dụng trong toàn page, chỉ cần đặt file này vào cùng file gốc index.html:
User-agent: *
Disallow: /page2.html
=> Googlebot đọc mọi pages trừ page2.html
VD2 <meta name = "robots" content = "noindex, nofollow"> => Không lập chỉ mục hay không theo dõi các liên kết từ page này.
<meta name = "robots" content = "index, follow"> => Có lập chỉ mục và theo dõi các liên kết từ trang này 
VD3: cho robots.txt cản pages2, nhưng trong pages 2 lại dùng thẻ meta robots cho phép index, thì googlebot gặp robots.txt sẽ bỏ qua pages2 luôn và chưa kịp thấy thẻ meta nên k đánh index

-> Sitemap: robots.txt là file kiểm soát quá trình crawl của search engine, còn sitemap.xml giúp search engine đánh chỉ mục dễ hơn sẽ SEO tốt hơn.
Sitemap chứa thông tin về các url cần crawl và cấu trúc nội dung, dễ đánh chỉ mục hơn với web có nội dung dài. \
Tạo sitemap.xml đặt cùng index.html, thêm cả robots.txt để gg biết, host lên, đăng ký sitemap với Google Search Console theo dõi thống kê để biết mà cải thiện SEO.
=> Web phức tạp nhiều content thì nên có vì giúp crawl dễ hơn

-> Nhanh:
Config thường dùng về canonical, og, language
Dùng senmatic element, dùng h1 h2 kèm id.
Preload ảnh, prefetch file.
robots.txt và sitemap.xml => đọc qua

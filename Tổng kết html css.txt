# Basic
-> Bản chất kích thước trong css
- margin collapse là hiện tượng bottom margin thẻ trên bị merge với top margin thẻ dưới => fix bằng cách dùng padding hoăc cho thành inline-block
- padding-top 100% lấy 1/3 phần height thẻ cha. VD: A height 600px chứa B có padding-top 100% thì B có padding top là 200px vì chia đều cho padding top, bottom, content height
- inline chiếm đủ nội dung và k thể set width height, block chiếm toàn bộ chiều ngang và có thể set. inline-block giống inline nhưng có thể set width height.
- width auto chiếm full remaining space k tính margin, khác với width 100% sẽ có kích thước = 100% width thẻ cha. Nếu nhiều thẻ auto sẽ chia đều.
Cách khác nếu muốn fillup remaining space là dùng flex-grow, fill-available
- Mọi trường hợp, min lớn hơn max sẽ lấy min. Vd min-height > max-height sẽ lấy min-height
- Bản chất về height:
height auto là default sẽ tự mở rộng theo kích thước content. Thường css reset cũng để thẻ body mặc định như v chứ k set height cố định.
Khi set 50% sẽ theo kích thước thẻ cha trực tiếp. Nếu thẻ cha trực tiếp k set height or auto theo thẻ con, thì bị loop, khiến thuộc tính height 50% invalid và coi như k có. 
VD thẻ cha có mỗi min-height:100vh; thẻ con height 50% sẽ k chạy vì height thẻ cha vẫn là auto tương tự như trên. 

-> Tổng kết dự án basic:
- Tạo dự án: parcel import npm; html thuần import cdn; react;
- Hosting: Github pages, netlify.
- Darkmode: scss dùng map; css thuần dùng var có thể set từ checkbox hoặc dùng JS set data-theme attribute cho thẻ body, hoặc viết thủ công như cách scss sau khi tạo ra; Dùng css relative color tạo color palette.
- Chia file: html thuần chia mỗi pages 1 file; css chia style chung và riêng từng pages ở các file riêng rồi import file css trực tiếp lẫn nhau được; scss cũng style chung từng file, từng pages @use các file chung đó, chia cả file components các thứ, cuối cùng quy hét về 1 file scss duy nhất @use tất cả để compile bằng 1 lệnh thôi, mọi pages đều phải script tới file chung đó dẫn đến style thừa nhưng chả sao.
- BEM: scss dùng &__container, css cũng vậy. Trong file css 1 pages có <section>__<subsection>__<content>, max là 4 level. CSS Selector 1 level thôi.
- Responsive: dùng css var với responsive hack grid flex, dùng clamp; Dùng @container > @media; scss dùng @mixin chia từng màn hình @media thuần và css hack.
- Routing chuyển pages: dùng thẻ a or window.location.href để chuyển page load lại mọi thứ, or mở tab mới; Dùng history.pushState + URLSearchParams cho đổi url mà k chuyển page; có thể prefetch trước file cho pages same site <link rel="prefetch" href="./page2.html">; Dùng view transition api; Dùng session storage lưu data các pages;



# BEM
BEM (Block-Element-Modifier) kbh dùng id mà chỉ có class và tên các class tuân theo chuẩn. Nested thì chỉ nên 1 cấp. BEM max 4 cấp
VD để biểu diễn item nằm trong khối block menu, thay vì:
  .menu { ... }
    .menu .item { ... }
    .menu .item.active { ... }
Ta dùng:
  .menu { ... }
    .menu__item { ... }
    .menu__item--active { ... }

VD: <a class="btn btn--orange" href="#">
  <span class="btn__price">$9.99</span>
  <span class="btn__text">Subscribe</span>
</a>
và file css: .btn { ... }
.btn--orange { ... } => -- có tính chất gì
.btn__price { ... } => __ là gì
.btn__text { ... }



# CSS reset
width default là auto tự full và k cần set 100% làm gì, height default tự theo content và chỉ cần set min-height 100dvh nếu cần footer dưới cùng thôi.

-> Phân biệt:
initial: lấy thông số kỹ thuật của css. VD display có default là inline sẽ khiến mọi thẻ thành inline kể cả các thẻ div => k dùng vì nhiều cái default rất ảo
unset: có parent thì lấy theo parent, nếu chưa từng set cho parent thì lấy initial value là thông sô kỹ thuật của css => k dùng
inherit: lấy giá trị thuộc tính kế thừa từ cha. Vì mọi thẻ đều có mọi thuộc tính, nếu cha k set sẽ dùng default value của browser. Chú ý default value của browser khác với default value của css property.
none: k set giá trị và coi như k có giá trị đó luôn, 1 vài css prop có giá trị này thôi.

-> Import css tự reset trước, rồi đến css của thư viện, sau đó là css cho component tuỳ chỉnh.
Bản chất: chia theo layer -> trong cùng cấp layer, style 1 thẻ con sẽ ghi đè style thẻ cha, style thẻ cha là body cũng mạnh hơn html vì cha gần hơn -> cùng là style thẻ đó thì style ngoài layer sẽ đè style layer con, cùng cấp layer mới chia theo specifility => Đó chính là lý do vì sao html là 0:0:1 nhưng lại k đè được :where là 0:0:0
VD thứ tự khi reset giả sử chỉ có 1 layer:
html => spec 0:0:1, là thuộc tính cha html của mọi thẻ, thường set style base mọi thẻ
:root => spec 0:1:0, là thuộc tính cha html của mọi thẻ, thường định nghĩa css var, k style (pseudo class)
body => spec 0:0:1, là thuộc tính cha body của mọi thẻ, thường dùng định nghĩa style cho body và mọi thẻ khác mà dùng biến trong :root
user agent stylesheet => cố định k thể sửa với từng thẻ
* => spec 0:0:0, set thuộc tính base cho mọi thẻ, thường để đè user agent stylesheet
:where(tag) => spec 0:0:0, set thuộc tính base cho 1 tag cụ thể
Trong react còn có #id là thẻ bao ứng dụng.



# Dùng @import trong css
- @import nhiều lần cùng 1 file sẽ lấy cái sau thôi, k sợ trùng.
- @import url("./2.css") layer(base); => nhét mọi code trong 1 file css trong 1 layer
- Phải để ở đầu file, nó sẽ chạy tuần tự và làm chậm tải trang => hạn chế dùng trong production mà nên bundle 1 file index.css duy nhất. Vd dùng parcel build.
Nếu được nên dùng <link rel="stylesheet" href="styles/reset.css"> sẽ chạy import nhiều file css song song nhưng vẫn đảm bảo thứ tự trong html nên k sao.

-> Nhanh:
Có thể chia layer
K dùng production vì tuần tự



# Dùng @scope và @layer
-> @scope selector k ảnh hưởng spec, selector bên trong giữ nguyên spec. Trong cùng 1 layer, nếu bên ngoài và trong scope đều cùng specifility, sẽ ưu tiên lấy trong scope
@scope có thể giới hạn style trong 1 phạm vi mà nested selector không làm được. VD @scope (article) to (aside) { } từ cha article đến con aside và k tính con.

VD2: @scope (.text) to (button.xxx) { // button.xxx k ảnh hưởng spec
  :scope { } // tương đương với & { } là root của @scope chính là .text
  p { color: red; }
  button { color: yellow; }
}
VD2: @scope (.text) to (button.xxx, a, p[class]) { } 
VD3: @scope (article) to (> figure) {} => áp dụng cho mọi con của article, trừ con trực tiếp là tag figure
VD4 scope lồng: @scope(aside) { @scope (article) { ... } }

:scope như 1 class selector duy nhất để tính spec, còn & thì tính spec như nested thế vào bth.
VD: @scope (main .text) to (button.xxx) {
  :scope img { } // (0, 1, 1)
}
@scope (main .text) to (button.xxx) {
  & img { } // (0, 1, 2) vì & thế vào thành "main .text img {}"
}

-> Có 3 loại layer theo thứ tự đè nhau: user agent styles -> user styles -> author styles
user agent style có sẵn browser k thể đổi. Có thể dùng @layer định nghĩa thêm các layer con trong author styles, còn style bth vẫn thuộc layer author styles và k nằm trong layer con nào.

Layer sau luôn đè layer trước, kể cả !important cũng k thể tác động, nên cần chú ý thứ tự import các layer.
VD: @layer framework, reset, base, layout, components; => để đầu file mới có tác dụng khai báo thứ tự, bên dưới set thế nào vẫn luôn tuân theo thứ tự này
=> Nếu lib css dùng layer riêng sẽ dễ custom hơn vì kể cả lib có dùng !important, vẫn có thể override với layer custom được import sau.

Trong cùng 1 layer thì style ngoài sẽ đè style trong layer con. 
@layer có thể lồng trong @layer khác và quy tắc vẫn tương tự.

--> scss dùng @layer như bth, nhưng nó phải dùng @use ở đầu nên k thể định nghĩa @layer trước nó được, buộc phải nhét @layer vào 1 file scss riêng rồi @use nó ở đầu để xuất hiện ở đầu
Case đặc biệt là @import có thể dùng bên trong @layer, nhưng @use thì không. VD fix với:
@use 'sass:meta';
@layer base, components, utilities;
@layer components {
  @include meta.load-css('components'); // Thế cho @use 'components'
}

-> Nhanh:
Các layer k thể can thiệp kể cả !important. Trong 1 layer thì style ngoài layer sẽ đè style trong layer
@layer phải khai báo thứ tự ở đầu. Sau đó muốn viết thứ tự như nào xuống dưới cũng được.



# Spec và CSS Selector
Cascade là khi cùng spec thì theo thứ tự định nghĩa. VD ta link file css sau <style> thì css trong file sẽ đè lên css trong tag <style>.
layer sau đè layer trước > cùng layer thì thẻ cha gần đè thẻ cha xa, style con đè style cha > cùng style con thì style bình thường đè style layer con -> cùng layer và cùng style con thì theo specifility -> cùng specifillity thì theo quy tắc @scope và cái sau đè cái trước
inline style > !important > style theo id > style class, pseudo-class, attributes > element and pseudo-element > universal selector(*)

-> Specifility (0,1,1) theo thứ tự là: Số ID selector; Số class / pseudo class / attribute selector; Element và số pseudo elements như :after, :first-letter
URL check spec: https://specificity.keegan.st/

VD1: pseudo-class :hover
attributes-selector img:not([alt]) 
pseudo-element: .test:before
VD2: dialog.hide 0:1:1 = dialog[open] 0:1:1 > .hide 0:1:0

-> Combinator:
space là descendant mọi cấp
>  child trực tiếp
~  mọi sibling sau
+  1 sibling ngay sau 

-> VD selector:
a[href$=".abc" i] => tag a có href kết thúc bằng .abc case insensitive
[href*="google.com"] => tag có href attribute chứa google.com ở bất kỳ đâu
:active => button, link đang được click, kể cả touch screen
::selection => text được bôi đen
:visited X :link => :link là <a> chưa visit bao giờ
p:empty => thẻ p k có text bên trong 
:nth-last-of-type(2) => sibling cuối cùng thứ 2. nth-of-type là cùng loại html tag thứ mấy
:nth-of-type(2 of .green) => là thẻ thứ 2 có class green.
p:lang(it) { } => thẻ p có lang là italia. VD: <p lang="it">Ciao bella!</p>
.grid > :nth-child(4n) => con trực tiếp trong grid mà thứ tự chia hết cho 4
:has(:nth-child(5):last-child) { } => nếu thẻ có đúng 5 con
p:only-child { } => thẻ p là con duy nhất của 1 thẻ khác 
::initial-letter = ::first-letter => tạo chữ đầu tiên to đùng như đầu bài báo article
X:before default ở top left, X:after default ở top right, nằm trong thẻ X
:target => style cho thẻ chứa id, khi được href tới id, từ 1 thẻ khác 

VD tạo checkbox với option light/dark mode thì: body:has(option[value="dark"]:checked){ --background: black; --text-color: white; }
VD ấn vào ảnh là phóng to ảnh, cck 1 button đóng ảnh css only. Thì click thẻ a ref tới ảnh và style img:target phóng to, khi close thì xoá target bằng href="#" k hợp lệ.
VD read more với CSS only: dùng 2 dùng label + checkbox + :checked để ẩn hiện text

--> Special navigate với thẻ a:
<a href="#"> => Invalid tự scrolls to the top of a document, or <a href="#top"> nếu k có thẻ id top
<a href=""> => Reloads the current page, preserving the search string but removing the hash string (if present)
<a href="."> => Reloads the current page, removing both the search and hash strings
<a href="?"> => Reloads the current page, removing both the search and hash strings (nhưng keeps `?`)
<a href="data:"> => Link to data URLs, like text fragments
<a href="video.mp4#t=10,20"> => Links chi tiết tới đoạn nào của media file

-> Pb:
- :is() sẽ lấy specificity của selector cao nhất bên trong và áp dụng cho tất cả, giúlip liệt kê gọn hơn. Còn :where() có spec là 0:0:0 cho css reset
:where(.parent) .child {} thì child vẫn giư specifility của nó là 0:1:0
VD: .example :is(h1, h2, .link) {} tương đương với .example h1, .example h2, .example .link {}
- :focus là chính thẻ đó focus. Còn :focus-within là khi bất cứ 1 thành phần bên trong nào của thẻ này được focus, bao gồm ấn tab thì đổi style thẻ này. 
:focus là chọn bởi chuột hoặc tabkey, :focus-visible là riêng TH chọn với tabkey vì nó visible trên UI
VD combo button:hover,:active,:focus-visible => hover hoặc click bởi chuột, bàn phím, tabkey
VD button show dropdown thì dùng :focus-within thay cho :focus để click vào item con thì button cũng k ẩn dropdown, chứ kp chỉ được ấn vào thẻ dropdown cha.
VD click chuột vào 1 phần tử trong list thì đổi style đơn giản: từng item thêm tabIndex={index}, trong css bắt sự kiện thẻ đó :focus r chỉnh style thoải mái. 

-> Nhanh: 
Spec 
4 combinator
light/dark mode, phóng to ảnh với css only, readmore
Có thể special navigate với thẻ a
:is và :where
:focus và :focus-within, dùng :focus với tabIndex



# Dùng font
TrueType Fonts (TTF): TrueType là định dạng font phổ biến cho các hệ điều hành Mac OS và Windows.
OpenType Fonts (OTF): OpenType là một định dạng được phát triển dựa trên nền tảng của TrueType.
Web Open Font Format (WOFF): là một TrueType nhưng nhẹ hơn và được W3C khuyến khích dùng
Web Open Font Format (WOFF 2.0): là một bản nén tuyệt vời hơn WOFF 1.0.
Embedded OpenType Fonts (EOT): EOT là một hình thức nén ít dùng của OpenType
SVG Fonts: là chữ biến hóa như ảnh graphic. 
Còn có material icons là icons viết dạng tag html

-> Thêm font mới:
- Dùng @import url(<remote url>); để import có trực tiếp font-family trong css, k dùng được với local url.
- Set font từ local file:
@font-face {
  font-family: MyFont;
  src: url(sansation_light.woff2) format("woff2"),
       url(sansation_light.woff) format("woff"); // Browser k support woff2 tự chuyển sang woff, hỗ trợ hết r nên k cần thiết
  font-weight: 100;
}
h2 {
  font-family: MyFont, sans-serif; // K tìm thấy MyFont sẽ dùng font sans-serif mặc định của browser
}
- Nên dùng 1 font file chuẩn và style tự set. Nếu buộc có nhiều style chia font-file riêng, phải thêm font-style font-weight để pb, dùng đúng style sẽ tự lấy đúng font
VD dùng cùng tên font nhưng style khác nhau:
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-Bold-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: normal;
}
@font-face {
  font-family: "DroidSerif";
  src: url("DroidSerif-BoldItalic-webfont.ttf") format("truetype");
  font-weight: bold;
  font-style: italic;
}
Sử dụng nó tự dùng đúng font tương ứng:
body { font-family: "DroidSerif", Georgia, serif; }
h1 { font-weight: bold; } // Cả 2 font cùng có styles sẽ lấy font đầu tiên
em { font-style: italic; }
strong em {
  font-weight: bold;
  font-style: italic;
}
Short hand nhiều url:
@font-face {
  font-family: 'Klavika';
  src: url(../fonts/Klavika-Regular.otf) format('truetype') font-weight-normal,
       url(../fonts/Klavika-Bold.otf) format('truetype') font-weight-bold,
       url(../fonts/Klavika-Bold-Italic.otf) format('truetype') font-italic font-weight-bold;
}

--> Variable fonts cho phép đổi thuộc tính cùng 1 font file, k fix cứng font-size, font-weight, italic => nên luôn dùng
Khi tải font chú ý font-weight fix cứng thì k nên dùng. Variable font thì FE chỉ cần tải 1 file rồi tự style thoải mái.
VD roboto là static font, roboto_flex là variable font

-> Web safe font: Có các font chạy trên linux ok nhưng sang window bị lệch dòng, phải sửa thẳng vào file ttf bằng FontForge mất tg. Web safe font là các font chạy mượt với mọi browser và hđh. Nó k đảm bảo lúc nào cũng khả dụng nên phải thêm fallback fonts nếu dùng.
URL: https://www.w3schools.com/cssref/css_websafe_fonts.php
URL: https://www.w3schools.com/cssref/css_fonts_fallbacks.php

-> Các thuộc tính:
- text-transform: uppercase; => viết hoa input của người dùng, luôn dùng thay cho JS
- font-systhesis => bỏ, default auto tự cho phép browser giả style khi font k hỗ trợ. 
Chỉ cần đảm bảo k bị lỗi hiển thị là đươc. Nếu thêm style mà text k đổi thì là do font k hỗ trợ và browser cũng k giả style được.
- text-rendering => default auto browser tự quyết định cân bằng optimizeSpeed, optimizeLegibility, hay độ chính xác hình học (geometricPrecision)
optimizeLegibility là giúp vc chữ hiển thị dễ đọc, phân biệt "f l i" bằng cách in với kích thước hơi khác biệt 1 chút cho người dùng tránh nhầm
=> Để thế nào cũng được, nếu k sợ nhầm chữ thì để optimizeSpeed
- font-smooth => luôn để always là luôn tối ưu smooth cho các thiét bị
Dùng kèm -webkit-font-smoothing: auto/none/antialiased/subpixel-antialiased (nét chữ sắc nhất) => MacOs
-moz-osx-font-smoothing: auto/grayscale => Firefox MacOS 
- font-display => Chỉ định cách hiển thị font khi chưa tải xong. default auto. 
block: text sẽ bị ẩn nhưng vẫn chiếm k gian (tối đa 3 giây) trong khi chờ font tải xong, sau đó sẽ hiển thị với font mong muốn.
swap: text hiển thị ngay lập tức bằng font dự phòng, sau đó thay thế bằng font mong muốn khi tải xong => luôn dùng css reset

-> Font size clamp:
Màn hình luôn được chia thành 100 vw và vh. VD màn hình là 1460px thì 1vw sẽ tương ứng với 14.6px
clamp(a, b, c); lấy 1 giá trị trong khoảng a và c. Nó ss lấy min(b,c) là x rồi lấy max(a, x) trả ra kết quả. Nên dùng min, max, clamp thay thế width, max/min-width.
URL: https://clamp.font-size.app
VD màn hình dưới 700px có font-size là 16px, sau đó tăng dần tuyến tính lên 1px mỗi 100px tăng lên cho đến max là 22px => font-size: clamp(16px, 1vw + 9px, 22px);
Khi 700px, nó sẽ là clamp(16px, 16px, 22px) thì lấy 16px. Font size tuyến tính tăng lên 1300px thì clamp(16px, 22px, 22px) thì lấy 22px

--> Gợi ý:
Màn hình break point: 500 - 1300 - 1900 => đặt ở 2 mốc 500 và 1300 là được
1) Màn hình lớn: text thường 16px, chữ to 20px, title 24px, chữ khổng lồ 48px, button 16px
Màn hình mobile: text thường 14px, chữ to 16px, title 20px, chữ khổng lồ 36px, button 14px 
2) Màn hình lớn: text siêu bé 12px, text thường 14px, title 16px, chữ khổng lồ 40px, button 14px
Màn hình mobile: text thường 12px, title 14px, chữ khổng lồ 20px, button 14px

-> Color font thêm màu. Tut: https://www.youtube.com/watch?v=VpZSMq2ajDE
URL web check màu color font support: https://wakamaifondue.com/
@font-palette-values --identifier {
  font-family: Bixa;
  base-palette: 3; // trong web từ trên xuống là các palette font hỗ trợ
  override-colors: 0 rgba(0,0,0,1), 2 red; // trong web từ trái sang là các color index để override
}
.my-class {
  font-palette: --identifier;
}

-> K dùng px vì browser đổi font-size và px sẽ override browser setting. Khi font-size tăng, nhiều nơi khác cũng nên tăng. 
Với kích thước bth như @media hay padding margin nên dùng rem, font-size cũng dùng rem. Với spacing liên quan đến text mới dùng em. 
VD box-shadow dùng px thoải mái vì chả liên quan đến font. Hoặc ảnh hay cái gì k phụ thuộc vào font-size mà cố định ở mọi màn hình thì để px.

-> Custom chữ trang trí:
-webkit-text-stroke: 1px black; => text-stroke tạo 1 đường viền ngoài cho svg, mà font thực chất là svg nên tạo viền cho font. Thường kết hợp thêm với text-shadow.
paint-order: stroke fill; => stroke được vẽ trước r mới fill màu lên tạo chữ đẹp hơn là để mặc định
Còn có text-fill kiểm soát màu > color

-> Nhanh:
- Thêm font remote với @import, local với @font-face. Dùng variables font k phải định nghĩa từng style. Web safe font, fallback font.
- font size clamp
- Có thể custom màu color font
- Dùng rem với kc phụ thuộc font, nếu kc liên quan đến text thì dùng em.
- Dùng text-stroke + text-shadow + paint-order tạo chữ đẹp



# Đơn vị trong CSS
-> Đơn vị tuyệt đối chỉ đúng trên các thiết bị độ phân giải cao như máy in, còn trên laptop và di động có thể sai khác. VD 1in = 96px = 2.54cm

-> Relative Units
em: tương đối so với font-size của phần tử cha
*rem (root em): Giống em, nhưng là tương đối với phần tử gốc <html>, hoặc theo setting browser nếu k set.
ex: Tương đối so với chiều cao chữ "x" của font hiện tại.
ch: Chiều rộng của ký tự "0" trong font đang dùng
*vw: Tương đối 1% width của kích thước cửa sổ trình duyệt (viewport).
*vh: Tương đối 1% height của kích thước cửa sổ trình duyệt (viewport).
vmin Relative to 1% dựa trên chiều nhỏ hơn của trình duyệt. VD điện thoại xoay dọc thì vmin sẽ là 1% của height
vmax Relative to 1% dựa trên chiều lớn hơn của trình duyệt
*%: Có giá trị tương đối so với phần tử cha.
=> Tức browser default 1rem = 16px or setting browser, nên set :root là 1rem or default luôn, các thẻ khác cũng dùng rem nhưng font to hay nhỏ set với dùng clamp là xong.

--> Các đơn vị đặc biệt cho mobile: lvh, dvh, svh, svw 
vh là chiều cao cơ bản, k tính toolbar.
lvh là chiều cao lớn nhất khi k có toolbar, svh là chiều cao nhỏ nhất khi k có toolbar
dvh là chiều cao dynamic tự thay đổi khi toolbar ẩn hoặc hiện => luôn dùng thay vh khi ứng dụng có chạy trên mobile

-> Nhanh:
Dùng rem em (px khi klq tới font) và dvh



# Private custom variable
VD click chuột là đổi màu vài thẻ thì nên dùng css var và đổi giá trị var thay vì gán lại style từng thẻ, tốt hơn cả việc gán class. Có thể dùng để tạo theme khác nhau.

-> Trong dự án lớn, nên dùng fallback var + kế thừa + private custom var. 
Lưu ý chỉ đè private var tối đa 1-2 lần thôi, k đè nh lần.
VD: <div class="container">
  <div class="hello">
    <button>Hello</button>
    <p>Hello</p>
  </div>
  <div class="hi">
    <button>Hi</button>
    <p>Hi</p>
  </div>
  <div class="bye">
    <button>Bye</button>
    <p>Bye</p>
  </div>
</div>

Cách làm ngu:
.hello button {
  color: red;
}
.hello p {
  box-shadow: 1px 1px 1px red;
}
.hi button {
  color: blue;
}
.hi p {
  box-shadow: 1px 1px 1px yellow;
}
.bye .button {
  color: green;
}
.bye p {
  box-shadow: 1px 1px 1px red;
}

Best practice là dùng private custom variables
.container {
  --_shadow: var(--shadow, red);
  --_color--text: var(--color, var(--color-text, red));
}
.container button {
  color: var(--_color--text);
}
.container p {
  box-shadow: 1px 1px 1px var(--_shadow);
}
.hi {
  --_shadow: yellow;
  --_color--text: blue;
}
.bye {
  --_color--text: green;
}
=> Nó giúp giảm số lượng css selector. Nhìn custom var, ta hiểu ngay là biến định nghĩa trong container thay vì tìm trên :root. 

-> @property trong css houdini giúp khai báo biến css type safe, nên dùng với animation.
Bản chất @property là khai báo biến và nó trở thành 1 thuộc tính (property) của css class đó luôn.
VD: @property --rotation {
  syntax: '<angle>';
  inherits: false;
  initial-value: 0deg;
}
.box {
  --rotation: 60deg;
  transform: rotate(var(--rotation));
  transition: --rotation 1s ease-in-out;
}
=> Transition trực tiếp biến --rotation được vì nó như 1 thuộc tính của class r.



# Metadata SEO
***Mọi tag trong <head>: https://github.com/joshbuchea/HEAD

-> Config thường dùng:
<title>Title</title>
<meta name="description" content="Test setup website">
<meta name="keywords" content="test,setup"/>
<link rel = "canonical" href = "http://example.com/"/> => 1 web có nhiều url dẫn tới cùng 1 nội dung, gg không biết url nào nên hiển thị trên kết quả tìm kiếm. Luôn dùng thẻ canonical trỏ tới url gốc để thông báo cho search engine URL này là trang chính.
<link rel="preload" as="image" href="./logo.svg"/> => ưu tiên preload
<link rel="icon" href="./logo.svg"/>

<meta property = "og:type" content = "article" /> => hay content="website"
<meta property = "og:title" content = "TÊN TIÊU ĐÊ HOẶC TRANG WEB" />
<meta property = "og:description" content = "MÔ TẢ CỦA TRANG NỘI DUNG" />
<meta property = "og:image" content = "./assets/logo.svg" />
<meta property = "og:image:alt" content="Collection Image"/>
<meta property = "og:url" content = "PERMALINK" />
<meta property = "og:site_name" content = "TÊN TRANG WEB" />
<meta property = "og:locale" content="en_US"/>

<meta name = "twitter:title" content = "TÊN TIÊU ĐỀ HOẶC TRANG WEB"> => ghi đè og:title vì og là thẻ chung, các thẻ từng nền tảng sẽ ghi đè og
<meta name = "twitter:description" content = ”"MÔ TẢ TRANG NỘI DUNG">
<meta name = "twitter:image" content = "LINK TO IMAGE">
<meta name = "twitter:site" content = "USERNAME">
<meta name = "twitter:creator" content = "@ USERNAME">

VD khi có nhiều lang:
<link href="https://opensea.io" hrefLang="en" rel="alternate"/>
<link href="https://opensea.io/zh-CN" hrefLang="zh-CN" rel="alternate"/>
<link href="https://opensea.io/zh-TW" hrefLang="zh-TW" rel="alternate"/>
<link href="https://opensea.io/de-DE" hrefLang="de-DE" rel="alternate"/>

<meta name="viewport" content="width=device-width, initial-scale=1.0"> => luôn có thẻ như này để cho phép người dùng zoom-in text, điều này phù hợp với những người thị lực yếu vào website, họ sẽ phải dùng các tool giúp zoom to trang web để nhìn rõ, VD CTRL+ của browser. Có thể custom: 
<meta name="viewport" content="user-scalable=yes"/> => cho phép người dùng sử dụng các tool zoom cho trang web
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=1"/> => chỉ cho max scale đến 200%
<meta name="viewport" conent="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/> => k cho zoom vì sợ break design
=> 1 số thiết bị có tính năng zoom text only, nhưng nếu text zoom to mà layout k zoom sẽ break design

-> Tối ưu SEO:
- Dùng đủ alt cho image
- Nên dùng senmatic element tốt cho SEO vì tạo cấu trúc nội dung rõ ràng hơn cho search engine hiểu:
header và footer ở đầu cuối page; figure chứa img và figcaption khi cần ảnh có chú thích; nav tạo navigation; aside tạo content related indirect to main; main chứa các article; article có các section; section có detail, detail có content bth và 1 thẻ summary; <mark> để highlight important text
Các thẻ heading h1 h2 chỉ nên dùng cho heading chứ k chủ động dùng để tạo big text vì search engine dùng heading để đánh index cho nội dung page
1 số thẻ đặc biệt như <time> biểu diễn thời gian. VD: <time datetime="2008-02-14 20:00"> thì thời gian trong attribute này sẽ được dịch sang machine-redable format và browser có thể thêm date này vào reminder của user's calendar nếu có và search engine cũng cho kết quả search thông minh hơn.
Dùng thẻ a navigate thay vì button sẽ tốt cho a11y và SEO hơn. Single page thì dùng <a href="#idofelement"/>
Dùng ul li cho list
- Mỗi thẻ h1, h2 nên có id để có url # ref tới vị trí đó nhanh, k giúp SEO nhưng UX tốt hơn:
document.querySelectorAll("h2").forEach(function(el) {
  if (!el.hasAttribute("id")) {
    el.setAttribute("id", el.textContent.replaceAll(/[^a-z]/gi, ''));
  }
});

-> Preload ảnh:
<link rel="preload" as="image" href="/static/images/logos/opensea.svg"/>
<link rel="preload" as="image" imagesrcset="
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=640 640w, 
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=750 750w,
  https://i.seadn.io/gcs/files/ee67a8d1f6a2ba1ffbdb64a48c708f51.png?auto=format&amp;w=828 828w,
" imagesizes="100vw"/>
Có thể preload 1 ảnh cố định, preload 1 file hay preload ảnh nào trong list tuỳ theo kích thước màn hình. 
VD ở đây imagesrcset có 3 bức ảnh có 3 chiều rộng khác nhau và imagesizes chỉ rằng ảnh sẽ chiếm full màn. Tuỳ kích thước màn, browser tự chọn 1 trong 3 ảnh phù hợp kích thước để tải trước và cache lại. Mọi chỗ trong web sử dụng đúng url ảnh đã cache sẽ lấy luôn từ cache ra, nên thường kết hợp với srcset của <img>

-> <link rel="prefetch" href="products.html">
Preload chỉ dùng cho page hiện tại, session hiện tại, với tài nguyên cần gấp. Chỉ nên preload ít để tránh page tải lâu.
Prefetch chỉ chạy khi browser rảnh và thường query tài nguyên cho next page k cần dùng ngay. Thời gian cache sẽ theo Cache-Control, or browser hard refresh cũng tải lại.
Trong quá trình dùng web, tag này được add bằng JS cũng khiến browser tự prefetch url.

-> Google bot tự đánh chỉ mục với mọi trang web mà nó truy cập được, trừ khi có robots.txt hay thẻ meta robots cản nó => thường để robots.txt default or k cần. Dùng khi có trang k cần đánh index thì đỡ tốn crawl budget cho các trang kqtr.
VD1 robots.txt có tác dụng trong toàn page, chỉ cần đặt file này vào cùng file gốc index.html:
User-agent: *
Disallow: /page2.html
=> Googlebot đọc mọi pages trừ page2.html
VD2 <meta name = "robots" content = "noindex, nofollow"> => Không lập chỉ mục hay không theo dõi các liên kết từ page này.
<meta name = "robots" content = "index, follow"> => Có lập chỉ mục và theo dõi các liên kết từ trang này 
VD3: cho robots.txt cản pages2, nhưng trong pages 2 lại dùng thẻ meta robots cho phép index, thì googlebot gặp robots.txt sẽ bỏ qua pages2 luôn và chưa kịp thấy thẻ meta nên k đánh index

-> Sitemap: robots.txt là file kiểm soát quá trình crawl của search engine, còn sitemap.xml giúp search engine đánh chỉ mục dễ hơn sẽ SEO tốt hơn.
Sitemap chứa thông tin về các url cần crawl và cấu trúc nội dung giúp dễ đánh chỉ mục hơn với web có nội dung dài.
Tạo sitemap.xml đặt cùng index.html, thêm cả robots.txt để gg biết, host lên, đăng ký sitemap với Google Search Console theo dõi thống kê để biết mà cải thiện SEO.
=> Web phức tạp nhiều content thì nên có vì giúp crawl dễ hơn

-> Nhanh:
Config thường dùng về canonical, og, language
Dùng senmatic element, dùng h1 h2 kèm id.
Preload ảnh, prefetch file.
robots.txt và sitemap.xml => đọc qua



# Speculation rules
URL: https://www.youtube.com/watch?v=LEF4UaM5m4U
- Speculationrules cho prefetch và prerender trong html cho tốc độ siêu tốc. Chỉ cần thêm 1 tag script là xong.
prefetch chỉ tải html, prerender sẽ tải hết và chạy cả js bên trong, fetch cả các API GET nếu có để client chỉ cần render ra. POST request sẽ bị delay gọi khi user truy cập
- Trong browser tab application có speculation rules hiển thị các trang đã được prefetch hay prerender.
- Khác với <link rel="prefetch> luôn prefetch ngay thì speculation rules có option eagerness kiểm soát nhiều hơn.
- eagerness mặc định là immediate tức page load là tải ngay prefetch luôn, nếu prerender sẽ tải hết tài nguyên, sẽ k ổn vì page lớn có quá nhiều file.
eager không khác immediate là mấy, cũng tải nhưng k vội. eager và immediate giới hạn tải 50 pages trước thôi. Chú ý mỗi file html tải trước sẽ là 1 files, chưa tính các tài nguyên bên trong.
moderate y hệt nhưng giới hạn max 2 pages, phải hover vào link hay scroll gần tới mới prefech. VD hover vào 3 đường link thì đường link đầu sẽ bị stale.
conservative cũng max 2 page nhưng user phải click vào link mới prefetch, nên chỉ lợi được 1 tí.
=> Có thể kết hợp page bth thì load moderate, page khác hay vào hơn thì load immediate.
- Việc prerender sẽ exec code JS và chạy trước các API GET luôn sẽ rất nguy hiểm. VD trang logout prerender execute code luôn là toang. 
Có nhiều cách fix như để request post thay vì GET để logout.
- Khi prerender sẽ gửi request kèm 1 header đặc biệt. VD nếu setup analytics thì k được tính số lần tải pages mà phải check vào pages k ở trạng thái prerender mới được.
Giải pháp là check khi thực sự vào 1 pages được prerender mới chạy analytics:
if(document.prerendering) { // true khi được tải bằng prerender
  document.addEventListener( "prerenderingchange", // event phát ra khi đổi trạng thái từ prerender sang k prerender nữa, VD khi thực sự access 1 pages đã được prerender
    func, { once: true }
  );
} else { func(); }
- Speculation rules k dùng reactjs vì nó là CSR. NextJS có prefetch sẵn rồi nhưng vẫn có thể dùng bằng cách thêm <script> nếu muốn kiểm soát

-> Nhanh:
Speculation rules là prerender mới exec hết code JS bên trong và gọi các API GET
Option eagerness giúp kiểm soát prefetch/prerender, prerender cẩn thận exec hết api GET bên trong
Có thể check page tải là prerender hay vào bth.



# a11y
Elements / Accessibility tool của browser giúp debug a11y

-> TK chỉ cần set: aria-label, aria-labelledby, aria-describedby, aria-hidden, aria-selected, aria-current, aria-autocomplete (kèm input autocomplete), title, alt, role, aria-expanded, label for để toggle input nếu có sẽ thay aria-label
- Icon thì nên có aria-hidden để ẩn khỏi screen reader, nếu có tính năng thì phải mô tả bằng aria-label cho tag bao nó
Thuộc tính hidden của html tương đương display none ẩn hết. Còn visibility: hidden chỉ ẩn trên UI mà k ẩn trên accessibility tree. 
VD: hidden + aria-hidden = false k hoạt động, vẫn ẩn cả UI và a11 tree bth.
- aria-controls xác định quan hệ điều khiển. Vd 1 button điều khiển dialog, menu, tab panel. VD: <button aria-controls="idofdialog"> => k nên dùng
- aria-describedby="idofelement" thêm mô tả chi tiết cho thẻ, kết hợp aria-labeledby được
-> aria-label text thuần: <button aria-label="Tìm kiếm"> => luôn dán nhãn nếu thẻ chỉ có icon
aria-labeledby để dùng các thẻ khác làm nhãn cho 1 thẻ: <div role="region" aria-labelledby="label1 label2">...</div>
<p id="label1">Giỏ hàng:</p> <p id="label2">Bạn có 3 sản phẩm.</p>

--> Đặc biệt cho input:
- Bộ 3 aria-errormessage, aria-invalid dùng cho thẻ input khi bị lỗi, aria-required báo input này k thể để trống.
VD: <input id="email" type="email" aria-invalid="true" aria-errormessage="email-error" aria-required="true">
<span id="email-error" role="alert">Email không hợp lệ</span>
- Bộ 3 aria-controls, aria-expanded và aria-haspopup cho button khi nó mở menu hay hộp thoại
aria-expanded cho <button> thì ấn button là mở rộng gì đó, cập nhật bằng JS khi mở và đóng là true và false, nó thể hiện trạng thái hiện tại của dialog
aria-haspopup="menu" cho <button> báo hiệu button này sẽ mở 1 menu popup ra thôi, chỉ dùng khi button chỉ mở, không dùng đóng.
<button aria-haspopup="dialog" aria-controls="login-dialog">
  Đăng nhập
</button>
<div id="login-dialog" role="dialog" hidden>
  <p>Vui lòng nhập thông tin đăng nhập.</p>
</div>
- Bộ 2 aria-selected và aria-multiselectable cho checkbox:
<ul role="listbox" aria-multiselectable="true">
  <li role="option" aria-selected="true">Mục 1</li>
  <li role="option" aria-selected="false">Mục 2</li>
  <li role="option" aria-selected="true">Mục 3</li>
</ul>
- aria-readonly cho input readonly. VD <input id="username" type="text" aria-readonly="true" value="user123">

-> Tạo tab chuẩn a11y: https://www.w3.org/WAI/ARIA/apg/patterns/tabs/
- pointer-events: none; sẽ cản sự kiện 1 tag. VD navigation bar đang ở tab .active thì ấn vào sẽ k load lại chính trang hiện tại nữa có thể dùng.
- aria-selected="true" báo đang ở tab nào
- role="tablist", role="presentation", role="tab", role="tabpanel"
Thuộc tính role sẽ loại bỏ ý nghĩa senmatic của thẻ, VD role="presentation" cho thẻ li chỉ định rằng phần tử có mục đích trình bày (decorative), không còn mang ý nghĩa semantic hay chức năng trong ngữ cảnh hiện tại, tức thẻ li k là list nữa và sẽ bị bỏ qua trong accessibility tree, screen reader sẽ không đọc hoặc thông báo về nó
- Mặc định ấn key tab sẽ navigate qua mọi thẻ a trên page. Nếu dùng tabindex="-1" cho 1 thẻ sẽ bị bỏ qua khi nhảy tab. Nếu dùng tabindex="0" cho 1 thẻ sẽ nhảy vào cả các thẻ bên trong. Điều này tiện cho việc ấn key tab vào 1 tab, và ấn key tab tiếp sẽ vào content của tab chứ k nhảy qua
Set bằng JS, ta cho mọi tab k active có tabindex="-1", tab đang active và nội dùng của nó có tabindex="0"
- Ấn tab và key left right phải switch tab. Cái này k có sẵn mà phải custom với sự kiện keydown.
Điều đặc biệt là khi ta add event keydown cho tabContainer thì chỉ khi ấn tab focus vào tabContainer thì keydown của nó mới bắt chứ ngoài màn hình gõ sẽ k ảnh hưởng
- Dùng kèm view transition api cho animation hoặc animation bằng JS custom
Dùng window.history.pushState để đổi url mà k chuyển page cho CSR, kèm xử lý onload lần đầu vào, xử lý khi gõ url vào cũng ở đúng tab nào.
Mỗi tab k nên chuyển pages mà nên là CSR, xử lý hiện ra bằng JS or dùng css thuần với label checkbox.
Khi chuyển tab, lưu lại vị trí scroll với các state data khác vào session storage trước khi chuyển và load lại khi vào tab



# Custom thẻ input
<datalist> + input list => bỏ, gõ có gợi ý nhưng xấu

-> Custom Input
- HTML thuần dùng event "input" giống onChange của react, thay event "change"
- Nếu muốn có 1 group input radio chỉ cho chọn 1 thì phải đặt chung trường name với nhau
- Vào web nên tự động focus vào input nếu cần điền, ấn tab nhảy sang ô input tiếp theo. Cũng có thể thêm shortcut cho input tiêu biểu. 
VD: document.addEventListener("keyup", function (e) { if (e.key === "/") document.getElementById("search").focus(); });
- Nên dùng attribute required input cho các trường buộc phải có. Dùng pattern khi input type text.
- HTML có sẵn form.reset() không cần tự viết.

- Dùng input radio nếu muốn chỉ chọn 1 thì phải đặt chung attribute name với nhau
- Dùng input password nên để 1 checkbox show password thay vì dùng con mắt mặc định vì nó éo chuẩn
- Dùng input text k có autocomplete, nhưng nếu thêm id/name="email/name/phone" sẽ có autocomplete tự động.
Custom vẫn dùng id nhưng bỏ autocomplete bằng cách thêm: autocomplete="off"
- Dùng input type="number" lợi là có min max value step.

- Custom style invalid input: https://www.youtube.com/watch?v=awNYtIAu6pI
Thay vì dùng: 
input:valid {} // style khi input có valid data
input:invalid {} // style khi input có invalid data
Ta dùng:
input:user-valid {} // style khi input có data, và data đó valid
input:user-invalid {} // style khi input có data, và data đó invalid
Hoặc better browser support: 
input:not(:placeholder-shown):valid {} 
input:not(:placeholder-shown):invalid {}
input:focus:invalid { } // style khi input có invalid data và ngừoi dùng đang nhập dở. Có thể custom để đang nhập dở chưa xong sẽ k style invalid
- Css selector for input
input:checked X input:not:(checked)  input:disabled X input:enabled  input:required X input:optional  input:read-only X input:read-write
input:out-of-range X input[type="number"]:in-range => custom cho input type number
input[type='file'][multiple]

- VD Sửa invalid text có sẵn của tag input. 
<input type="email" required oninvalid="this.setCustomValidity('Vui lòng nhập email hợp lệ!')" oninput="this.setCustomValidity('')">
VD custom form khi hợp lệ:
document.querySelector('form').addEventListener('submit', function(e) {
  if (this.checkValidity()) { <form hợp lệ> }
});
VD custom input khi gõ hợp lệ: 
document.querySelectorAll('input').forEach(input => {
  input.addEventListener('input', function() {
    this.setCustomValidity(''); // Bắt đầu gõ thì clear
    if (this.validity.valid && this.value.length > 0) {
      this.style.transform = 'scale(1.02)';
      setTimeout(() => {
        this.style.transform = 'scale(1)';
      }, 200);
    }
  });
});

-> Custom spin button cho input số:
- Dùng input type="number" và custom shadow DOM với input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button
Dùng thuộc tính -webkit-appearance và appearance là none để ẩn
- Dùng custom cho type="number" k an toàn vì -webkit => Best practice là dùng type text và lọc thủ công. 

-> Custom style input file và ảnh:
C1: Input file text 
<CustomButton2 variant="outlined" onClick={() => fileInputRef.current.click()}>
  Upload File
</CustomButton2>
<input type="file" ref={fileInputRef} style={{ display: 'none' }} onChange={getFile} />
const getFile = (event) => {
  const reader = new FileReader();
  reader.onload = (e) => { console.log(e.target.result); };
  reader.readAsText(event.target.files[0]); // Đọc text từ file
}
C2: Input image, hiển thị và gửi qua API
<input accept="image/*" hidden id="raised-button-file" type="file" onChange={onImageChange}/>
<label htmlFor="raised-button-file">
  <Box style={{ width: "299px", height: "300px" }}>
    <img
      width="100%"
      height="100%"
      style={{ borderRadius: "15px" }}
      src={image}
    />
  </Box>
</label>
const onImageChange = (event) => {
  if (event.target.files && event.target.files[0]) {
    setImage(URL.createObjectURL(event.target.files[0]));
  }
  setImageSending(event.target.files[0]);
};
const uploadData = new FormData();
uploadData.append("image", imageSending);
const response = await client.post("/api/v1/event", uploadData, config);

-> Custom select => chưa support rộng
Dùng selectedcontent sẽ hiện đủ trong option chứ mặc định chỉ hiện phần text k có style
<select>
  <button><selectedcontent></selectedcontent></button>
  <option>
    <img/>
    <div>XXX</div>
  </option>
</select>
select, ::picker(select) { appearance: base-select; } // hiện đủ tag trong option thay vì hiện mỗi text k có style
selectedcontent, option { /* Style cho từng item */ }
option::checkmark { display: none; } // mặc định có checkmark
option:checked { /* style cho option trong dropdown khi được check */ }



# Random trong css
random(min, max, step). VD: random(5rem, 50rem, by 5rem);
random(min, max)
random(--per-element, 4rem, 10rem) => gán vào biến tái sử dụng 1 số random từ 4-10 rem



# Dùng z-index
Thẻ A có z-index là 1, thẻ B có z-index là 2 thì thẻ A luôn nằm dưới thẻ B, kể cả thẻ A có children z-index là 100 thì tất cả đều dưới thẻ B thôi
Best practice để tất cả cùng z-index thì cái sau đè cái trước. Đến khi cần TH cái sau nhỏ hơn cái trước mới phải specific. 
z-index luôn đi kèm với position relative tránh lỗi. K dùng z-index với opacity vì opacity làm giảm z-index của thẻ trong nó.



# Dùng border-radius
URL: https://9elements.github.io/fancy-border-radius/
Shorthand border-radius: 10% 30% 50% 70%;
outer radius = inner radius + distance giữa 2 border (border-width) => Dùng khi cần 1 thẻ có boder radius trong thẻ khác
Dùng border-image: border-image-source border-image-slice border-image-width border-image-outset border-image-repeat



# Css shadow
Có text-shadow và box-shadow: https://html-css-js.com/css/generator/box-shadow
Có thể dùng multiple box-shadow lồng nhau trong 1 thẻ có thể gom tạo hình trừu tượng bao quanh: https://www.youtube.com/watch?v=20QiX8rmHnU
box-shadow tạo hình phức tạp với animation bằng cách dùng inset lồng đè ở các vị trí khác nhau: https://frontendmasters.com/blog/expanding-css-shadow-effects/ 
Có drop-shadow tự theo hình dạng và màu của ảnh có nền transparent, or kèm ảnh với clip-path



# Xử lý cách dòng text
white-space: nowrap; dùng được cho mọi loại tag => k nên dùng
text-overflow: ellipsis; overflow: hidden; cắt text tràn và hiện thị 3 chấm
letter-spacing là kc giữa các ký tự; word-spacing là kc giữa các word, nên dùng thay cho &nbsp;
text-ident để lùi đầu dòng paragraph
text-align: justify; 
box-decoration-break: clone; để style inline element khi break sang nhiều dòng thì ở đây là mỗi dòng 1 style riêng.
line-height là kc giữa các dòng trong 1 văn bản nhiều dòng, thay cho việc dùng paddingTop
vertical-align dùng nhanh để chỉnh vị trí lên hay xuống 1 tẹo mà k cần dùng flexbox => nên thử mọi options khi dùng

-> Dùng text-wrap: wrap/no-wrap; tương tự white-space
text-wrap: balance; khiến cho content chia vào nhiều dòng 1 cách cân bằng hơn giữa các dòng, khi text < 6 lines, thường dùng cho title lớn, dùng được mọi loại k chỉ text. VD: list có 10 items, nó sẽ chia mỗi 5 items 1 dòng khi có 2 dòng thay vì cứ giảm dần 9 1, 8 2, 7 3 khi co nhỏ màn lại.
text-wrap: pretty; sẽ đẹp hơn balance khi ít dòng và right gap lớn. pretty cũng tốt nếu cuối dòng có 1 icon và icon bị dài quá sang line2 nhìn rất chuối.
=> React có lib tương tự là https://react-wrap-balancer.vercel.app/

-> Xử lý cách dòng:
- Default text tràn khung sẽ tự xuống dòng, nhưng 1 từ dài quá 1 dòng sẽ k cắt.
- word-wrap: break-all; sẽ cut mọi chỗ => bỏ, thế bằng word-break
word-break y hệt word-wrap nhưng có thêm break-word là chuẩn nhất
- line-clamp: giúp hiển thị quá bnh dòng thì mới cut, react phải dùng là WebkitLineClamp / -webkit-line-clamp
- VD trong khung max 4 chữ:
1) abcde thì word-wrap break-word hiện là:
abcd
e
2) ab def thì word-break keep-all kbh cắt chữ:
ab
def
3) ab def thì word-break break-all hiện là:
ab de
f
4) ab defghi ac thì word-break: break-word là ok nhất, muốn nó vừa bảo toàn chữ khi tràn, vừa break word nếu word quá dài:
ab
defgh
i ac
=> Mức độ cut chữ: default < keep-all < break-word < break-all

-> Nhanh: 
text-wrap balance/pretty, word-break break-word
line-clamp + text-overflow + overflow hidden
line-height và vertical-align 
letter-spacing và word-spacing



# Dùng attr css
-> attr css giúp lấy giá trị thuộc tính html vào css. 
- attr mặc định lấy ra string và chỉ dùng được trong css content:
<button class="btn" data-label="Bấm vào đây">Click</button>
.btn::after {
  content: " (" attr(data-label) ")"; // Diễn giải là " (" "Bấm vào đây" ")" mà css nối string k cần dấu cộng sẽ thành " (Bấm vào đây)"
}
- Cast sang kiểu khác ngoài string để dùng với style khác, trừ image url k cast được: https://una.im/advanced-attr/
VD dùng với color: attr(data-color type(<color>), gray); có tham số 2 là default value
- Cách khác là thêm đơn vị vào sau sẽ tự cast mà k cần viết rõ type.
VD: width: attr(data-width px); or width: attr(data-width %);
- Có type(<custom-ident>) là 1 custom identifier có thể trỏ tới id 1 thẻ. Có thể dùng đặt tên cho view-transition-name.
VD: <div data-animation="pulse"> và animation: attr(data-animation type(<custom-ident>)) 1s linear; để convert string sang kiểu custom k còn "
- Check support: 
@supports (x: attr(x type(*))) {
  .warning {
    display: none;
  }
}

-> Cách dùng data chung giữa html css js
1) Dùng custom property:
<div style="--color: red"></div>
element.style.setProperty("--color", "red")
2) Dùng data-* tiện hơn: cũng dùng thay thế id vì dùng id lỡ cần duplicate component sẽ bị trùng id.
<div data-color-to-show="red"></div>
element.dataset.colorToShow = "red"
:after { content: attr(data-image-to-show); }

-> Tạo hover tooltip: 
- Dùng thuộc tính title có sẵn của các thẻ p, div
- Custom bằng css: Cho thẻ đó position relative bao thẻ x absolute có visibility là hidden, :hover thì set visibility của x là visible

-> Nhanh:
html có data-*
attr css lấy data từ html
html có title



# Dùng content-visibility
-> visible: là default paint cả page.
Khi vào 1 page, mặc định browser tải resource, tạo DOM và layout, paint cả page ra màn hình dù viewport chỉ hiển thị 1 phần. Nó khiến page lớn load hiện lần đầu tiên bị lâu, và lag khi resize.

-> hidden:
display none và html hidden attribute ẩn khỏi DOM và a11y tree.
content-visibility hidden ẩn khỏi DOM và UI, nhưng k ẩn a11y. Đặc biệt là nó giữ state giúp ẩn và hiện lại rất nhanh.
visibility hidden ẩn UI và a11y tree, k ẩn khỏi DOM. K thể tương tác, nhưng vẫn chiếm diện tích
opacity 0 dường như chỉ ẩn phần nhìn, vẫn tương tác đươc.

-> auto: thẻ sẽ k được paint lên màn hình cho đến khi xuất hiện gần viewport.
Để browser paint content, nó phải calculate layout trước. Thẻ có auto sẽ k tính layout khi chưa vào viewport nên phải đi kèm contain-intrinsic-size: auto 600px; để dùng kích thước tạm khi thẻ chưa được paint. Thường set contain-intrinsic-size width là auto tự scale full.
Khi scroll xuống và paint thẻ đó, kích thước thực tế sẽ bị thay vào gây jump scrollbar phải chấp nhận.
K nên dùng auto cho các thẻ quá lớn để tránh scroll nhanh paint thẻ đó k kịp gây khoảng trắng, nên chia chunk nhỏ tốt hơn.

-> Dùng contain: sẽ giảm tải cho browser khi tính toán layout hay paint ra màn hình. 
contain: none; => contain xác định 1 thẻ có containment không, default none là k có giới hạn gì.
contain: paint; => đảm bảo mọi thứ bên trong 1 thẻ k thể paint ra ngoài thẻ đó
contain: size; => đảm bảo mọi thứ bên trong 1 thẻ sẽ k ảnh hưởng đến kích thước thẻ đó. Vì bth kích thước thẻ cha tự kéo dài theo kích thước con, nhưng ở đây thì không.
contain: layout; => đảm bảo thẻ bên trong k ảnh hưởng đến layout các thẻ khác và ngược lại.
contain: layout paint size; => có thể kết hợp
contain: style; => css counter hay content open quotes trong css sẽ k ảnh hưởng ra ngoài or vào trong thẻ này
=> Thẻ có content-visibility auto sẽ tự có contain layout tức thẻ bên trong k thể break layout ra bên ngoài

-> Nhanh: 
content-visibility auto chỉ render khi gần viewport
contain paint đặt giới hạn k paint ra ngoài thẻ



# Dùng detail summary => k support rộng
VD: <details>
  <summary>Summary</summary>
  <p>Detail content</p>
</details>
details::details-content { // Style shadow dom cho content khi chưa hiện ra
  block-size: 0;
  overflow: hidden;
  transition: block-size 1s allow-discrete, content-visibility 1s allow-discrete; // cho animation
}
details[open]::details-content { // Style phần content khi hiện ra
  block-size: auto;
}
summary::marker { } // Style cho marker ấn để hiện details. Có thể để display none và dùng :before để tạo custom marker



# Dùng position
position absolute xếp vị trí so với thẻ cha relative đầu tiên của nó, nếu k có thì sẽ là thẻ body, thẻ absolute cũng thành inline block.
position absolute nếu set cả 4 giá trị sẽ ảnh hưởng đến kích thước của thẻ.
Có thể kết hợp position absolute + transform để animation dịch thẻ k chiếm kích thước.

position relative tương tự position static nhưng custom vị trí được với top bottom left right.

position sticky thì vật ở vị trí bth, nhưng khi scroll quá sẽ stick vào thẻ parent relative đầu tiên của nó, k thì sẽ theo màn hình, thẻ parent scroll hết thì k stick nữa

position fixed cố định thẻ mãi ở 1 vị trí. VD dùng cho menu.
Bản chất: thẻ A chứa thẻ B, mà B có position fixed sẽ căn fixed theo window nhưng nếu thêm translateZ(0) cho A thì B sẽ fix theo A chứ k fix theo window nx.

-> Float khiến 1 thẻ block thành inline-block và trôi sang 1 bên, k chiếm height. Các thẻ khác vẫn hiện cùng dòng và né nó ra => bỏ
Thẻ div chỉ có thẻ float bên trong thì height thẻ div đó là 0. 
ClearFix trong CSS giúp thẻ cha tính cả kích thước của thẻ con kể cả con dùng float: thêm clear both khiến nó chiếm height và các thẻ khác k thể ở cùng dòng với nó nữa.



# Tạo dialog
-> Dùng <dialog> có thể đóng mở bằng html
<dialog> là 1 loại popover và có thể dùng kèm API của popover để tạo click outside close với popovertarget popover popovertargetaction => k support rộng
Style animation với @starting-style + transition-behavior allow-discrete + ::backdrop => k support rộng
dialog trên mobile nên để bottom sheet hoặc full màn hình kèm nút bấm tắt sẽ đẹp hơn.

--> Dùng JS để support chuẩn mọi browser:
Dùng @keyframes css và JS event animationend cho animation từng step
Ấn ra ngoài ẩn dialog bằng cách bắt sự kiện click global rồi check target khác dialog để close dialog
React sẽ khó dùng JS kiểm soát animation, phải dùng portal mới chuẩn

Vấn đề mở dialog thì cản scroll, vị trí scroll ngoài phải giữ nguyên khi tắt dialog, content k bị di chuyển sang trái khi mở, hoạt động trên cả mobile.
- Dùng <dialog> vốn tự cản scroll rồi
- Cản dịch chuyển sang trái: 
VD set padding-right bằng kích thước scrollbar default là 15px, nên set thêm width trong ::-webkit-scrollbar đảm bảo cũng bằng 15px => safari có thể k ổn
html:has(dialog[open]){
  overflow: hidden;
  padding-right: 15px;
}
VD cách khác chạy mượt cả safari:
html:has(dialog[open]){
  position: fixed;
}
- Để giữ vị trí scrollbar, làm như VD trên nhưng thêm 1 biến css lưu vị trí scroll bằng event "scroll", khi đóng dialog thì JS jump tới là được.

-> Hiển thị scrollbar: nên cho background transparent chỉ hiện mỗi thumb
Nếu muốn scrollbar luôn hiện thì để "overflow: scroll;" => ok
Nếu muốn scrollbar luôn chiếm kích thước kể cả khi k hiện "scrollbar-gutter: stable". Điều đb là nó bằng đúng kích thước width set của ::-webkit-scrollbar => bỏ, vì khi kết hợp position fixed dialog khiến scrollbar-gutter k chiếm nx và dịch chuyển
Đẹp nhất là khi k overflow thì k hiện scrollbar nhưng scrollbar vẫn chiếm kích thước kể cả position fixed dialog => cách duy nhất là tự tạo thẻ custom scrollbar, kqtr

-> Nhanh:
Tạo dialog bằng JS animationend, bắt sự kiện click global cho click outside close
dùng position fixed cản dịch chuyển content, event scroll lưu vị trí scrollbar
overflow scroll để scrollbar luôn chiếm kích thước



# Dùng css anchor
Ful tut: https://css-tricks.com/css-anchor-positioning-guide/

Thường dùng cho html popover để custom vị trí với css thuần
Phải có inset: unset; để tránh bị lỗi full màn.
Dùng kèm position-try-fallbacks: flip-inline, flip-block; để tự động đổi position nếu màn k đủ diện tích

Mặc định anchor gắn vào thẻ trigger nó, có thể dùng anchor-name để custom gắn vao thẻ nào
VD: #btn { anchor-name: --btn2; }
[popover] {
  position-anchor: --btn2;
  bottom: anchor(top);
  left: anchor(center);
  /* Hoặc position-area: top right; */
}



# Custom cursor
C1: cho cursor none rồi tự custom 1 thẻ ảnh khác transform theo mousemove. Có thể custom event mouse down thì phóng to thẻ, mouse up thì thẻ về bth
=> k nên dùng vì text, input, button đôi khi cần các hình khác nhau thì custom sẽ phức tạp với từng thẻ
C2: là dùng cursor: url(<base64>) 8 8, auto; // Tham số 2 là dự phòng nếu browser k hỗ trợ hình ảnh  
Có thể tự set cursor như nào ở các thẻ khác nhau, k custom gì khác được, chỉ thay đổi được cách hiển thị. 
URL: https://css-tricks.com/next-level-css-styling-for-cursors/ => có check chỉ show khi không là touch screen
URL: https://custom-cursor.com/ => lấy ảnh cursor free, copy style nó làm code mẫu luôn



# Dùng scroll
-> Tạo scrollbar cho 1 box bằng cách cho container kích thước nhỏ hơn content và overflow auto là có scrollbar
VD box inline-block, white-space nowrap, overflow-x auto, set width k fit-content mà responsive màn hình, content set minWidth bằng kích thước của box
- overflow: clip; kết hợp overflow-clip-margin: 30px; để overflow tràn ra ngoài 1 lượng tối đa là bao nhiêu, còn lại sẽ hidden
- overscroll-behavior: khi 2 scroll lồng nhau, auto thì cục bên trong scroll tới đích mà vẫn lăn tiếp chuột ở cục trong thì cục ngoài sẽ scroll (scroll chaining), contain để cản. Trên điện thoại tự có bounce effect, none để cản thêm bounce effect.

-> Nhảy đến 1 vị trí trên trang html: đặt id cho thẻ và dùng tag a href đến #đó là được
scroll-behavior: smooth hay auto để trượt đến hay nhảy đến

-> Custom style scrollbar
URL: https://css-tricks.com/custom-scrollbars-in-webkit/
URL: https://www.w3schools.com/howto/howto_css_custom_scrollbar.asp
Có thể ẩn thanh scrollbar nhưng vẫn giữ nguyên chức năng
K thể tạo được scrollbar có background transparent, có thể ép bằng cách cho background cùng màu thẻ body.

-> Dùng scroll-snap
- scroll-snap-type: x mandatory; xác định hướng và kiểu scroll. proximity là scroll tới sát mép card mới tự scroll vào đúng vị trí card nếu k sẽ lơ lửng, mandatory là trình duyệt tự snap theo từng điểm scroll mọi lúc theo cách ta dùng scroll-snap-align 
- scroll-snap-align: từng item sẽ có vị trí như nào với container bao nó. VD center là điểm giữa item trùng điểm giữa container, tương tự start và end.
- Đôi khi ta k muốn item hiển thị ở đúng ở 3 vị trí start center end, mà hiển thị ở giữa cách bên trái 1 vài pixel thì:
scroll-padding dùng ở container sẽ cho mọi item bên trong được quyền hiển thị cách mép 1 khoảng bnh
scroll-margin dùng ở từng item sẽ cho phép cụ thể 1 item nào được phép hiển thị cách mép bnh
Thường thì nên để kích thước container chia hết cho kích thước card bên trong
- scroll-snap-stop: khi lướt quá nhanh sẽ luôn dừng ở từng element (always) hay cho lướt qua (normal)

-> Usecase tạo carousel css only: https://css-tricks.com/css-carousels/ => chưa support rộng
Dùng grid hiện list card và ::-webkit-scrollbar display none để ẩn scrollbar mặc định
scroll-snap-type: x mandatory; thẻ cha và scroll-snap-align: center; thẻ con để ấn là dịch từng card ở đúng vị trí giữa
::scroll-button(left) và ::scroll-button(right) hoặc ::scroll-button(*) để custom 2 button cho scroll
Dùng anchor-name cho thẻ cha để custom vị trí scroll button trong thẻ cha với anchor position
Dùng ::scroll-marker-group cho các button dịch chuyển tức thời. scroll-marker-group: after; chỉ định vị trí nó ở dưới carousel
::scroll-marker thẻ con để custom từng button nhỏ. 
::scroll-marker:target-current khi đang hiện, ::scroll-marker:hover, ::scroll-marker:focus-visible, ::scroll-marker:disabled khi scroll đến cuối bị disable

-> Nhanh:
overflow-clip-margin để giới hạn khoảng overflow, còn lại sẽ hidden
overscroll-behavior: contain để cản scroll chaining
scroll-behavior: smooth
Custom style ::-webkit-scrollbar
Dùng scroll-snap-type kiểm soát vị trí item so với container
Css new feature carousel css only



# Xử lý màu
https://www.w3schools.com/cssref/css_colors.php => màu chuẩn đồng nhất browser, giúp tránh lệch màu trong browser khác nhau.
K nên giả định 2 màu là giống nhau giữa 1 thẻ so với 1 bức ảnh hay video, vì màu thẻ sẽ khác khi sang browser khác

-> Gradient color: https://angrytools.com/gradient/
Linear từ 1 phía sang 1 phía, radial kéo từ tâm ra xung quanh, conic-gradient như cái compa
- background: linear-gradient(direction, color1, color2, color3, color4,..);
VD: linear-gradient(in oklch, red, blue); => gradient ưu tiên dùng oklch sẽ đẹp hơn
- background: radial-gradient(circle closest-corner at 100px 100px, red 10%, yellow 20%, pink 10%); 
shape là circle / elipse (default) bóp méo theo khung ngoài
size có thể là closest-side, farthest-side (default), closest-corner, farthest-corner at ... để set kích thước, màu cuối của gradient chạm cạnh nào của box bao nó thì dừng
- background: repeating-linear-gradient

-> Các cách lấy màu: rgba(255,0,0,0.5); rgb(255,0,0); hsl(0, 100%, 50%), hsla(0,100%,10%,0.3); #ffffff; red, yellow
Nên dùng oklch(0.8 0.1 100) tạo màu như lch(lightness, chroma như saturation, hue) nhưng cân bằng hơn. Dùng tạo color palette được.

- mix-blend-mode: difference; => giúp đổi màu tương phản color white realtime
- backdrop-filter: blur(5px); => style area đằng sau element, dùng tạo glass morphism

--> Tạo màu random:
Random hoàn toàn: x.style.color = `rgb(${Math.round(Math.random()*255)} ${Math.round(Math.random()*255)} ${Math.round(Math.random()*255)})`;
Random tông sáng: x.style.backgroundColor = `hsl(${Math.round(Math.random()*359)}deg 100% 80%)`;
Dùng oklch tốt hơn: x.style.backgroundColor = `oklch(0.8 0.1 ${Math.round(Math.random()*359)})`

-> Dùng relative color
hsl(from #ff0000 / 0.5); => giảm opacity đi 0.5
hsl(from red h s calc(l - 20) / 0.5); => lấy màu đỏ và giảm light đi 20, alpha là 50%
hsl(from var(--clr-primary) h s 20%); => lấy màu từ biến và gữi h s, light set là 20%
rgb(from #ffff r g g / 0.5); => tương tự nhưng lấy màu green làm màu blue, alpha 50%
oklch(from red calc(l * .5) calc(c * .1) h / 0.5); => nên dùng

-> Dùng color-mix
VD: color-mix(in srgb, red 30%, blue);
VD: color-mix(in lab, currentColor, red 70%); => pha 70% đỏ
VD: color-mix(in lab, black, currentColor); => currentColor sẽ lấy thuộc tính color của thẻ hiện tại và ở case này làm tối màu đó đi, nếu thẻ k set color sẽ lấy của cha.
Usecase ở light background cần chữ màu tối hơn, dark background cần chữ màu sáng hơn.
=> currentColor dùng được mọi nơi, kể cả trong linear-gradient cũng dùng được , dùng được mọi nơi cho màu

--> Color hue interpolation: dùng được ở mọi hàm về màu
VD: linear-gradient(to right in lch shorter hue, lch(70% 80 30) 0%, lch(70% 80 330) 100%); => không gian màu lch dùng shorter route để đến màu đích, là mặc định
VD: in lch decreasing hue => theo hướng giảm dần các thông số đến giá trị đích, giảm về 0 sẽ quay lại 255

-> Color shifting animation:
- Đơn giản dùng hsl(xdeg 100% 80%) thì đổi sang màu khác bằng cách cộng thêm 180deg. 
Cách này chỉ rotate max 180deg, màu ở vị trí xdeg và x+360deg là 1. Cơ chế nó đổi sang rgb và tịnh tiến r g b về giá trị đích. Nếu rotate quá 180deg, nó vẫn convert sang rgb và chọn được ngắn nhất để tịnh tiến các giá trị r g b, dẫn đến chỉ max 180deg.
Làm vậy sẽ bị grey out do chỉnh các số r g b sẽ tới lúc r g b xấp xỉ nhau gây ra màu xám.
- Dùng @property của css houdini cho deg là 1 property sẽ rotate quá 180deg ok.
- Best practice là dùng filter:hue-rotate() sẽ tự rotate màu của thẻ hiện tại, thoải mái bao nhiêu deg cũng được, k còn bị grey out.
Các cách trước render lại ở từng frame, còn cách này sẽ tận dụng màu có sẵn và tilt sang màu đích nên có performance tốt hơn đổi màu trực tiếp.
VD: @keyframes hueRotate { to { filter: hue-rotate(720deg); } } .particle { animation: hueRotate 1000ms; }

-> Usecase dùng conic-gradient tạo hình zigzag 
.loader {
  height: 47px; /* control the size */
  aspect-ratio: 5;
  background:
    conic-gradient(from 135deg at top,#000 90deg,#0000 0) top,
    conic-gradient(from 135deg at top,#0000 90deg,#000 0) bottom;
  background-size: 20% 50%;
  background-repeat: repeat-x;
}

-> Nhanh: 
Gradient color
Relative color
color-mix
Color shifting animation



# Dark mode 
Best practice là vào web lần đầu sẽ theo setting của browser. Khi ấn đổi mode sẽ lưu setting mới vào localStorage đè setting browser.

-> Các cách tạo darkmode:
- Luôn dùng JS: Check darkmode setting browser với window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; rồi dùng setting đó nếu localStorage k có
- Mặc định Canvas là màu của background, CanvasText là màu của text, sẽ tự đổi tuỳ vào mode hiện tại => Bỏ k dùng
VD để thêm sáng tối cho màu có thể dùng color-mix(in oklab, Canvas 75%, RebeccaPurple);
- style trong @media (prefers-color-scheme: dark) { } được áp dụng khi settings của browser là dark hoặc color-scheme trên là dark => Bỏ k dùng vì nếu browser set dark thật thì style bên trong k thể mất, éo đổi sang light được.
- Css có sẵn. VD html { color-scheme: light dark; } tương đương với <meta name="color-scheme" content="light dark"> => Bỏ k dùng
Nó gợi ý trình duyệt là web hỗ trợ những mode nào. Nếu dùng "light dark" thì browser tự dùng theo seting. Nếu chỉ rõ color-scheme light hay dark sẽ dùng đúng mode đó.
Các chỗ dùng màu thì light-dark(màu light, màu dark); sẽ trả về màu tương ứng tuỳ vào trường color-scheme
- Dùng css only chuẩn với if @function style query => k support rộng
:root {
  --root-scheme: light;
  --scheme: light;
  @media (prefers-color-scheme: dark) {
    --root-scheme: dark;
    --scheme: dark;
  }
}	
@scope ([data-scheme]) {
  :scope {
    --scheme-from-attr: attr(data-scheme type());
    --scheme: if(
      style(--scheme-from-attr: system): var(--root-scheme);
      else: var(--scheme-from-attr)
    );
    color-scheme: var(--scheme); /* Dùng được light-dark() */
  }
}
@function --light-dark(--light, --dark) {
  result: if(
    style(--scheme: dark): var(--dark);
    else: var(--light)
  );
}
[data-scheme] {
  color: light-dark(#333, #e4e4e4);
  background-color: light-dark(aliceblue, #333);
  border: 4px --light-dark(dashed, dotted) currentcolor;
  font-weight: --light-dark(500, 300);
  font-size: --light-dark(16px, 18px);
}
<body data-scheme="light"></body>
=> Lần đầu vào thì data-scheme để system lấy system. Nếu đổi theme set vào local storage thì set tiếp vào data-scheme để dùng theme tương ứng. Dùng cả hàm light-dark và custom để dùng cho mọi style khác chứ k chỉ màu



# View transition API
HTML thuần thì animation khi update DOM bị phức tạp, navigate SSR thì bị jump. Dùng view transition api sẽ tối ưu performance và chuẩn hơn.

URL chuẩn tạo moving hightlight: https://www.smashingmagazine.com/2025/06/creating-moving-highlight-navigation-bar-javascript-css/ => luôn dùng
Full docs chuyển page: https://developer.chrome.com/docs/web-platform/view-transitions/
Giải thích: https://www.youtube.com/watch?v=xZteiW-cun8
Custom cho slideslidein fadeslideout: https://www.youtube.com/watch?v=aTGwrErX9AM 
Tạo morphing button: https://www.youtube.com/watch?v=N2BKAKwGP6M 

-> Set cùng 1 view-transition-name cho thẻ trước và sau animation để browser tự animate thẻ nào biến đổi dần thành thẻ nào
Customize animation với ::view-transition-old(<name>) là style thẻ trước animation, và ::view-transition-new(<name>) là style thẻ sau animation.
Animation mặc định là fade or dịch chuyển, có thể customize.
Đổi DOM thì wrap trong startViewTransition. SSR cross docs animation thì dùng @view-transition { navigation: auto; }
Custom animation time với ::view-transition-group(root) { animation-duration: 0.5s; }

Code hack html thuần nếu k chạy: đặt trong head <script src="ignored" type="module" blocking="render"></script> 
VD dòng text ở trang này bé, ở trang sau vẫn là dòng text đó nhưng to hơn, thì ta gán view-transition-name cho 2 tag ở 2 page cùng 1 giá trị là ok
Chú ý nếu dùng page1 span -> page2 h1 thì sẽ phóng to, nhưng cả 2 page cùng tag thì lại k.

-> URL phức tạp custom animation toàn page, định hướng tiến lùi: https://view-transitions.chrome.dev/stack-navigator/mpa-prerender/ 
pageswap khi page hiện tại bị thể bởi trang khác sự kiện phát ra ở trang cũ trước khi chuyển.
pageshow khi load pages lần đầu tiên, hoặc navigate tới
pagereveal khi nội dung thực sự được render, bất kể nội dung từ cache, prerender hay refresh mới.



# Dùng flexbox
flex: 2 2 10%; // grow shrink basis
flex: 2 2; // grow shrink
flex: 2; // = 2 1 0% vì default là flex grow 0, flex shrink 1, flex-basis 0% 
order: 3; // ép 1 thẻ nằm ở vị trí số 3 trong flexbox
flex-flow: row wrap; // flex-direction flex-wrap

place-self: start end; /* align-self: start; justify-self: end; */ => place-items dùng cho container bao ngoài, place self là dùng cho từng phần tử được trong grid
place-items: center stretch; /* align-items: center; justify-items: stretch; */ => stretch sẽ giãn trong phạm vi ô to, 
place-content: center space-between; /* align-content: center; justify-content: space-between; */
Dùng align-self để chỉnh con ở start hay end so với cha là flexbox. VD cha cho align-item center để mọi con ra giữa, muốn 1 vài con ở 2 bên vẫn dùng align-self chỉnh được.

-> Bản chất flex:
Flexbox chỉnh size của cell lệch dựa vào kích thước item bên trong, shrink hay grow cũng k ép về bằng nhau được. Grid chỉnh cell size dựa vào kích thước set cho container bao ngoài => Nếu cần chia chuẩn cột cho các hàng, nên dùng grid, còn chỉ cần xuống dòng bth thì dùng flex responsive. Flex cũng k xử lý được case row cuối k full.

Bản chất các bước tính flex-basis là thẻ cố đạt kích thước xác định, nếu k đủ 1 dòng sẽ xuống dòng theo flex-wrap, r tính grow shrink. Nếu có space thừa sẽ grow theo flex-grow, nếu container nhỏ hơn sẽ shrink theo flex-shrink. flex-basis là NN xuống dòng, kp flex-grow hay flex-shrink.
Nếu vừa có flex-basis, vừa có flex-grow, nó chỉ cố grow đến khi đạt được kích thước flex-basis thôi chứ kp cứ set 999 là chiếm cả. Chú ý là nếu set flex-basis 100% tất cả các cột, k có shrink hay grow thì các cột sẽ luôn bằng nhau y như grid.
Set flex-basis cho item là 0 thì item mang kích thước nhỏ nhất fit content, set auto or 100% thì chia đều nhau trong 1 hàng, set quá container thì item max trong giới hạn container. VD flex-basis là 0 và flex-grow 999, nó sẽ ưu tiên grow thẻ đó đạt được kích thước fit-content.
VD: container 100px, item1 50px, item2 30px. Nếu flexbasis item1 là 1000px thì chỉ tới 70px thôi, nếu set là 10px thì nó mang width là 50px để hiển thị đủ item
URL: https://www.youtube.com/watch?v=Ns12ALe8aqI => 2 flexbox có content bên trong khác nhau sẽ có tốc độ shrink content khác nhau. 
Nếu muốn hoạt động giống grid, dùng flex-basis khiến các thẻ content cố đạt được 1 mốc width cố định sẽ giống nhau, còn khi shrink nhỏ hơn mốc đó thì chưa chắc.

-> Display nhận 2 params thì 1 là style container ngoài, 2 là style con bên trong:
flex => = block flex, container là block
inline-flex => container là inline 
inline-grid => container là inline, bên trong là grid
block => = block flow
inline-block => = inline flow-root

Param 2 là flow-root tạo block formatting content k bị margin collapse, còn lại như default flow: https://www.youtube.com/watch?v=JY0FN71vCbw
Còn có display list-item khi muốn 1 thẻ hoạt động như 1 item trong list ul li dù k có => k dùng
Còn có display contents khiến 1 thẻ biến mất khỏi DOM nhưng ta vẫn css selector từ nó để style cho thẻ con được
Còn có display table khi hoạt động như table, 1 thẻ dùng display table-column sẽ k hiện nếu thẻ này k nằm trong 1 table => k dùng

-> Dùng min-width: fit-content; cho thẻ con để fix case muốn thẻ con ưu tiên xuống dòng mới thay vì wrap content ở màn hình nhỏ, chỉ wrap khi k thể xuống dòng mới được.



# Dùng grid
https://uxdesign.cc/css-grid-with-galaxy-layout-figma-886a935b9649 => tạo CSS grid galaxy layout
https://css-tricks.com/snippets/css/complete-guide-grid/?fbclid=IwAR0hXkP7RHqFTVbuRnF-Vau0VqkVig1dQn6gpfa80ig3bMo7mPzW0m6DdpM => full tut master
https://flexboxlabs.netlify.app/grid => grid playground
https://ryanmulligan.dev/blog/layout-breakouts/ => grid làm container

grid/grid-gap: 1rem 3rem; => vertical 1rem, horizontal 3rem. Cũng có column-gap, row-gap
grid-column / grid-row => 1 phần tử chiếm bnh cột và hàng. Vd: grid-row: 1 / span 2; là item này bắt đầu từ row1 và kéo dài 2 row
grid-area: 2 / 1 / span 2 / span 3; => là short của grid-column và grid-row, thẻ ở row 2 column 1 kéo dài 2 rows 3 column. 
grid-area: 1 / 2 / 3 / 4; => tương đương với grid-row-start: 1; grid-column-start: 2; grid-row-end: 3; grid-column-end: 4; là kéo dài từ row1->row2, col2->col3

-> grid-auto-flow: row dense; => ưu tiên xếp row trước, và ưu tiên fill vào các chỗ trống trước đó nếu đủ, điều này làm mất thứ tự
Có thể dùng tạo masonry grid

-> grid-template-rows: 300px 100px; => row1 cao 300px, row2 cao 100px, các row sau kích thước mặc định k fix
grid-auto-rows => set kích thước chiều cao mặc định cho row mới được thêm vào, nếu ta k set bằng grid-template-rows cho nó thì sẽ lấy cái này

grid-template-columns: 10% 10% 10%; hoặc repeat(3, 10%) => chia 3 thẻ bên trong làm 3 cột, một cột chiếm 10%. 
grid-template-column: 1fr 14rem; thì cột 2 chiếm 14rem, cột 1 chiếm phần content còn lại => dùng fr thay % vì fr fill content còn lại, % có thể bị tràn nếu có gap chẳng hạn.
grid-template-columns: repeat(3, minmax(200px, 1fr)); => có thể tự động responsive min item width 200px.
Có thể tạo container với line names tự định nghĩa. Browser Elements -> Layout -> show line names để thấy grid line names

-> grid-template-areas => định nghĩa vị trí area cho các label để xếp item vào. Kết hợp grid-area định nghĩa các label cho từng thẻ, có thể responsive đổi vị trí area.
grid-template-areas cũng có thể thay thế position absolute vì nó chồng các element lên nhau và lấy kích thước của thẻ to nhất.

Usecase ấn button thì text trong button thay đổi: ta cho các đoạn text là thẻ riêng với cùng grid-area đè nhau, cái nào ẩn thì hide nó đi
K dùng display none vì nó làm mất thẻ thì grid-area k tự lấy kích thước thẻ to nhất, k dùng opacity 0 vì nó gộp aria text các thẻ lại => dùng visibility hidden ok nhất vì vẫn chiếm k gian và có ẩn aria-text, dùng cho transition được

-> Căn giữa phần tử ở hàng cuối:
Dùng flexbox hàng cuối bị full width. Nếu set max-width chứ k full width thì khi màn hình nhỏ chỉ còn 1 column muốn full lại k được nx => flexbox thường chỉ cho 1D layout
Dùng grid ưu tiên cho 2D layout, hàng cuối căn giữa phải css selector chọn từng item cho ra giữa kèm với @media. Tạo galaxy layout, kim tự tháp card bằng cách tương tự.
VD: &:nth-child(-n+2) { /* Chọn 2 item đầu tiên trong grid */}
VD: &:nth-child(n+3)&:nth-child(-n+4) { /* Chọn item thứ 3 và thứ 4 trong grid, vì phải thoả mãn giao 2 selector */ }
VD: &:nth-child(3n)&:nth-last-child(-n+4) ~ * { } => trong grid có 3 cols thì sẽ chọn hàng cuối, vì nó chọn phần tử cuối cùn của hàng sát cuối phải chia hết cho 3 và nằm trong 4 phần tử đầu tiên, rồi chọn các thẻ sibling sau nó chính là hàng cuối.
URL: https://codepen.io/t_afif/pen/QwbZKPB => chọn row cực mạnh mà k cần media query

-> Master trick responsive:
- Grid responsive với grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); ô có thể dãn > 200px nhưng nhỏ hơn 200px sẽ ưu tiên xuống dòng.
minmax nếu max < min thì lấy min, thay thế min-width, max-width.
1fr chỉ là đơn vị fraction chia tỉ lệ các items, nó k định nghĩa theo kích thước bất cứ container nào cả. Mặc định là max 100%. Nếu cố điền 1fr trong 1 đơn vị yêu cầu kích thước cụ thể sẽ invalid property.
repeat(số/auto-fill/auto-fit, số); Tức là auto-fit và auto-fill là giá trị của repeat chứ klq gì grid. Mục số là điền số chứ đừng điền 1fr
auto-fit thì grid cố "điền đầy" không gian bằng cách dãn phần tử, nên dùng auto-fill hơn vì nó cố điền nhiều cột nhất có thể, khi chỉ có 1 hàng sẽ thấy rõ.
display grid mà các item k set grid-column hay grid-row sẽ mặc định 1 item là 1 ô, k set kích thước thì 1 ô chiếm cả row, tức chỉ có 1 cột
Grid mặc định dòng dưới cột phải có width y như dòng trên. Còn muốn height các cột bằng nhau thì set grid-template-rows 1fr hết

- Tạo số dương cực lớn hay âm cực lớn ở 1 mốc: Lấy 100% - absolute unit và so sánh với mốc mong muốn rồi *999, kết hợp minmax
VD lớn hơn 200px thì lấy dương vô cực, nhỏ hơn thì lấy 200px: max(calc((100% - 200px)*999),200px)
VD chỉ bo góc ở màn hình lớn: .card { 
  border-radius: max(0px, min(8px, calc((100vw - 4px - 100%)*9999))); 
} => 100vw là kích thước screen, 100% là kích thước container. Nếu kích thước container gần bằng với kích thước screen sẽ thành max(0px,min(8px,âm vô cực)) = 0px. Nếu kích thước container không bằng với màn hình (vì màn hình lớn ta cho container nhỏ ra giữa thôi) thì thành max(0px,min(8px,dương vô cực)) = 8px
Tức if(!mobile) borderRadius=0px else borderRadius=8px
=>*** Cứ tưởng tượng màn hình lớn và màn hình nhỏ thì min max width là gì là chơi dược thôi. Điều đb là dùng calc kết hợp kích thước absolute và relative

- Custom max bao nhiêu cột: dựa vào tính chất flex-basis xếp k đủ thì tự giảm cột xuống dòng, rồi mới xét shrink grow.
VD set item là min-width: 100% / 4 + 0.1%; => 1 row max 3 cột

-> Usecase flexbox có 2 tag con, tag con sẽ tự hiện lên nếu mang kích thước đủ: https://www.youtube.com/watch?v=LEkFckg7sfw
VD: .with-sidebar {
  --main-min-width: 45ch;
  --sidebar-size: 250px;
  --gap: 2rem;
  display: flex;
  gap: var(--gap);
  flex-wrap: wrap;
}
.with-sidebar > * {
  flex-grow: 1;
}
.with-sidebar > :last-child {
  flex-basis: var(--sidebar-size);
}
.with-sidebar > :first-child {
  flex-grow: 999;
  flex-basis: calc(((var(--main-min-width) - (100% - var(--sidebar-size) - var(--gap))) * 9999));
  // container lớn sẽ là âm vô cực tức flex grow 999 sẽ cố gắng kéo dài để đạt được kích thước fit-content, sidebar bên phải sẽ hiện
  // container nhỏ là dương vô cực, flex-grow 999 sẽ hiện content cố full màn, sidebar sẽ k hiện
} 

-> Usecase grid nhảy cột từ 1 tới 4 luôn khi màn hình to ra 
.columns {
  --min-column-size: 200px;
  --column-count: 4;
  --gap: 2rem;
  --breakpoint: calc(var(--min-column-size) * var(--column-count) + (var(--gap) * (var(--column-count) - 1)));
  --column-size: calc((100% / var(--column-count)) - var(--gap));
  display: grid;
  gap: var(--gap);
  grid-template-columns: repeat(auto-fit, 
    minmax(
      min(max(var(--column-size), (100% - var(--breakpoint)) * -999 ), 100%), // Màn > 4 thẻ thì min width từng thẻ là màn / 4, màn < 4 thẻ thì min width từng thẻ là full
      1fr
    )
  );
}
=> hoàn toàn master, tham số 1 của minmax là min width của 1 item, thì ta cho số này responsive theo màn hình và các size kia thôi.

-> Usecase dùng grid + container query tạo responsive layout:
VD 1 grid hiện nhiều cards, style card thay đổi khi số thẻ trong 1 row thay đổi:
.grid-auto-fit {
  display: grid;
  gap: 1rem;
  grid-template-columns: repeat(auto-fit, minmax(min(30ch, 100%), 1fr));
  container: grid-auto-fit / inline-size;
}
.card:has(> img) {
  // Giả sử mỗi card dài 30ch. Khi tăng lên 2 card 1 hàng, thẻ chứa ảnh chiếm cả 1 hàng
  @container grid-auto-fit (inline-size > calc(30ch * 2 + 1rem)) { // K dùng được css var
    grid-column: span 2;
    display: grid;
    grid-template-columns: subgrid;
    gap: 0;
    > img {
      grid-column: 2;
      grid-row: 1 / 4;
    }
  }
  // Khi 4 card 1 hàng, thẻ chứa ảnh chiếm 2 hàng 2 cột
  @container grid-auto-fit (inline-size > calc(30ch * 4 + 3rem)) {
    grid-column: span 2;
    grid-row: span 2;
    > :not(img) {
      grid-column: 1 / -1; => dùng 1 / -1 để chiếm cả từ đầu đến cuối thay vì 1 số span cụ thể
    }
    > img {
      grid-column: 1 / -1;
      grid-row: 1;
    }
  }
}

-> Nhanh: 
Các thuộc tính grid cơ bản
Cách tạo galaxy layout, masonry grid, căn giữa phần tử cuối
Master trick responsive



# CSS responsive
Responsive cần chú ý cả case xoay ngang phone khiến height rất nhỏ và width gấp 3 lần height.
Kích thước luôn set relative để khi screen co lại thì item cũng tự nhỏ lại, chỉ cần thêm min max để giới hạn thôi.

-> Dùng @media: @media not|only mediatype and (mediafeature and|or|not mediafeature) { }
mediatype: all / print / screen
media feature: min-height, resolution, orientation (portrait/landscape)
=> Viết @media query tối ưu: VD màn lớn thì 2 col, màn nhỏ thì 1 col, mà mặc định grid là 1 col thì ta nên để mặc định 1 col, @media min-width thì set 2 cols. Chứ mặc định set 2cols, sau màn nhỏ lại phải set style 2 lần => thường thì media query toàn dùng min-width

VD: @media (min-width: 100px) { } => tương đương @media all and (min-width: 100px) {}
VD: @media (min-device-width: 100px) { } => kích thước tính cả thanh công cụ và thanh cuộn => k dùng
VD: @media only screen and (max-width: 480px) and (min-width: 320px) { } => kích thước từ 320->480 của màn hình máy tính or smartphone
VD: @media only print { } => chỉ cho máy in
VD: @media (100px <= width <= 300px) { } => luôn dùng
VD: @media only screen and (max-width: 100px) and (orientation: landscape), screen and (min-width: 100px) { } => thiết bị chỉ có màn hình width nhỏ hơn 100px và chiều rộng lớn hơn chiều cao, tức k bao gồm thiết bị đọc màn hình hay in ấn, đồng thời áp dụng cho mọi thiết bị hiển thị bao gồm cả in ấn nếu width lớn hơn 100px
Còn có color-index là thiết bị màn hình dạng indexed color, hay min-aspect-ratio, min-device-aspect-ratio, min-device-pixel-ratio => k dùng
Có thể responsive từ thẻ link, kiểu chia mỗi màn 1 file css. VD <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"> => k dùng

@media (prefers-color-scheme: dark) { } => setting dark mode cho browser
@media (prefers-reduced-motion) { } => setting giảm animation được bật. Có thể bật chế đ

-> Dùng @container: xử lý case screen nhỏ dần mà kích thước container lại tăng. 
URL tut: https://www.youtube.com/watch?v=rrLAg7xNERA
@container tự tìm container bao ngoài là parent đầu tiên, dùng container-name nếu muốn rõ ràng hơn.
container-type: size là lấy theo 2 chiều, inline-size là lấy theo 1 chiều ngang thôi. Kích thước container defines kích thước của content theo chiều đó.
container: main / inline-size; => shorthands container-name / container-type
Dùng đơn vị 50cqw để set kích thước theo width của container, nếu k có container sẽ dùng như vw
=> Nhanh: Dùng container-name chỉ cần set cho phần tử cha, tự dùng container gần nhất bao nó, 50cqw.



# 3D 2D transform
transform-origin: top left;
translate: 50% -40%;
rotate: -45deg;
scale: 1.7 50%;
transform: skew(15deg, 15deg);
=> (Shorthand) transform: perspective(500px) translate(100px, 50px) scale(1.5, 1.5) rotate(45deg) skew(10deg, 15deg);

translate dùng đơn vị relative sẽ tính tương đối theo kích thước của chính nó chứ kp kích thước thẻ cha. Thẻ vẫn chiếm kích thước vị trí cũ dù di chuyển đè thẻ khác.
translate tương tự như position relative và chỉnh vị trí với top right left bottom, nhưng translate có graphical performance tốt hơn.

-> Bản chất transform 3D: https://www.youtube.com/watch?v=niwUUtgn4-o
Sample căn phòng 3d: https://codepen.io/ricardoolivaalonso/pen/mdPzrpe
- Perspective chỉnh kc từ mắt đến vật. Mặc định nó nhìn từ rất xa, VD hình vuông nghiêng nhìn từ kc xa sẽ thành hcn chứ k thấy độ lệch, như flat plane.
Perspective càng nhỏ không khiến vật lớn hơn vật ở gần mắt hơn khiến cho s3D space rõ ràng hơn, sự thay đổi trên trục z rõ hơn.
Nếu perspective 1000px và 1 mp translateZ 500 sẽ nhìn tương tự perspective 100 và mp cách mắt 50, vì qtr là ratio như nhau. Nhưng nếu perspective là kc từ mp đến mắt nhỏ khi rotate sẽ bị nhìn gần quá, ảnh bị phóng to méo nên xấu, nên thường thấy perspective lớn.
Luôn dùng perspective responsive theo vw giúp co nhỏ khi thu nhỏ màn hình mobile ok.
- transform-style: A chứa B thì xoay A, B cũng xoay theo. transform-style: flat; mặc định khiến cho vị trí đó trở thành kích thước và vị trí mới của thẻ B luôn, nếu xoay B -60 độ thì nó xoay cái hình méo đó tiếp làm thẻ B nhỏ hơn nữa (xoay xong flat ra thành mp r xoay tiếp mp đó). 
transform-style: preserve-3d; thì thẻ B tách rời với thẻ A và k bị flat nữa nên xoay -60 độ sẽ trở lại kích thước và vị trí ban đầu

-> Usecase tạo 3D layer text: https://css-tricks.com/3d-layered-text-the-basics
Cơ chế tạo chữ phồng lên là dùng nhiều layer đè nhau, cách nhau 1px trục z thôi. Animation trục z tạo hiệu ứng chữ nổi lên xẹp xuống.
Cách dùng 3D cũng đỉnh



# Animation basic
Search #topcsseffects trong youtube => ra animation đủ loại cả ngàn video css animation.

-> transition: [transition-property] [transition-duration] [transition-delay] [transition-timing-function];
transition-behavior: allow-discrete; cho phép animation vẫn chạy khi đổi các thuộc tính rời rạc kiểu display, visibility, content-visibility
transition-timing-function VD cubic-bezier custom, ease/ease-in-out châm nhanh châm, ease-in chậm nhanh, ease-out nhanh châm. URL: https://cubic-bezier.com
transition-property k thể animation ảnh như background-image, animation màu thì nên dùng hue-rotate
VD: transition: all 1s 0.5s ease-in;
VD: transition: width 2s, height 2s, transform 2s;
VD: react dùng style={appear ? {fontSize: "unset"} : {fontSize: 0, padding: 0, opacity: 0}} + transition + transition-behavior allow-discrete

--> interpolate-size: allow-keywords; cho phép animate theo các giá trị auto, min-content, max-content, fit-content. VD padding 0 -> unset.
Luôn để transition-behavior allow-discrete và interpolate-size allow-keywords ở :root để áp dụng với mọi thẻ

--> JS có event "transitionend" và "animationend"
VD muốn 1 thẻ faded rồi biến mất bằng JS thì dùng transition opacity + "transitionend" để gán display none là được.

-> animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-direction] [animation-fill-mode] [animation-play-state];
animation-duration là thời gian từ lúc bắt đầu cho đến khi kết thúc
animation-delay là thời gian chờ trước khi hiệu ứng bắt đầu chạy. Có thể set số âm để bắt đầu nh animation lần lượt nhau ở giữa.
animation-iteration-count dùng số or infinite, số float cho ra animation dừng giữa chừng
animation-direction normal là đi về phía trước, reverse là về phía sau, alternate chạy xuôi rồi ngược lại, alternate-reverse chạy ngược rồi xuôi.
animation-fill-mode là khi animation end, nếu none or k set gì thì default jump về style ban đầu lúc chưa chạy animation, nếu forwards sẽ dùng giá trị khung hình cuối, backwards dùng giá trị khung hình lúc 0%; both là trộn forward và backwards; Bản chất style thêm sau đè lên style thêm trước, forwards thêm style cuối của keyframe vào thẻ.
animation-play-state: paused hay running. VD :hover mới chạy keyframe animation thì có thể dùng animation-play-state để tạo.
VD animation: name(hello) duration(2s) timing(linear) delay(2s) inter-count(infinite) direction(alternate/normal) both running;

URL full tut cả animation svg, 3d: https://viblo.asia/p/tap-tanh-tim-hieu-css-animation-bai-1-transition-4dbZNprL5YM
VD https://www.youtube.com/watch?v=M1qPpwVcF64 => Khi hover mới có animation hover thì để animation-play-state paused, hover thì running để tránh chạy mãi ngốn CPU.

- Nếu chỉ có to: nó sẽ animation từ thuộc tính hiện tại đến to
- Nếu chỉ có from: nó sẽ animation từ from tới thuộc tính hiện tại. 
- Nếu có cả from và to mà thuộc tính k khớp sẽ jump

--> Nếu có nhiều animation giống nhau chỉ hơi khác thuộc tính 1 xíu với từng thẻ, có thể gom với css var.
VD: @keyframes oscillate {
  from { transform: translateX(calc(var(--amount) * -1)); }
  to { transform: translateX(var(--amount)); }
}

--> Ứng dụng animate to dynamic value: https://www.joshwcomeau.com/animation/partial-keyframes/#animating-to-a-dynamic-value-3
Animation có thể kết hợp multiple chạy tất cả song song, cộng 2 đồ thị. 
1 animation dao động, 1 animation chỉ có from sẽ combine khiến animation chạy từ from tới cái còn lại. VD Tạo twinkle animation.

-> Usecase hover button to ra: 
- Nên cho button to sẵn và hover thì scale nhỏ lại về ban đầu.
- Nếu vẫn bị mờ và phải scale(1.2) lên khi hoverNếu không. Có thể hạn chế với:
will-change: transform; đưa gợi ý cho browser biết trước sẽ thay đổi như nào để optimize, có thể gây lag vì expensive cho browser nhưng fix mờ
backface-visibility: hidden; chặn hiển thị mặt sau giúp giảm mờ.

-> Animation với transform 
- rotate xoay các trục theo chiều kim đồng hồ khi các trục chỉ vào mặt mình
- keyframe transform: rotateZ(-45deg) translateX(50px) rotateZ(45deg); thì thứ tự viết các hàm ảnh hưởng tới animation, vì hàm sau phụ thuộc vào hệ toạ độ biến đổi từ hàm trước đó. Sau cùng nó gom đồ thị thành 1 và chạy animation 1 cục luôn. Ở case này sẽ di chuyển đường vòng cung.
VD rotateZ sẽ rotate cả trục tọa độ nên nếu rotateZ rồi translateX khác với translateX rồi rotateZ
- Để animation 1 set thẻ, nên nhét tất cả vào 1 thẻ container và animation thẻ container là được

-> Playback 1 animation
- Nếu muốn đổi animation từ nhanh sang chậm khi ấn nút, thì bao bằng 1 thẻ khác và animation ngược lại với cường độ nhỏ hơn, ấn thì đổi animation-play-state paused sang running
- Nếu 1 animation k có infinite, sẽ chạy đúng số lần r dừng, thay đổi các thuộc tính animation k khiến nó trigger lại. Để trigger lại, phải đổi animation-name. VD tạo 1 animation giống hệt, rồi liên tục thêm bớt animation thứ 2 để trigger liên tục, thực chất là 2 cái so le
Dùng css only có thể trigger animation liên tiếp mỗi khi click button bằng cách gán or remove 1 animaition y hệt nhưng khác name.

--> Playback animation bằng JS: xoá rồi thêm lại class sẽ trigger animation, nhưng làm bằng JS sẽ k chạy khi xoá r thêm lại class quá nhanh.
Để fix:
- Trigger reflow ép ở giữa khiến browser buộc render lại ngay:
animatedElement.classList.remove('animate');
void animatedElement.offsetWidth; // forces reflow
animatedElement.classList.add('animate');
- Dùng timeout cực ngắn => k dùng, k đảm bảo sẽ chạy mọi trường hợp 
animatedElement.classList.remove('animate');
setTimeout(() => {
  animatedElement.classList.add('animate');
}, 10);
=> Để 10ms là đủ để browser nhận ra và render lại, để là 0 thì chạy ngay event loop sau.

-> Animate SVG:
URL vẽ svg đơn giản: https://editor.method.ac/
- SVG có thể có animation sẵn, hoặc tự style animation cho các thẻ g, path là 1 phần của svg icon được.
- Animate line trong svg bản chất là animate thuộc tính stroke-dashoffset thôi
stroke-dasharray: 5,3; tức là 5 pixel liền thì có 3 pixels đứt sau đó và cứ tiếp tục vẽ đến hết hình
stroke-dashoffset: 100; xác định điểm bắt đầu vẽ của stroke-dasharray.

-> CSS sprite animation: có thể custom play, pause, chạy khi hover or click phức tạp, kiểm soát frame rate, kết hợp animation timeline cho scroll mà video hay gif k làm được.
https://ezgif.com/gif-to-sprite => convert ảnh động gif, apng or video sang sprite image với. Kết hợp hàng loạt ảnh gif trên trang giphy.
https://opengameart.org/ => search sprite có sẵn

Nhét mọi animation frames vào chung 1 bức ảnh và show nhanh từng frame trong ảnh để animate.
animation-timing-function: step(<số>); sẽ chia đều các khoảng được khai báo trong keyframes là từng frame rồi nhảy nhanh qua từng frame.
VD: @keyframes play {
  0% { background-position: 0 0; }
  10% { background-position: 100px 100px; }
  100% { background-position: 0 0; }
}
animation: play 1s steps(10) infinite; => Từ 0% đến 10% sẽ chia làm 10 frames và hiển thị lần lượt, từ 10% đến 100% lại chia 10 frames và hiển thị lần lượt, trong 1s.

-> Nhanh:
transition và animation
Playback 1 animation với css và js
Animate svg
CSS sprite animation



# Animation advance parallax
-> Tạo parallax với JS: object chuyển động dị dạng, font chữ và box to nhỏ.
- Để làm các thẻ đè lên nhau, dùng position absolute or fixed hoặc grid-template-areas mọi thẻ cùng 1 grid-area, để di chuyển dùng transform như bth.
- Để style theo scroll, dùng JS thay đổi css var --scroll và style css theo biến đó.là được.
URL: https://css-tricks.com/books/greatest-css-tricks/scroll-animation/ => 1 công thức duy nhất: window.addEventListener('scroll', () => { document.body.style.setProperty('--scroll', window.pageYOffset / (document.body.offsetHeight - window.innerHeight)) }, false);
VD scroll thẻ đi ngang, đến 1 mốc thì đi như bth: cho thẻ position fixed ở cuối màn hình, scroll thì translateX thẻ đó đi ngang và 1 thẻ trống có height cao để scroll
- Kết hợp công thức hoán đổi khoảng css var từ phạm vi scroll sang phạm vi animation của thẻ: (scrollVar - oldMin) * newRange / oldRange + newMin 
VD: calc(-1% * (max(var(--scroll), 25) - 25) * 100 / 75)
Để convert 1 giá trị sang 1 đơn vị khác, ta dùng phép nhân. VD 1vw*var(--value) là ta đang convert sang đơn vị vw 

-> Usecase parallax hover chuột thì card chuyển động nghiêng theo
Cơ chế là xđ vị trí chuột clientX clientY bằng JS để thay đổi css var. CSS thì :hover thẻ nào sẽ nghiêng thẻ đó với rotateX, rotateY, scale3d, rotate3d theo css var.

-> Tạo scroll parallax css only:
- Check browser hỗ trợ không. VD: @supports not (animation-timeline: scroll()) { }
Check browser có reduced motion không, no-preference là khi không reduce motion: @media (prefers-reduced-motion: no-preference) { }
- animation-timeline: scroll(<axis> <scroller>); chạy animation khi scroll cả page top tới bottom.
axis: x / inline / y / block (default)
scroller: nearest (default) / root / self 
nearest là check thẻ gần nó nhất bị scroll thì chạy animation, để chỉ chạy effect với scroll ngoài cùng thì dùng scroll(root);
VD tạo thanh loading ngang khi scroll bằng css thuần với animation-timeline scroll(block):
- animation-timeline: view(<axis> <inset>); chạy animation khi thẻ đi từ vị trí nào đến vị trí nào của viewport
axis: x / inline / y / block (default)
inset: auto / số% => có thể là 1 or 2 giá trị
animation-timeline: view(x 200px auto); => animation theo chiều ngang tính bắt đầu từ cách mép viewport 200px, điểm kết thúc là auto để browser tự tính.
Hoặc dùng animation-range kiểm soát điểm start và end của timeline, default thì animation bắt đầu khi mới vào viewport và kết thúc khi hiện đầy đủ trong viewport.
VD scroll animation với text: https://www.youtube.com/watch?v=d10GaL6F-lA
- animation-timeline: --squareTimeline; => animate theo scroll của thẻ có scroll-timeline-name: --squareTimeline; 

-> Usecase full project parallax với photoshop: https://www.youtube.com/watch?v=Yo3j_Dx4u7c
Cơ chế để move chuột thì các thẻ di chuyển full màn thì ảnh phải to hơn màn hình 1 chút, body overflow hidden, khi di chuột thì transform các layer ảnh với tốc độ khác nhau.
Để khiến nó realistic hơn, ta cần move nó cả trục z và thêm rotateY 1 chút, phải dùng kèm perspective.
VD: transform: translateX(...) translateY(...) perspective(2300px) translateZ(1000px);
Dùng kèm @media check case heigth lớn hơn width vì khi đó ảnh nên to ra theo height thay vì theo width. Check xóa hết width về initial, set kích thước theo height là đươc.
Khi vào page lần đầu cần có animation reveal, hiện page loading đảm bảo tải hết tài nguyên, sau đó set vị trí start và apply chạy reveal animation 1 lần tới vị trí bth. Cần đảm bảo khi load lần đầu và reveal animation thì mọi actions đều k thực hiện được như click mouse k tác dụng.

-> Usecase stack card dính ở top khi scroll: cho các thẻ position sticky và set top-padding cho từng card chênh nhau 1 khoảng theo index là xong.



# Usecase responsive marquee css only
-> URL simple: https://www.youtube.com/watch?v=iLmBy-HKIAw
Giải pháp là double các thẻ html và align animation hoàn hảo cho lần jump ở giữa với translate calc(50% - gap/2)

-> URL: https://frontendmasters.com/blog/infinite-marquee-animation-using-modern-css/ => chưa support rộng
offset: path() giúp định nghĩa 1 đường đi, kèm offset-path sẽ chỉ định vị trí trên path đó theo %, kèm offset-distance để di chuyển object theo path.
Dùng shape thay cho path vì shape tương tự nhưng có thể kết hợp với css function phức tạp. VD: path("M100 100 h200"); tương đương với shape(from 100px 100px, hline by 200px);
sibling-count() là hàm đếm có bao nhiêu sibling là các thẻ cùng là con trực tiếp của thẻ cha của hiện tại, k fix cứng gì cả.
VD offset: shape(from calc(var(--image-size)/-2) 50%, hline by calc(sibling-count() * var(--image-size))); => bắt đầu từ sát bên trái ngoài màn hình, 1 đường ngang dài bằng kích thước số lượng element



# Xử lý image
Hạn chế dùng ảnh gif vì nó nặng hơn video rất nhiều, dùng APNG hơn.

-> clip-path:
URL: https://bennettfeely.com/clippy/ => kích thước vẫn thế nhưng hiển thị cut ảnh clip-path
URL: https://www.youtube.com/watch?v=oWXm5n-Zi38 => thực sự học master clip-path
URL: https://css-generators.com/svg-to-css/ => convert hàm path thành hàm shape dùng cho clip-path trong css vì shape tốt hơn.
URL: https://www.youtube.com/watch?v=A5GXdjEOvos => ứng dụng clip-paths tạo diamond grid

URL: https://yqnn.github.io/svg-path-editor/ => vẽ ảnh svg cực mạnh, có thể dùng cho clip-path
Ưu tiên dùng SVG nếu có thể để tránh mờ khi zoom lớn: có thể tách file riêng or nhúng trực tiếp html hay sửa style tuỳ ý. SVG sprites là pp gom các ảnh svg từng phần vào 1 file duy nhất và chỉnh vị trí, FE k cần query từng phần svg 1 mà 1 cục luôn.
Có nhiều tool giúp vẽ tay SVG: https://topdev.vn/blog/svg-la-gi/

-> background: <background-color> <background-image> <background-position> / <background-size> <background-repeat> <background-attachment> <background-origin> <background-clip>;
VD: background: red url('image.jpg') center / cover no-repeat fixed padding-box content-box;
background-repeat space tương tự repeat nhưng repeat cắt background image khi ra ngoài phạm vi vì kích thước content k thể luôn chia hết cho kích thước background được. Còn space sẽ xếp mà k bị cắt, khoảng trống thừa ra sẽ chia đều giữa các ảnh
background-image có thể set multiple image, nó chỉ hiện trong phạm vi content, set background-repeat hoặc background-size lớn để tránh image nhỏ hơn content
background-color có thể dùng kèm background-image được và sẽ nằm ở dưới
background-clip: text; => sẽ lồng background image vào trong text, phải bỏ màu của text mới hiển thị ảnh với color or -webkit-text-fill-color: transparent;
background-attachment: scroll mặc định là trôi theo page scroll bar; local là trôi theo scrollbar của content; fixed là background fix k trôi, tạo parallax.
background-position kiểu vị trí x,y của ảnh trùng với vị trí x,y nào của khung. VD center center là tâm ảnh trùng tâm khung.
background-origin xác định vị trí hiện background image từ padding, border hay đúng phần content, ốp cho cả background-color và background-image.
background-blend-mode chỉ có tác dụng khi có màu chồng lên nhau: https://www.w3schools.com/cssref/playdemo.php?filename=playcss_background-blend-mode

-> Layer mask: tạo 1 lớp hiệu ứng lên trên thẻ đó. VD hiển thị bức ảnh theo phần ảnh của 1 bức ảnh png khác, ta cho bức ảnh khác đó như 1 lớp bên trên.
Dùng mask là shorthand của mọi thuộc tính mask-* trong css
VD mask-image: linear-gradient(black, transparent);
VD mask: url(masks.svg#star) 0 0 / 50px 50px no-repeat; => lấy thẻ có id là star trong ảnh svg làm mask, tại vị trí 0 0 từ top left và width height mask là 50px 50px.
VD mask: url(masks.svg#star) left / 16px repeat-y; => thẻ là mask ở phía bên trái với width 16px. Mask position phải xác định 2 giá trị như left top, mặc định nếu chỉ set 1 giá trị thì giá trị còn lại sẽ là center
VD mask mờ 2 bên thẻ: mask: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, black 20%, black 80%, rgba(0, 0, 0, 0) 100%); => thêm -webkit-mask nữa cho chắc
Còn có mask-composite giúp lồng nhiều lớp mask với nhau là intersect hay gì

-> Hiện ảnh responsive => 2 cách đều được
- Dùng <picture> tự đổi ảnh tùy vào kích thước màn hình mà k cần css js. <source> chỉ cung url, còn lại vẫn dùng tag image để chèn ảnh vào
VD: <picture class="image_container">
  <source media="(min-width:650px)" srcset="https://www.w3schools.com/tags/img_pink_flowers.jpg" type="image/jpg">
  <img src="" alt="" onerror="this.onerror=null;this.src='base64image';" loading="lazy">
</picture>
- <img> có sẵn srcset.
VD: <img src="image-400.jpg" srcset="image-400.jpg 400w, image-800.jpg 800w, image-1200.jpg 1200w" sizes="(max-width: 600px) 400px, (max-width: 900px) 800px, 1200px">

-> Style cho tag <img>: html cũng có <object> show mọi loại media, bị lỗi sẽ tự show thẻ con của <object> rất hay => với ảnh dùng <img> hơn
Dùng image filter: https://www.w3schools.com/css/tryit.asp?filename=trycss_ex_images_filters => có thể keyframe animation
Dùng attribute loading="lazy"/"eager" có sẵn của html <img>
Luôn set min-width min-height cho <img> giảm layoutshift khi load xong
object-fit: contain; => nên set contain trong khung, hoặc cover 1 chiều và hiện ở tâm
object-position: center center;
aspect-ratio: 1 / 1;

--> onload check ảnh tải xong => có thể hiện spinner mặc định và ẩn đi khi ảnh tải xong, lấy được kích thước ảnh sau khi tải.
onerror check ảnh lỗi thì hiển thị ảnh fallback => luôn dùng
VD: <img src="invalid_link" onerror="this.onerror=null;this.src='https://placeimg.com/200/300/defaultiamge';"> => Dùng this.onerror=null chống lỗi infinity loop, xảy ra ở 1 số browser khi fallback image trong onerror lại bị lỗi khiến lặp vô tận.
Dùng ảnh low-res ở local làm bg image đảm bảo luôn có và ưu tiên load: <link rel="preload" as=image href="./lowresimage.png" fetchpriority=high>. Để đảm bảo ảnh luôn có kể cả lỗi mạng, dùng base64 cho blur image là được => luôn dùng base64 cho default image

--> Cách tạo ảnh mờ làm placeholder thay cho màu xám, ảnh default fix, skeleton loading:
- Ảnh người dùng nhập thì dùng BlurHash - lib giúp tạo ảnh mờ từ 1 ảnh khác, paste ảnh vào và lấy ra hash làm mờ.
- Ảnh có sẵn thì thu nhỏ rồi phóng to là xong
Có thể chuyển sang base64. Khi nhúng ảnh base64 vào code, tốc độ transfer ảnh tới client sẽ nhanh hơn nhưng mobile lại chậm hơn vì ngốn CPU render ảnh. 
Web chuyển ảnh thành data uri base64 dạng mờ không cần dùng thư viện blur hash: https://blurred.dev/
- Cloudinary nhận image cung ra url là blur image nhẹ hơn, có thể generate blur dynamic image.
VD URL gốc: https://res.cloudinary.com/hieucuopbien123/image/upload/v1688738028/eokcgjfzuedo2oobnzzb.png
Làm mờ nhẹ hơn: https://res.cloudinary.com/hieucuopbien123/image/upload/e_blur:100/v1688738028/eokcgjfzuedo2oobnzzb.png
Làm mờ kèm grayscale nhẹ hơn nữa: https://res.cloudinary.com/hieucuopbien123/image/upload/e_blur:1000,q_1,f_auto/v1688738028/eokcgjfzuedo2oobnzzb.png
Full tut custom: https://cloudinary.com/blog/low_quality_image_placeholders_lqip_explained#the_javascript_options_for_generating_lqips

-> Tối ưu nén ảnh:
- Dùng cloudinary có thể giảm kích thước ảnh tối đa mà k mất chất lượng: https://cloudinary.com/blog/adaptive_browser_based_image_format_delivery
- Dùng tinyPNG hay imagemin để giảm tải kích thước cho ảnh tĩnh trước r mới lưu vào server.
- Ưu tiên định dạng WebP or AVIF giảm kích thước 30% so với jpg
- Các framework như NextJS cung sẵn option tự optimize image theo kích thước màn. ReactJS có lib nén ngay tại browser.
- Có thể tự chuẩn bị sẵn các bức ảnh kích thước khác nhau và cho load theo kích thước màn hình

-> Nhanh:
Dùng clip-path
background
Dùng layer mask
Đổi ảnh theo kích thước responsive
Dùng <img> và lazy loading
Dùng onload onerror khi ảnh lỗi
Tạo ảnh placeholder
Tối ưu nén ảnh



# if else và style query và function trong css => k support rộng
-> Style query: style cho 1 tag con nếu tag cha có style gì, có thể dùng nested selector tương tự
VD: @container style (--bg: red) { } => dùng như này trong 1 thẻ thì nếu thẻ cha có style tương ứng, sẽ áp dụng style cho thẻ hiện tại
VD: @container style (--bg: var(--accent)) { }
VD: @container style (--overflow-scroll: on) and (width < 900px) { }
=> Có thể mix @media đổi custom properties + @container style query + if else tạo ra case phức tạp

-> VD lấy html attribute data-status vào custom property --status và gán giá trị cho grid-columns tuỳ vào giá trị của --status:
.card {
  --status: attr(data-status type(<custom-ident>));
  grid-columns: if(
    style(--status: pending) 1;
    style(--status: complete) 2; // if check từ trên xuống, lấy cái đầu tiên thoả mãn
    else 3
  );
}
=> Lưu ý đổi grid-columns bằng css if khiến cho thứ tự card hiện ra không đồng nhất với thứ tự định nghĩa trong html, gây nhầm lẫn cho screen reader. Phải dùng thêm reading-flow: grid-columns; ở thẻ cha để chỉ định cho screen reader đọc theo từng grid-columns

-> VD function chỉnh opacity cho màu: 
@function --opacity(--color, --opacity) { result: rgb(from var(--color) r g b / var(--opacity)); }
:root { --brandBlue: skyblue; --brandBlue-a20: --opacity(var(--brandBlue), 20%) }

-> VD tạo font-size responsive nhưng header sẽ scale font manh hơn các vùng khác.
@function --fluid-type(--font-min, --font-max, --type: 'header') {
  --scalar: if(style(--type: 'header'): 4vw; 
               style(--type: 'copy'): 0.5vw);
  result: clamp(var(--font-min), var(--scalar) + var(--font-min), var(--font-max));
}
h1 { font-size: --fluid-type(24px, 36px); }
p { --copy-min: 16px; --copy-max: 24px; font-size: --fluid-type(var(--copy-min), var(--copy-max), 'copy'); }

-> VD gom responsive chung 1 hàm:
@function --layout-sidebar(--sidebar-width: 20ch) {
  result: 1fr;
  @media (width > 640px) { result: var(--sidebar-width) auto; }
}
.layout { grid-template-columns: --layout-sidebar(); }

-> VD dùng if với media query: 
:root {
  --bp: if(
    media(width <= 600px): "sm";
    media(width <= 800px): "md";
    else: "lg";
  );
}
.box {
  background-color: if(
    style(--bg: "sm"): green;
    else: blue;
  );
}

-> VD dùng style query với media query:
:root {
  --bp: "xl";
}
@media (width <= 1000px) {
  :root {
    --bp: "md";
  }
}
@media (width <= 500px) {
  :root {
    --bp: "sm";
  }
}
@container style (--bp: "sm") {
  /* Style cho "sm", khi đổi số "sm" chỉ cần đổi 1 nơi */
}

-> Văn bản file bth lưu là .htm cx mở đc bằng web nhưng nó chỉ là văn bản thô, k có các chức năng xuống dòng,... nên dùng các thẻ HTML vô thì nó sẽ thành siêu văn bản(hypertext)
file .htm < .html

-> ECMAScript hay ES6 là 1 đề xuất tiêu chuẩn cho các ngôn ngữ javascript ra đời năm 2015 hay còn gọi là ECMAScript 2015 vì mỗi trình duyệt có cách chạy javascript khác nhau nên cần 1 quy tắc chung để trang web có thể chạy tốt trên mọi trình duyệt. Như v ES6 cx chỉ là các quy tắc, tính năng của javascript mà thôi.
Các phiên bản ES1, ES2,..., ES8 cũng chỉ là các phiên bản JS theo thời gian, các phiên bản sau vẫn dùng được code của các phiên bản trước.

CommonJS là 1 module cung thêm 1 vài cú pháp như hàm require. Tránh nhầm lẫn vì k dùng được CommonJS trong JS thuần mà nó dùng trong NodeJS phía server để hỗ trợ code được JS phía server. Thực tế trong JS thuần ta có thể sử dụng công cụ bên thứ 3 là package Browserify sẽ cho phép phía frontend dùng được CommonJS nhưng điều này là k cần thiết vì các phiên bản ES là quá đủ nên ta chả bh thấy. Ngược lại, package babel cho phép convert ES6 sang CommonJS để NodeJS dùng được.

JS là 1 ngôn ngữ lập trình hướng đối tượng vì nó đáp ứng tất cả tính chất của lập trình hướng đối tượng, dù tính chặt chẽ cú pháp của nó khá kém. JS là prototype-based(object-based) language, 1 nhánh của OOP language, còn Java, C++ mói là chuẩn class-based object-oriented language.

-> Có nhiều loại trình duyệt tùy theo nền tảng hệ điều hành khác nhau. VD trong android có Android Browser, iPhone, La bàn, Opera, UC Browser,.. còn trên desktop có Chrome, IE, Firefox, Safari, Cốc Cốc(của VN),..
Trình duyệt cx chỉ có chức năng hiển thị tài nguyên web sử dụng, ta query tài nguyên đó từ server thông qua url. 

Bao gồm giao diện người dùng(các thứ hiển thị trên màn hình)-> browser engine phân phối công việc giao diện và render engine-> render engine chịu trách nhiệm hiển thị nội dung yêu cầu ra, phân giải html/css ra-> Networking xử lý http request-> bộ thông dịch js chạy code js-> lưu trữ dữ liệu như storage, cookies

Các trình duyệt khác nhau sử dụng rendering engine khác nhau như: Webkit dùng cho Safari, Gecko dùng trong firefox, blink dùng trong chrome, opera,..
V tại sao lại cần dùng đến các engine khác nhau, bởi vì mỗi thứ có 1 điểm lợi khác nhau, vd 1 cái giải quyết cái gì k tốt thì họ có thể tạo ra 1 engine mới tốt hơn chẳng hạn. Tuy nhiên cho đến h, khả năng xuất hiện 1 engine mới là cực thấp trừ khi có 1 bước tiến mới đáng kể. 

Chromium là 1 trình duyệt mã nguồn mở. Các trình duyệt như chrome cũng sử dụng mã nguồn của chromium để tạo nên đó tuy nhiên nhiều người biết đến chrome chứ k bt đến chromium, chromium bị hạn chế hơn so với chrome. Nên dùng Chromium nếu sử dụng hđh mã nguồn mở. Tức là người ta dùng mã nguồn mở của Chromium để phát triển nên các trình duyệt khác.


-> Có nhiều trang web cho hosting miễn phí, vd 000webhost-> vào đăng ký tk free-> tải file lên-> đổi tên file html cần hiển thị đầu tiên là index.js là xong. Dùng free sẽ bị hạn chế chỉ được quản lý 2 website 1 lúc, lượng file size bị giới hạn, tên miền sẽ có thêm 000webhostapp.com
VD trang web của ta: https://magicnumberfortest.000webhostapp.com/



#***Thao tác hay trên DevTool của Browser:
Trên tab console: 
allow pasting
[...$$('img')].forEach(a=>a.remove()); => chọn tất cả thẻ img trong trang nhét vào 1 mảng, duyệt từng phần tử trong mảng r xóa nó
document.designMode = "on"; => sửa trực tiếp mọi thứ trên trang web
Có thể bảo toàn log khi refresh lại trang bằng Preserve Log ở tab Console
Viết autoClick VD: Array.from($$('a.touchable.primary')).forEach(btn => btn.click()) => click tất cả các thẻ a có 2 class .touchable.primary => Toàn viết bằng jQuery thôi. VD: đồng ký tất cả kết bạn

Tab Source: ctrl+p -> tìm file -> đặt debugger -> tới line bất kỳ với: ctrl+p -> :100 để tới dòng 100 -> refresh trang thì nó sẽ chạy đến breakpoint là dừng
No tương đương đặt lệnh debugger; trong file js
Trong VSC có thể search ký tự gì xuât hiện ở những dòng nào file nào và trong devtool cũng có thể với: ctrl+shift+f
Để cho file chạy đến dòng nào thì log gì ra có thể: right click breakpoint -> logpoint -> ghi message có thể ghi biến ra thì nó sẽ log biến đó



#***Load file JS với async và defer
Browser nếu thấy file js or script, sẽ dừng vc parse HTML để lý JS (Parse Blocking)
Trong script có 2 attribute là async và defer: async sẽ tải script bất đồng bộ trên 1 thread khác và tiếp tục parse trang, tải xong JS sẽ chạy; defer chỉ chạy khi html parse xong.

VD: Trình duyệt đang parse HTML CSS thì gặp 1 script async -> trình duyệt tiếp tục parse HTML CSS trong khi tải script -> trình duyệt parse HTML chưa xong nhưng tải xong script thì vẫn chạy script bất cứ lúc nào khi tải script xong
VD: Trình duyệt đang parse HTML CSS thì gặp 1 script defer -> trình duyệt tiếp tục parse HTML CSS trong khi tải script -> trình duyệt parse HTML chưa xong nhưng tải xong script thì script k được exec -> parse HTML xong thì exec script đã tải
=> Dùng async khi script độc lập với DOM(ít khi), defer khi script tác động vào DOM, cần DOM load xong trước



-> Ở tab network: có thể filter để lọc ra những request loại file gì browser lấy từ server. VD lọc ảnh và lấy link ảnh nhanh
Ở tab Console: Có thể chỉnh trạng thái element là hover, active, focus,.. để xem style element khi điều đó xảy ra. Có thể lọc ra những log nào có thể hiện VD chỉ lọc log warn và error chẳng han


-> Cách trình duyệt hiển thị website:
Sử dụng file HTML tạo DOM: đọc từ trên xuống tạo cây DOM. Nên đặt style ở đầu và script ở cuối vì trình duyệt bth luôn cần css load sớm để hiện ra còn tính năng k cần load ngay. Đấy là với ứng dụng bth chứ React luôn load js.

Load CSS tạo CSSOM(CSS object model): Trình duyệt chỉ hiển thị khi cả DOM và CSSOM được tạo hoàn chỉnh nên CSSOM cũng chặn quá trình render trang web(Render Blocking). Do đó nên giảm kích thước style và load càng sớm càng tốt, xóa các style dư thừa để trình trì hoãn tối đa

Load JS: nếu thấy file js or script, sẽ dừng vc parse HTML để lý JS (Parse Blocking) 
Trong script có 2 attribute là async và defer

Kết hợp DOM và CSSOM tạo Render Tree và render ra màn hình -> Xác định size và vị trí các phần tử trong trang web -> Paint ra màn hình


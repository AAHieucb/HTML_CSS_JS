# Sự phát triển của JS
Đầu tiên JS được dùng trong website bằng tag <script> tới file index.js. Khi JS thuần k đủ, người ta phải thêm các thư viện như jQuery, lodash. 
Ta phải tải file lodash.js về và lại <script> tới nó là được. Để dùng code lodash trong index.js thì phải script tới lodash trước index.js

Việc quản lý version sẽ khó vì ta phải tải file về thủ công và nhớ version. 
npm ra đời giúp quản lý thư viện, nó giúp tải thư viện về node_modules và quản lý version trong package.json.
Frontend muốn dùng thì index.html vẫn phải <script> thủ công tới lodash.js đặt trong node_modules 

NodeJS ra đời giúp js code được phía server và tính năng import sourcecode với server đã ra đời thông qua keyword require. Tức ta dùng require("lodash") kết hợp npm sẽ tự tìm chính xác vị trí thư viện trong node_modules, xử lý duplicate import.
Nodejs còn cung cấp export/require giúp tự tạo modules, tức require còn tìm ở các file trong thư mục gốc chứ k chỉ tìm trong node_modules.
Frontend lúc này vẫn chưa thể import sourcecode trực tiếp, lý do là client side k hiểu lệnh require là gì, vẫn phải <script> tất cả trong file html trước theo thứ tự.

JS ra đời type module giúp import code giữa các module với nhau ở FE, và import từ node_modules

Module bundler ra đời giúp FE dùng được các package của server bằng cách thế nội dung gốc vào, loại bỏ cú pháp require. Có thể import cả file css các thứ luôn. 
Bundler cũng đóng gói phần code js thành 1 file js chung và html chỉ cần script tới 1 file đó thôi. 
Có nhiều phiên bản JS, nhiều lúc ta cần chuyển đổi những mã JS ở bản mới về bản cũ để hỗ trợ các browser cũ hơn, thì có thể thêm JS compiler như Babel. 
Khi gõ 1 command là tự động build, đóng gói, <script> code JS trong file html k cần làm thủ công. Để làm điều đó tự động, có thể dùng task runner, như Grunt, Gulp.



# Nguyên tắc code FE
Kiểm soát bố cục từ lớn tới nhỏ, cái nào chứa cái nào, thẻ con có vị trí thế nào so với thẻ cha. 
Đảm bảo thẻ con luôn nhỏ hơn ở trong thẻ cha, con phụ thuộc vào cha chứ kp ngược lại. Màn hình nhỏ dần thì cha nhỏ dần, vì con phụ thuộc vào cha nên cũng nhỏ theo.
Chỉ set fix with với button hay icon nhỏ. Vì màn hình nhỏ sẽ khiến cha nhỏ dần, mà con fix cứng thì đến 1 lúc sẽ tràn khỏi cha.
VD k dùng fit-content vì thẻ con to ra sẽ khiến cha to ra theo sẽ vi phạm nguyên tắc, nên thay bằng max-width và xử lý rõ overflow để kbh cho 1 con dôi ra ngoài cha.
VD tương tự k nên dùng whitespace nowrap mà hãy dùng line clamp nếu có thể



# DevTool Browser
-> Tab Console: 
allow pasting
document.designMode = "on"; 
[...$$('img')].forEach(a=>a.remove()); 
VD autoClick: Array.from($$('a.touchable.primary')).forEach(btn => btn.click()) => click tất cả các thẻ a có 2 class .touchable.primary

-> Tab Source: ctrl+p -> tìm file -> đặt debugger -> refresh trang thì nó sẽ chạy đến breakpoint là dừng
Để cho file chạy đến dòng nào thì log gì ra có thể: right click breakpoint -> logpoint -> ghi message có thể ghi biến ra thì nó sẽ log biến đó

-> Tab network: Chuột phải vào api -> override json -> chọn 1 folder bất kỳ -> ghi đè api

-> Edge tắt JS: 3 chấm -> setting -> site permission -> javascript -> ấn tắt
Khi đó, thẻ <noscript> </noscript> sẽ hiển thị. Tắt JS cũng chặn quảng cáo.

-> CTRL + F => Emulate a focus page => luôn dùng



# Animation JS hay CSS
Đa số TH thì tốc độ là như nhau, nhưng CSS thường tốt hơn vì giảm thiểu logic cho browser xử lý các thứ khác, tận dụng GPU tối ưu hiệu suất
Chỉ dùng animation cho JS khi buộc cho exit animation. React mà dùng useState cho animation sẽ rối vì rerender.
VD cần remove 1 thẻ khỏi DOM bằng animation buộc phải dùng JS bảo nó chạy animation trước, khi animation kết thúc thì remove thẻ để có exit animation. 
Dù CSS k xoá thẻ khỏi DOM được nhưng vẫn có cách ẩn thẻ: opacity 0 + visibility hidden trước rồi height giảm về 0 sau đó



# How to design a website
-> Exp:
- Phần header dóng được xuống phía content bên dưới, hoặc content ngay bên dưới là fullscreen, nếu không sẽ rất xấu. Tương tự các section cần align theo chiều dọc bằng nhau
- Navigation bar có text và logo nên cùng màu đồng bộ, cùng 1 styles, logo nhỏ gọn.
- Hero section: Chữ nên được tương phản với ảnh background và có kích thước vị trí nổi bật hoặc thêm gradient, có thể phóng to thu nhỏ từng phần, uppercase chữ nổi bật. VD cho núp sau ảnh. Ảnh nên được upscale rõ, ít khi cho tối hay mờ đi, ưu tiên load trước.
- K nên để text dài cả 1 dòng, nên vắn tắt ít chữ, nếu buộc có đoạn văn dài thì nên chia ra nhiều paragraphs nhỏ.
- Button trong card thường đồng bộ và nằm ở 1 phía, k chiếm full kích thước
- Sidebar UX:
Cho phép expand 48-64px to 240-300px. Icon khi thu nhỏ luôn phải có tooltip và show cả phím tắt. Cho phép user drag trong sidebar, hightlight vùng quan trọng thường dùng.
Mỗi item trong sidebar có button riêng như create, view, update, leave, or có số nhỏ hiển thị thông tin ví dụ số lượng notifications
Sidebar có thể mở sidebar con và back lại được, hoặc chia level dropdown xuống subitem. Pages khác nhau có thể có sidebar khác nhau. Safe triangle.
Sidebar thường có thể switch accounts, chứa darkmode, chứa thông báo update ở cuối có thể tắt đi. Có thể chứa search bar search item trong sidebar nếu lớn.
Có checkbox thì chia 3 vùng màu rõ ràng cho item unselected, selected, hovered.
- Có tool online check constrast ratio vì nó ảnh hưởng SEO: Văn bản thường > 7:1, Văn bản lớn > 4.5:1, Max k quá 15:1

-> AI tool
https://teleporthq.io/ai-website-builder => AI design web, có hosting. Free được 1 web 3 pages, 5MB assets.
https://www.motiff.com/ => AI design được như figma, nhưng AI chỉnh sửa k được chuẩn
https://readdy.ai/ => AI design web mạnh, k tự sửa được như figma
http://purecode.ai/my-generations => tool generate component UI bằng AI
https://codia.ai/pricing => AI convert qua nhiều kiểu đa dạng. VD image sang code.

-> Tổng hợp các kiểu design
Newmorphism: kiểu design tạo clean effect rất ảo
Glass morphism dùng với backdrop-filter blur + 1 lớp kính rgba mỏng
Skeuomorphism hình thực tế => k dùng
Flat design: web như 1 mặt phẳng với hình vẽ đơn giản, k có shadow hay hiệu ứn nổi lên gì cả
Material design mở rộng của flat design, có hiệu ứng nổi lên mọi nơi. Màu và shape cần thay đổi. Mọi chuyển động phải liên tục, k đột ngột ẩn hiện.
Retro/Vintage Styles: web phong cách tinh tế, cổ kính, sang trọng, quý tộc, cổ điển. 
Brutalism design: web hiệu ứng mạnh, thô mộc, tương phản cao, font chữ nhiều lúc rất ảo
Minimalism: chỉ hiển thị các thứ cần thiết, k có gì thừa thãi, đơn giản, có thể đơn sắc, là loại web dễ tạo và dễ nhìn nhất.
Vaporwave design: web dùng tông màu neon như hồng, tím, xanh dương kiểu biển hiệu quảng cáo điện tử, video game, hoài cổ. VD thena.fi mới chỉ có 1 chút vaporwave thôi
Memphis design: dùng màu sắc sống động với các dạng hình học, ký tự đa dạng không đối xứng sắp xếp trừu tượng ngẫu hứng.

https://htmlrev.com/ => 1500 template free tạo dự án

-> Color rule phối màu 
Màu neutral 60% quyết định theme chính của ứng dụng. Màu này được sử dụng cho nền ngoài cùng. Thường là đen or trắng (1 màu rất tối or 1 màu rất sáng).
Màu primary 30% được dùng cho các panel hay background của dialog, card. Màu này nên gần giống màu neutral để tạo ứng dụng 1 theme monochrome.
Màu secondary 10% chỉ dùng cho các phần tử quan trọng nổi bật mà user có thể tương tác hoặc muốn highlight như button đặc biệt. Màu này nên nổi bật lên trên 2 màu kia.
=> Màu chọn có thể mix gradient hay 1% các màu lạ khác nhưng phải tuân theo quy tắc 3 màu chủ đạo. K để màu quá tương phản show đè nhau.
=> Ảnh k ảnh hưởng màu nhưng nếu nhiều ảnh cùng 1 màu nền thì nên để màu ảnh là màu primary.

-> Các component style:
https://css-tricks.com/hexagons-and-beyond-flexible-responsive-grid-patterns-sans-media-queries/ => Tạo polygon responsive thuần
https://www.youtube.com/watch?v=G8cyr199xZQ => animation cho button đẹp
https://www.youtube.com/watch?v=qTfQUXCPA2o => inverted border dùng thêm tag
https://www.youtube.com/watch?v=dbaOq7F5msU => inverted border dùng mask phải có ảnh
https://www.youtube.com/watch?v=BgBtxSGEows => crazy animate text theo chuột



# Thuộc tính khác ít dùng
resize: both; => biến mọi thẻ thành resizable
direction: ltr; => hướng căn lề
writing-mode: vertical-rl; => hướng in chữ
contenteditable => biến mọi thẻ thành editable nhưng xấu
text-emphasis => emphasis marks dùng cho ngôn ngữ có thanh âm để biểu hiện tính cao hay trầm của âm tiết.
margin-inline: auto; thay cho margin: 0 auto; để căn giữa
*min-inline-size => thay cho min-width và nó tính cả hướng văn bản
*border-block-end => là cạnh dưới của văn bản trong phần tử như border-bottom nhưng tính thêm cả writing-mode.
*text-decoration-thickness, text-underline-offset => style underline chi tiết
<progress> => giúp hiện thị progress
<template> => tag đặc biệt mà nội dung k được render trực tiếp mà dùng để copy rồi mới render ra chỗ khác
<video> có preload="auto,metadata,none", metadata là xem đến đâu load đến đấy, trong khi auto là load entire video luôn. 
inert là attribute sẽ vô hiệu hóa mọi tương tác của người dùng với tag đó.
*width: fill-available; width: -webkit-fill-available; => kéo dài hết phần mà nó có thể kéo. Cách khác là bao flexBox và dùng flexGrow cho nó
*field-sizing: content; => dùng cho mọi loại input/textarea tự mở rộng dần khi content đổi. Dùng min-height cho progressive enhancement.

-> min/max/fit-content => bỏ
min-content: kích thước nhỏ nhất mà vẫn chứa content, sẽ khiến content co nhỏ nhất có thể
max-content: kích thước lớn nhất mà vẫn chứa content, sẽ khiến content duỗi dài nhất có thể, gây overflow.
fit-content: kích thước luôn vừa với content, khi màn hình nhỏ khiến content co nhỏ lại thì nó chiếm fullwidth, như width auto.



# Youtube streaming server load video rất nhanh
Video được nén bằng thuật toán AV1 cực mạnh mà k giảm chất lượng, nó dùng nhiều server chuyên dụng để encode vì thuật toán nặng.
Video tải lên cũng được mã hoá ở nhiều độ phân giải. Youtube tính toán cấu hình máy và tốc độ mạng (nếu để auto) để tải video tương ứng.
Ưu tiên load video hơn các component khác trên web
Dự đoán video nào xem tiếp để tải trước phần đầu, dựa vào lịch sử và xu hướng của nhiều người dùng.
Xem đến đâu tải đến đấy, kéo dài đoạn tải trước ra dài để đảm bảo k bị delay.
Băng thông rộng với mạng lưới CDN có mọi video.

Để xử lý video quá dài, youtube chia hàng nghìn segment nhỏ và đánh dấu phần đầu và phần xem nhiều thì cho cache Edge CDN, phần xem vừa thì cho regional server, phần xem ít giữ trong original server. Video hot trending cũng ưu tiên lên CDN hơn video cũ rồi. Nhiều video chỉ có người xem ở vài quốc gia thì chỉ lưu trên các CDN quốc gia đó.
Phần tải trước dài như nào cũng dựa vào phần sắp xem ở trên original server không, tốc độ xem, pattern đoạn nào hay bị skip.

Youtube tính view: 
Video phải xem quá ngưỡng thời gian tối thiểu, thậm chí có các mốc được mark random phải request đủ các mốc đó mới tính.
Phát hiện bots và spam. IP tracking 1 máy xem lại nhiều lần 1 đoạn trong thời gian ngắn sẽ bị hạn chế, chỉ tính vài view đầu.
Có cơ chế tự động check để audit lại view định kỳ nên đôi khi sẽ thấy view giảm.
Video mới mà có lượt view tăng bất thường sẽ bị đóng băng view vài giờ đầu để đội ngũ vào xác minh thủ công.



# Other
-> Dùng CSS JS tính năng mới luôn phải có fallback, k hỗ trợ sẽ để mặc định: CSS có @support. JS check bth.
VD check polyfill browser cũ: if (!Array.prototype.includes) Array.prototype.includes = function includes(searchElement) { return this.indexOf(searchElement) !== -1 }



# Xử lý image
URL: https://bennettfeely.com/clippy/ => kích thước vẫn thế nhưng hiển thị cut ảnh clip-path
URL: https://yqnn.github.io/svg-path-editor/ => linh động hơn

=> Ứng dụng tạo diamond grid: https://www.youtube.com/watch?v=A5GXdjEOvos&list=WL&index=98

-> Có multiple background image. background-size background-image background-repeat background-color (dùng kèm background image được sẽ nằm ở dưới)
background-position kiểu vị trí x,y của ảnh trùng với vị trí x,y nào của khung. VD center center hay 0 0 là tâm ảnh trùng tâm khung hay 0,0 của ảnh trùng 0,0 của khung. background-image hiện trong phạm vi content, nếu dịch tràn ra ngoài sẽ k dịch chuyển trừ khi cho repeat hoặc background-size lớn 

background: red url("./image.png") no-repeat local right top

background-origin xác định vị trí của background image theo content. 
background-clip text => sẽ lồng background image vào trong text, buộc phải bỏ màu của text mới hiển thị ảnh, color: transparent; => giải quyết vđ k set gradient cho text color đc
background-blend-mode chỉ có tác dụng khi có màu chồng lên nhau: https://www.w3schools.com/cssref/playdemo.php?filename=playcss_background-blend-mode
background-attachment: scroll mặc định là trôi theo scroll bar; local là trôi theo scrollbar của content; fixed là background fix k trôi, tạo parallax

VD: background-origin apply cho cả background-color và background-image, k thể chỉnh riêng hay chia từng image

-> Các thuộc tính image filter: https://www.w3schools.com/css/tryit.asp?filename=trycss_ex_images_filters

-> Layer mask: mask là shorthand của mọi thuộc tính mask-* trong css
Dùng style cho 1 thẻ để tạo 1 lớp hiệu ứng bên trên thẻ đó. VD hiển thị bức ảnh theo phần ảnh của 1 bức ảnh khác, ta cho bức ảnh khác đó lên 1 lớp bên trên.
VD mask-image: linear-gradient(black, transparent);
VD mask: url(masks.svg#star) 0 0/50px 50px no-repeat; => đặt mask tại vị trí 0 0 từ top left và width height mask là 50px 50px
VD mask: url(masks.svg#star) left / 16px repeat-y; => element là mask ở phía bên trái với width 16px. Mask position phải xác định 2 giá trị như left top, mặc định nếu chỉ set 1 giá trị thì giá trị còn lại sẽ là center
Dùng mask: linear-gradient(90deg, transparent, white 20%, white 100%, transparent);

-> Image placeholder
Dùng thẻ img có width và height bằng kích thước ảnh, nếu k rõ thì dùng minWidth minHeight để luôn có placeholder. 
Cbi sẵn 1 bức ảnh default để lỗi thì show ra. Dùng bg color xám cho thẻ img để ảnh chưa có thì hiển thị 1 màu xám, hoặc tìm cách show skeleton. Có thể dùng background-image của tag image để làm ảnh default.
Dùng border radius thẻ div bao ngoài img kèm overflow hidden
Dùng onLoad và onError, VD check ảnh lỗi thì hiển thị ảnh lỗi mặc định chứ k show hình lỗi xấu.
HTML có thẻ object show mọi loại media, nếu bị lỗi sẽ tự show thẻ con của thẻ object rất hay => ít dùng vì kp chuyên cho ảnh.

VD: <img src="invalid_link" onerror="this.onerror=null;this.src='https://placeimg.com/200/300/animals';" >
Việc dùng this.onerror=null chống lỗi infinity loop. Lỗi này xảy ra ở 1 số trình duyệt khi chính ảnh để ta fix lại bị lỗi xong lại chạy onerror lại lỗi và cứ lặp vô tận
Nếu sợ lỗi infinite loop, thì có thể set 1 bức ảnh backup onerror local đảm bảo luôn tồn tại là được. 

--> 1 cách khá hay là chuẩn bị 1 phiên bản cực nhẹ cho ảnh, thu nhỏ nó lại và làm mờ đi. Cho nó làm background-image và phóng to lên để load ra trong lúc tải ảnh gốc nặng.
object-position: center top; => giống background position nhưng áp dụng với các tag có thuộc tính object-fit 

--> onLoad, onError k hỗ trợ mọi browser nên thư viện react-lazy-load-image-component sẽ lo điều đó với mọi browser
Thuộc tính PlaceholderSrc của LazyLoadImage nhận 1 ảnh kích thước nhỏ để hiển thị ra trước khi ảnh lớn được load. Ta có thể giảm độ phân giải ảnh bằng các công cụ chỉnh sửa để thế vào, thêm effect="blur" để làm mờ ảnh placeholder được
--> Lib react-progressive-graceful-image rất phù hợp dùng được thay thế cho tag object của html hiển thị ảnh placeholder, nếu ảnh lỗi thì chỉ hiển thị placeholder mặc định

-> Lazy loading ảnh: thuộc tính loading="lazy"/"eager" có sẵn của html

-> Ưu tiên dùng ảnh SVG để tránh bị mờ khi zoom lớn: svg dùng đồ họa vector có animation.
SVG Sprites là pp gom các ảnh từng phần vào 1 file duy nhất và chỉnh vị trí cho chuẩn. Thay vì server nhận nhiều request từng tấm ảnh nhỏ thì chỉ cần 1 bức SVG là được
Có nhiều tool giúp vẽ tay SVG: https://topdev.vn/blog/svg-la-gi/



# Dùng float:
Float khiến 1 thẻ block thành inline không chiếm height và trôi sang 2 bên. Các thẻ khác vẫn hiện cùng dòng và né width nó ra.
clear: both => khiến thẻ float chiếm height, các thẻ khác k thể ở cùng dòng với nó nữa

-> VD thẻ div chỉ có các thẻ float bên trong thì height thẻ div đó là 0 vì thẻ float k chiếm height của cha nó mà
ClearFix trong CSS giúp thẻ cha mang kích thước của thẻ con kể cả dùng float, chỉ cần cho 1 thẻ con dưới float để kéo dài cha quá float là được.
VD: .clearfix:after{
  content: ".";
  clear: both;
  display: block;
  width: 0px;
  height: 0px;
}



# Cách dòng
white-space: nowrap
text-overflow + overflow hidden xử lý text tràn thì cut và hiển thị gì ra
letter-spacing là kc giữa các ký tự; word-spacing là tăng hay giảm kc các word bnh chứ kp là giá trị kc luôn
text-indent để lùi đầu dòng paragraph

box-decoration-break => xử lý style inline element khi break sang nhiều dòng, liệu các style css vẫn dùng chung cả cục hay mỗi dòng là 1 style đó riêng. 
line-height giúp căn kc các dòng trong 1 văn bản có nhiều dòng. Có thể dùng nó để chỉnh vị trí của text theo chiều dọc, VD dùng thay việc set paddingTop
vertical-align có thể dùng nhanh khi cần chỉnh vị trí lên hay xuống 1 tẹo so với vị trí hiện tại mà k cần dùng đến flexbox => nên thử mọi options khi dùng
=> Thông thường ta bao tất cả bằng 1 component lớn với line-height, phần nào bên trong muốn chỉnh vị trí lên xuống thì nhét vertical-align cho nó

-> Mặc định text tràn khung sẽ tự xuống dòng, nhưng 1 từ dài quá 1 dòng sẽ k cắt.
word-wrap xử lý cut text như nào, dùng break-all sẽ cut được chữ dài => bỏ, thế bằng word-break
word-break y hệt word-wrap nhưng cung thêm break-all. break-all thì 1 chữ k đủ dòng vẫn viết tiếp, mặc định thì chữ k đủ phần còn lại sẽ xuống dòng sau
line-clamp: giúp hiển thị quá bnh dòng thì mới cut, react phải dùng là WebkitLineClamp / -webkit-line-clamp
VD: 
1) abcde trong khung max 5 chữ thì word-wrap break-word đảm bảo hiện là:
abcd
e
2) ab def thì word-break keep-all hiện là:
ab
def
vì nó kbh là cắt chữ
3) ab def thì word-break break-all hiện là
ab de
f
hiển thị như bth vì nó chỉ xuống khi tràn
4) ab defghi ac và muốn nó vừa có kiểu bảo toàn chữ tràn khi full width, vừa break word nếu word quá dài kiểu:
ab
defgh
i ac
=> word-wrap/word-break: break-word; 



# Metadata SEO
<title> <meta name="description> <meta name="keywords"/>
<link rel = "canonical" href = "http://example.com/"/> => thông báo cho search engine URL này là trang chính và tránh lập chỉ mục với URL của các trang trùng lặp khác
Đủ alt cho hình ảnh
<meta name = "robots" content = "noindex, nofollow"> => Có nghĩa là không lập chỉ mục hay không theo dõi trang web này.
<meta name = "robots" content = "index, follow"> => Có nghĩa là chỉ mục và theo dõi trang web này

Open Graph tags liên kết với các social media: <meta property = "og: type" content = "article" />
<meta property = "og: title" content = "TÊN TIÊU ĐÊ HOẶC TRANG WEB" />
<meta property = "og: description" content = "MÔ TẢ CỦA TRANG NỘI DUNG" />
<meta property = "og: image" content = "LIÊN KẾT ĐẾN TẬP TIN HÌNH ẢNH" />
<meta property = "og: url" content = "PERMALINK" />
<meta property = "og: site_name" content = "TÊN TRANG WEB" />

Twitter tag tương tự nhưng chỉ dành cho twitter: <meta name = "twitter: title" content = "TÊN TIÊU ĐỀ HOẶC TRANG WEB">
<meta name = "twitter: description" content = ”"MÔ TẢ TRANG NỘI DUNG">
<meta name = "twitter: image" content = "LINK TO IMAGE">
<meta name = "twitter: site" content = "USERNAME">
<meta name = "twitter: creator" content = "@ USERNAME">

-> <meta name="viewport" content="width=device-width, initial-scale=1.0"> => Luôn có thẻ này để cho phép người dùng zoom-in text, điều này phù hợp với những người thị lực yếu vào website, họ sẽ phải dùng các tool giúp zoom to trang web để nhìn rõ, VD CTRL+ của browser. Custom:
<meta name="viewport" content="user-scalable=yes"/> cho phép người dùng sử dụng các tool zoom cho trang web
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=1"/> chỉ cho max scale đến 200%
<meta name="viewport" conent="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/> => k cho zoom vì sợ break design
=> 1 số thiết bị có tính năng zoom text only, nhưng nếu text zoom to mà layout k zoom sẽ break design, do đó code height của thẻ nên phụ thuộc vào content chứ k được fix cứng

-> Nên dùng senmatic element sẽ tốt cho SEO vì tạo cấu trúc nội dung rõ ràng hơn cho search engine hiểu.
header và footer ở đầu cuối page; figure chứa img và figcaption; nav tạo navigation; aside tạo content related indirect to main; main chứa các article; article có các section; section có detail, detail có content bth và 1 thẻ summary; time biểu diễn thời gian và mark để highlight important text
Các thẻ heading h1 h2 ... chỉ nên dùng cho heading chứ k chủ động dùng để tạo big text vì search engine dùng heading để đánh index cho nội dung page
=> 1 số thẻ có thể có tính chất đặc biệt như thẻ time có thể dùng attribute. VD: <time datetime="2008-02-14 20:00"> thì thời gian trong attribute này sẽ được dịch sang machine-redable format và browser có thể thêm date này vào reminder của user's calendar nếu có và search engine cũng cho kết quả search thông minh hơn



# 3D 2D transform
Chỉ có: translate(1,2), rotate(20deg), scale(1,2), skewX() có thể dùng trực tiếp mà k cần transform
Dùng transform-origin set tâm

Hàm translate có 1 điểm đặc biệt là khi lùi tương đối, nó lùi so với kích thước của chính nó chứ kp kích thước cha => cách để cho thẻ ra tâm thẻ khác
transform nhược điểm là vẫn chiếm vị trí cũ nên position relative ít dùng
VD: position relative top -50px và transform translateY(-50px) chả khác gì nhau. Thực tế translate nó boost graphical performance of browser vì nó ra đời sau.

-> transform-style: A chứa B thì xoay A, B cũng xoay theo. Vd thẻ A xoay trục Y 60 độ sẽ nhỏ lại và text bị méo, transform-style mặc định là flat khiến cho vị trí đó trở thành kích thước và vị trí của thẻ B luôn, nếu xoay B -60 độ thì nó xoay cái hình méo đó tiếp làm thẻ B nhỏ hơn nữa. transform-style preserve-3d thì thẻ B tách rời với thẻ A và k bị flat nữa nên xoay -60 độ quay trở lại kích thước và vị trí ban đầu

-> Perspective chỉnh kc từ mắt đến vật, mặc định nó nhìn từ rất xa. VD 1 hình vuông nghiêng mà nhìn từ kc xa sẽ thành hcn bth chứ k thấy độ lệch.



# CSS reset
* refer đến mọi thẻ và :root là refer đến cha của mọi thẻ. Trong react thì có thẻ id là root bao mọi thẻ khác.
Luôn set html và body từ đầu là 100% kích thước, overflow scrollbar

-webkit-touch-callout: none; => Khi touch và hold trên màn hình iOS hay Safari sẽ hiển thị callout(chú thích) thì có thể ta disable
user-select: none; => cản người dùng bôi đen, thg dùng khi với canvas hay ảnh chẳng hạn
box-sizing: border-box; 

-> Phân biệt unset, none, initial, inherrit: 
initial là lấy thông số kỹ thuật của css. Ít dùng vì nhiều cái default rất ảo. VD display có default là inline sẽ khiến mọi thẻ thành inline kể cả các thẻ div.
Vd: * { all: initial; }
=> Thực tế, default value của css property khác với default value của browser. VD div có default display nếu nói default value của browser.

inherit: lấy giá trị thuộc tính kế thừa từ cha. Vì mọi thẻ đều có mọi thuộc tính, nếu k set sẽ dùng default value property của browser.
unset: có parent thì set parent, nếu chưa từng set cho parent thì lấy initial valua. Initial là thông số kỹ thuật CSS ấy
none: k set giá trị và coi như k có giá trị đó luôn, 3 thuộc tính trên có với mọi thẻ còn none kp thẻ nào cũng có



# Dùng scroll
Cơ bản tạo scrollbar trong 1 box: cho box là inline-block, white-space nowrap, overflow-x auto, set width không được fit-content mà responsive màn hình, thẻ con bên trong phải set minWidth bằng kích thước của box.
Tức chỉ cần cho container kích thước nhỏ hơn content và set overflow có scrollbar là được.
=> refer tới "Projects / Tinkerbellgarden"

overflow: clip; kết hợp với overflow-clip-margin: 30px; để kiểm soát overflow vẫn tràn ra ngoài mà k chiếm thêm kích thước
overflow-scroll: Chèn thêm hàng loạt thẻ vào bên trên mà k thay đổi vị trí scroll, k bị đẩy scroll xuống.

-> Để nhảy đến 1 vị trí trên trang html: đặt id rồi tại thẻ nào ta dùng tag a href đến đó là được
scroll-behavior: smooth hay auto để nhảy đến hay trượt đến

-> overscroll-behavior: khi 2 scroll lồng nhau, cục bên trong scroll tới đích mà vẫn lăn tiếp chuột ở cục trong thì cục ngoài sẽ scroll (scroll chaining), contain để cản. Trên điện thoại tự có bounce effect, none để cản thêm bounce effect.

-> Có thể ẩn thanh scrollbar nhưng vẫn giữ nguyên chức năng

-> Dùng scroll-snap
- scroll-snap-type: x mandatory; xác định hướng và kiểu scroll. proximity là scroll tới mép card mới tự scroll vào đúng vị trí card, mandatory là trình duyệt tự snap theo từng điểm scroll mọi lúc theo cách ta dùng scroll-snap-align 
- scroll-snap-align là từng item sẽ có vị trí như nào với container bao nó. VD center là điểm giữa item trùng điểm giữa container, tương tự start và end. Điểm giữa của chiều nào tùy thuộc type dùng x hay y
- scroll-snap-stop: là khi lướt quá nhanh sẽ luôn dừng ở từng element(always) hay cho lướt qua(normal)
- Đôi khi ta k muốn chuẩn kiểu item hiển thị đúng ở 3 vị trí mà hiển thị ở hơi mé bên trái cách 1 vài pixel cơ thì:
scroll-padding dùng ở container sẽ cho mọi item bên trong được quyền hiển thị cách mép 1 khoảng bnh
scroll-margin dùng ở từng item sẽ cho phép cụ thể 1 item nào được phép hiển thị cách mép bnh
=> dùng được 4 chiều left right top down. Thường để kích thước container chia hết cho kích thước card bên trong



# BEM
BEM(Block-Element-Modifier) đem lại hiệu quả viết tên class hướng module, dùng mạnh trong sass.
Theo BEM, kbh dùng id mà chỉ có class và các class biểu diễn lồng nhau thì dùng với quy tắc kiểu.
VD: thay vì
  .menu { ... }
    .menu .item { ... }
    .menu .item.active { ... }
Ta dùng   
  .menu { ... }
    .menu__item { ... }
    .menu__item--active { ... }
=> để biểu thị item nằm trong khối block menu

VD: <a class="btn btn--orange" href="#">
  <span class="btn__price">$9.99</span>
  <span class="btn__text">Subscribe</span>
</a>
và file css: .btn { ... }
.btn__price { ... }
.btn__text { ... }
.btn--orange { ... }



# Kích thước khoảng cách trong CSS
-> auto do browser tự tính, chiều dọc lấy 0, chiều ngang lấy hết phần có thể lấy, nếu có nhiều cái cùng auto thì chia đều giá trị cho từng cái => Cần nếu muốn kích thước 1 thẻ bị kéo dài theo thẻ cha tự lấp đầy vào khoảng trống
Hàm calc có thể tính các kiểu như 50% - 10px là 50% thẻ cha giảm 10px là bnh

-> Đơn vị tuyệt đối: Chỉ đúng trên các thiết bị độ phân giải cao như máy in, còn trên laptop và di động kết quả cho có thể sai khác. VD 1in = 96px = 2.54 cm

Relative Units
em: tương đối so với font-size của phần tử cha
ex: Tương đối so với chiều cao chữ "x" của font hiện tại.
ch: Chiều rộng của ký tự "0" trong font đang dùng
*rem (root em): Giống em, nhưng là tương đối so với phần tử gốc, thường là <html>.
*vw: Tương đối 1% width của kích thước cửa sổ trình duyệt (viewport).
*vh: Tương đối 1% height của kích thước cửa sổ trình duyệt (viewport).
vmin Relative to 1% dựa trên chiều nhỏ hơn của trình duyệt. VD điện thoại xoay dọc thì vmin sẽ là 1% của width
vmax Relative to 1% dựa trên chiều lớn hơn của trình duyệt
*%: Có giá trị tương đối so với phần tử cha.

VD thuộc tính có thể thay đổi phức tạp, ta k muốn đổi thủ công mà đổi 1 chỗ thì các chỗ khác cũng đổi thì nên cho các thuộc tính phụ thuộc vào nhau. Chẳng hạn thẻ container có padding gấp đôi padding thẻ X thì set padding container là 10rem, padding thẻ x là 5rem chẳng hạn. Xong responsive fontsize của thẻ root là xong

--> Các đơn vị mới dùng riêng cho mobile như lvh, dvh, svh, svw 
vh là chiều cao cơ bản, k đổi 
lvh là chiều cao lớn nhất khi k có toolbar, svh là chiều cao nhỏ nhất khi có toolbar
dvh là chiều cao dynamic tự thay đổi khi toolbar ẩn hoặc hiện => luôn dùng

--> Trap: 1 thẻ có height 50% thì sẽ bằng 50% height thẻ cha. Nếu thẻ cha k set height tức tự vừa với thẻ con thì chả có gì nên là 0
Thế nhưng thẻ có padding-top 50% thì padding nó lại bằng relative theo chiều rộng. VD thẻ width 100px thì padding top 50% sẽ là 50px => thg dùng khi ta muốn padding nó thay đổi theo màn hình responsive chứ kp lúc nào cũng fix cứng, k cần dùng @media



## JS
# Basic
script tới file js ở cuối page để đảm bảo mọi component đã load xong

-> Thao tác với chuột clientX, clientY
window.scrollTo(0, document.body.scrollHeight); để scroll xuống vị trí dưới cùng của thẻ body
BigInt trong JS

-> Thao tác với file json:
Có thể dùng JSON làm nguồn cung data, lưu file config xong import vào file js dùng trực tiếp dưới dạng object
Có thể dùng JSON lưu function bằng function constructor

-> Tạo unique id với Date.now() trả ra milisecond từ epoch time nếu k quá khắt khe vì vẫn có xs trùng nếu có quá nhiều request lấy id cùng 1 lúc

-> VD string find 1 string khác: 
str1.trim().replaceAll(",","").replaceAll(".","").toLowerCase().includes(str2.trim().replaceAll(",","").replaceAll(".","").toLowerCase());
Thay vì dùng str1 + str2, nên dùng `${str1}${str2}`



# Dùng biến global 
BOM(Browser Object Model) là thứ cho phép ta thao tác với browser như cookies, history, window, screen, navigator, location.
Có thể xem trạng thái load của document, tình trạng pin, tốc độ internet, onerror để handle window error, có chuyển tab, bật devtool



# Dùng Map thay if else và switch case:
if else là cấu trúc bậc thang
switch case nhanh hơn if else đáng kể khi số lượng điều kiện lớn. Mỗi điều kiện k phụ thuộc vào điều kiện trước đó nên thực hiện như mạch logic sẽ nhanh hơn.
=> Tuy nhiên trong Js khi muốn search theo key nên dùng new Map là nhanh nhất. Map là 1 instanceof Object nhưng sinh ra để search nhanh hơn, nên dùng thay thế



# Cơ chế WeakMap dọn rác
Các biến k thể truy cập được sẽ tự bị GC dọn. VD: user = { name: "John" }; user = null; thì object {name: "John"} k còn được ref bởi biến nào khác sẽ tự giải phóng vùng nhớ
GC sẽ tự được scheduled và dọn rác vào lúc rảnh.

-> WeakMap và WeakSet
Do cơ chế dọn rác, nếu mảng có 1 phần tử là 1 object chẳng hạn thì dù object mất reference nhưng mảng vẫn còn phần tử đó thì object vẫn k bị giải phóng vì vẫn refer được với array[index]. Điều này là đúng nhưng trong TH dùng map với set, có thể ta muốn nó tự động bị xóa với WeakMap, WeakSet
- WeakMap thì key buộc là object và khi reference đến object bởi 1 biến khác k còn thì sẽ tự bị xóa.
Do GC k rõ thời gian chạy nên k thể truy cập vào số lượng phần tử hay duyệt các phần tử của WeakMap. Chỉ có has delete get set. 
- WeakSet giống set nhưng chỉ nhận object, tự bị xóa khi k còn reference từ ngoài, cũng k hỗ trợ size keys hay các kiểu duyệt
VD 1 biến WeakMap lưu thông tin của người dùng, khi người dùng leave thì tự xóa, nếu dùng map bth phải xóa thủ công hoặc chờ biến map giải phóng. Tức là ta dùng khi cần dùng map với set, mà k cần dùng length hay duyệt, mất reference bên ngoài là tự xóa tối ưu bộ nhớ.



# Closure function
Function 1 return ra function 2, thì function 2 dùng biến khởi tạo trong function 1 được dù function 1 đã kết thúc, biến đó là 1 single instance phạm vi sẽ thuộc về function 2
Function trong 1 class, return 1 function khác. Biến this trong function sẽ k còn là class bao ngoài nữa, phải dùng bind hoặc arrow function để this dính sát cái bao nó

-> this mặc định global là window
Trong mọi TH, dùng arrow function thì this sẽ trỏ cái bao ngoài cái hiện tại(object, class, window,..)
bind call apply sẽ xác định rõ biến this nhưng vẫn cùi hơn arrow function
this dùng bth trong hàm or class sẽ trỏ vào đối tượng đó như 1 object có constructor
Truyền this vào sự kiện trong code html thì this là code thẻ tag đó
with(this) { ... }

-> Dùng call bind apply
Dùng bind có điểm lơi là return 1 function mới với giá trị biến this xác định mà có thể tái sử dụng gọi function đó nhiều lần
call và apply giống nhau chỉ khác cú pháp: o.call(this, args1, args2) và o.apply(this, [args1, args2]); là khi gọi mới gán giá trị this là gì, k thể tái sử dụng.



# Dùng sự kiện JS
Sự kiện hay dùng: https://freetuts.net/su-kien-event-trong-javascript-368.html
3 cách: dùng ở tag html; code js là element.onclick = () => { }; element.addEventListener("click", () => { });

-> onmouseenter khi hover vào element(dùng thay thế :hover tạo animation cho React được); onmouseover cũng tương tự nhưng điểm khác là onmouseenter k bubble bắn ra again khi mouse trỏ vào child element, onmouseover thì có.

-> addEventListener
Tham số 3 là useCapture, ngược với bubbling. Khi 1 event trigger luôn chạy theo thứ tự Capture phase rồi đến Bubbling phase, từ cha đến con. Khi chạy, thấy thẻ nào bắt capture hay bubbling mà chạy event thẻ đó tương ứng. Có thể dùng object { capture: true, once: true }

removeEventListener cũng chạy Capture phase trước rồi đến Bubbling phase. Tham số thứ 3 boolean tương tự, có thể dùng object {capture: false}
Nếu đăng ký với once hoặc passive, remove phải có once và passive

passive: true => Báo là sẽ k chạy event.preventDefault() và browser có thể xử lý ngay lập tức, cải thiện hiệu suất. Mặc định hiệu suất bị giảm khi browser xử lý event vì luôn phải đợi xem event.preventDefault có được gọi hay không.



# Dùng mảng và object và hàm 
Chuyển từ string sang array: [..."Hello"];
Hàm Array.from(iterable, function); giúp tạo array cực mạnh
Cách khác lấy params của function ít dùng là dùng for(var x of arguments) {<>}
Các hàm biến hóa mạnh: splice, copyWithin, flat

-> Sort array giảm dần: arr.sort(function(a, b){return b-a});
Cách nhớ: trả true thì giữ thứ tự(a, b) tức a < b, trả false thì đổi b < a

-> Cách shuffle 1 array
Lodash có hàm shuffle
Dùng 0.5 - Math.random() k hoàn toàn random nhưng có thể dùng nếu k yêu cầu khắt khe
Dùng Fisher-Yates alg, cơ chế là sinh số random nguyên để hoán đổi vị trí các phần tử trong array

-> Vòng for of chỉ dùng với các biến iterable. Vd k dùng được với object vì object không iterable, phải dùng hàm Object.entries.
Vòng for in dùng được với biến và mảng bình thường nhưng 1 số kiểu IterableIterator như entries, values của Map hay Set lại k dùng được
forEach chỉ dùng cho mảng vì nó thuộc Array.prototype

-> Hàm map tạo ra 1 mảng mới và k thay đổi trên mảng cũ nên phải gán bằng. 
2 tham số: 1 là function(currentValue, index, array), 2 là thisValue là giá trị pass vào function để dùng từ khóa this. Tuy nhiên để dùng được đối số 2 thì đối số 1 k được dùng arrow function, nếu k this sẽ luôn là cái bao ngoài hàm. 
VD: var object = { id: 1 }; const item = [1,2,3].map(function(currentVal, index, arr){ return currentVal + this.id + arr[index]; }, object); // [3, 5, 7]



# OOP
Nếu có thể nên dùng class thay vì function hay object trong JS 
VD: 
function Animal() { this.name= "a"; }
Animal.prototype.test = () => { console.log("test"); }
Tương đương với:
class Animal {
  constructor(){ this.name = "a"; }
  test = () => { console.log("test"); }
}



# Tạo extension browser bằng JS
-> Để thêm extension vào browser: bật developer mode -> load unpacked folder chứa file manifest extension.

-> 1 extension cho browser cần tối thiểu 1 file manifest.json cung cấp thông tin mà thôi. Như v thì chưa làm gì cả, phải viết thêm các script chức năng:
Content script: là những đoạn mã sẽ chạy trên trang web đang xem -> dùng với "content_scripts"+"js"
Background script: thực hiện ngầm extension, nhận message từ content script or extension khác => dùng bằng "background"+"scripts"
UI Elements: thành phần giao diện người dùng thg là hộp thoại popup hiện ra khi ấn vào icon của extension => vd dùng với "browser_action"+"default_popup"
=> Background script bắt đầu thực hiện khi ta ấn vào biểu tượng extension, content script tự thực hiện khi ta load 1 trang web mới

persistent xđ trang background đc chạy như thế nào
Dùng "scripts":[".js"] or "page":".html" vói file html chỉ có 1 thẻ script thêm code js vào
default_popup dùng để hiển thị file html khi mở extension
js là danh sách các file js được inject vào trang web nên file js luôn trong 1 mảng còn html là ""
matches xác định trang web muốn thêm nội dung và0, dùng regexp: "*://*/*" sẽ dùng với mọi trang web



# Dùng FormData
-> Có thể upload multiple file lên server với tag <input type="file" multiple>
Nạp nội dung vào thẻ input -> tạo 1 form -> lấy nội dung files trong thẻ input -> nhét files đo vào form -> nhét nó vào phần body vói method POST lên server. VD:
var formData = new FormData();
var photos = document.querySelector("input[type='file'][multiple]");
formData.append('title', 'My Vegas Vacation');
formData.append('photos', photos.files);
fetch('https://example.com/posts', {
  method: 'POST',
  body: formData
})
.then(response => response.json())
.then(response => console.log('Success:', JSON.stringify(response)))
.catch(error => console.error('Error:', error));
=> refer tới "Projects / Tinkerbellgarden"



# Dùng yield
Dùng yield chạy 1 hàm * nhiều lần thì chạy liên tiếp, còn k có * thì yield trả lấy được gì.
Nếu function* có return thì nó sẽ kết thúc luôn nên có thể dùng return để dừng hàm * vĩnh viễn khi thỏa mãn đk gì nhưng giá trị return về sẽ k được lấy ra.
function* gọi là generator function
yield* dùng được với mọi type iterative
Có thể dùng vòng for để duyệt yield function sẽ chạy liên tiếp mà k cần gọi next. Đây cũng là cơ chế của redux-saga, k cần gọi next mà đưa vào loop duyệt liên tiếp



# Dùng promise 
Promise chỉ coi là kết thúc khi gọi resolve hoặc reject.
Gọi new Promise(<>) thì bên trong promise sẽ thực hiện bất đồng bộ ngay khi được gọi tới. Chú ý phân biệt điều này với var a = function() và bên trong function mới return new Promise thì promise sẽ k thực hiện ngay vì function k được thực hiện thì chưa gọi tới promise.

-> Promise all trả về mảng kết quả đúng thứ tự với mảng input truyền vào
Promise.race tìm ra cái đầu tiên trả về true là lấy
Có thể dùng promise kết hợp với map



# setTimeout, setInterval, setImmediate
Nếu tham số 2 lơn hơn 2147483647 hoặc nhỏ hơn 1 thì sẽ tự động set về 1

-> Dùng setTimeout để sort => bỏ
const arr = [10, 50, 100, 500, 0, 200]; var arr1 = [];
function sortIt() {
  for (let i of arr) {
    setTimeout(()=> console.log(i), i);
    setTimeout(()=> {	
      arr1.push(i);
      arr.splice(arr.indexOf(i), 1);
      if(arr.length === 0)
        console.log(arr1);
     }, i);
  }
}

Vd: setTimeout(function(){
  alert("Chào mừng bạn đến với freetuts.net");
});
=> Thực hiện bất đồng bộ hàm sau 0s, thực tế nó k thực hiện ngay sau 0s mà phải chờ thực hiện Ct hiện tại đến khi stack trống để đẩy event vào và thực hiện callback event đó. Event Loop chỉ nhặt event từ queue vào stack khi stack trống.

-> Dùng setImmediate: tương tự setTimeout với 0s
setImmediate(<function>);
process.nextTick(<function>); => chỉ có trong NodeJS



# Fetch API trong JS thuần
Dùng XMLHttpRequest có sẵn của JS ít dùng
Dùng fetch của JS được tích hợp sẵn trong browser. Check fetch có dùng được k với: if(!('fetch' in window)){ }

fetch('<link có dữ liệu cần xử lý>', {optional object}); VD object { method: POST, headers: {"Content-Type:application/<>; charset=UTF-8"}, body: '<foo=bar>' }
VD Để xác thực thông tin: đối số 2 thêm { credentials: "include(same-origin/ omit)" } => là đi kèm cookie; same-origin là gửi request cùng nhà, omit thì k cho trình duyệt gửi thông tin xác thực. VD:
fetch(url, { 
  credentials: 'include'; // include là có gửi kèm thông tin xác thực cookie
})

-> Các response.type: basic nếu ứng dụng gửi request cho server cùng nhà, k có giới hạn vc xem thông tin trên response; cors: tức server và client cách xa nhau, lúc đó sẽ bị giới hạn, chỉ biết đc ít thông tin hơn.



# Other
-> Typescript sẽ ngăn các trường hợp kỳ lạ xảy ra, đảm bảo operator phải cùng type. Vd: ("b" + "a" + + "a" + "a").toLowerCase(); => banana

-> Polyfill là một đoạn mã (thường là JavaScript trên Web) được dùng để cung cấp chức năng hiện đại trên các trình duyệt cũ hơn vốn không hỗ trợ nó
VD IE8 k có hàm Array.prototype.includes, ta phải tự viết polyfill riêng để thực hiện chức năng đó. VD:
if (!Array.prototype.includes) {
  Array.prototype.includes = function includes(searchElement) {
    return this.indexOf(searchElement) !== -1
  }
}
Tương tự các hàm như Object.assign cũng nên check như v nếu ứng dụng yêu cầu tương thích nhiều trình duyệt rồi dùng như bth. Trên mạng đôi khi có thu viện polyfill để tải về dùng sẵn or nhờ chat GPT viết hộ

-> Cách che giấu source code frontend: Đang ở trang webA, khi load ta cho history.pushState sang đường dẫn khác (cùng host) thì khi mở view page source sẽ ra html của đường dẫn đó. Để đánh lừa thì ta nên cho 2 đường dẫn na ná nhau với chữ i viết hoa giống chữ l viết thường
Bắt khi người dùng vào devtool bằng JS và cho ẩn phần code JS đi là được. 
Dev khác vào web sẽ thấy source code là của web kia và k có code js nào cả

# Dùng counter-reset hiện số đếm tự tăng k cần JS
URL: https://www.youtube.com/watch?v=PL3Odw-k8W4



# Transform stream
1 loại stream xử lý data, pipe vào các stream khác như bth, dùng stream giúp tiết kiệm băng thông.

Vd tạo một TransformStream để chuyển đổi văn bản thành chữ hoa trước khi đọc nó thì dùng transform stream ở giữa để viết hoa chữ:
const transformStream = new TransformStream({
  start() {
    // Được gọi khi TransformStream khởi tạo
    console.log('TransformStream bắt đầu.');
  },
  transform(chunk, controller) {
    controller.enqueue(chunk.toUpperCase());
  },
  flush(controller) {
    // Được gọi khi toàn bộ luồng đầu vào đã được xử lý
    console.log('Đã hoàn thành chuyển đổi.');
  }
});
const readableStream = new ReadableStream({
  start(controller) {
    // Đẩy dữ liệu vào luồng
    controller.enqueue('hello');
    controller.enqueue(' world');
    controller.close();
  }
});
// Kết nối ReadableStream với TransformStream và tạo một WritableStream để ghi dữ liệu
readableStream
  .pipeThrough(transformStream) // Chuyển dữ liệu qua TransformStream
  .pipeTo(new WritableStream({
    write(chunk) {
      // Ghi ra phần dữ liệu đã biến đổi
      console.log(chunk);
    },
    close() {
      console.log('Đã ghi xong dữ liệu.');
    }
  }));

  

# Private custom variables trong css
VD Click chuột là đổi màu 1 vài thẻ: nên dùng css var trong :root và đổi giá trị khi click thay vì gán lại style từng thẻ

Thiết kế css var cho dự án lớn: dùng fallback var + kế thừa css var, đảm bảo css var được đinh nghĩa trong 1 scope tối ưu
VD: 
<div class="container">
  <div class="hello">
    <button>Hello</button>
    <p>Hello</p>
  </div>
  <div class="hi">
    <button>Hi</button>
    <p>Hi</p>
  </div>
  <div class="bye">
    <button>Bye</button>
    <p>Bye</p>
  </div>
</div>

-> Ngu:
.hello button {
  color: red;
}
.hello p {
  box-shadow: 1px 1px 1px red;
}
.hi button {
  color: blue;
}
.hi p {
  box-shadow: 1px 1px 1px yellow;
}
.bye .button {
  color: green;
}
.bye p {
  box-shadow: 1px 1px 1px red;
}

-> Dùng private custom variables tự định nghĩa với dấu _ ở dưới. 
.container {
  --_shadow: var(--shadow, red);
  --_color--text: var(--color, var(--color-text, red));
}
.container button {
  color: var(--_color--text);
}
.container p {
  box-shadow: 1px 1px 1px var(--_shadow);
}
.hi {
  --_shadow: yellow;
  --_color--text: blue;
}
.bye {
  --_color--text: green;
}
=> :root có thể list hàng loạt các variables làm style chung và chỉ cần sửa trong đó để tạo các theme khác nhau. Nếu k định nghĩa tự dùng fallback cho các private custom var. Đảm bảo tính kế thừa từ cao xuống
=> Các private var k ảnh hưởng tới scope khác. Nhìn custom var, ta hiểu ngay là đổi trong container của phần đó, thay vì tìm trên root, root chỉ đinh nghĩa các biến base
=> Giảm bớt số lượng selector. VD muốn đổi màu button trong bye thì đổi ngay css var của .bye thay vì viết selector ".bye button"

->***Bản chất: Css var thường dùng khi ta có các style phụ thuộc vào nhau, sau này muốn đổi sẽ phải đổi tất cả. Thay vì vậy sẽ gom vào 1 biến css và relative tói nó để đổi.
Trừ @media và @container mới fix cứng vì k dùng được css var, đồng nghĩa đổi chỗ khác cũng phải đổi nó



# Dùng css @scope và @layer, specifility
Specifility: @layer > @scope > thứ tự định nghĩa trong css => sai vì @scope k tăng specifility
@scope (article) to (aside :scope) {} => article tới thẻ cha là aside mà k tính thẻ cha tức là áp dụng cho thẻ con của article nếu article là con của aside trực tiếp => sai bỏ
@scope đơn giản là thay thế việc dùng nested selector bth, điểm khác biệt duy nhất là selector gốc của @scope không đóng góp vào specificity, tức làm giảm specificity.

-> CSS rule mặc định theo thứ tự đinh nghĩa trong css. @scope khiến cho nó theo thứ tự nested tag trong html. VD:
// index.html
<div class="container">
  <p class="text">Hello <button class="xxx">Button</button></p>
</div>
// index.css
p.text { color: red; }
.container p { color: white; }
=> Chữ sẽ là màu trắng vì 2 class cùng specifility sẽ theo thứ tự đinh nghĩa

@scope sẽ lấy css lên dần các thẻ cha cho đến khi gặp @scope gần nhất, gặp text thì k theo container nữa
@scope (.text) to (button.xxx) {
  :scope { } // tương đương với & { }
  p { color: red; }
  button { color: yellow; }
}
.container p { color: white; }
.container button { color: black; }
=> nhớ to (.not-these) { } vì cái trong to k tính 
=> ở đây lấy hết style ở ngoài vì specifility trong scope rất thấp do .text k tính

VD: @scope (.text) to (button.xxx, a, p[class]) { 
  // Code css
} 
=> tag nằm trong .text sẽ ưu tiên mang code css đó hơn ưu tiên hơn bth, nhưng nếu tag có dạng selector là button.xxx or a or p[class] sẽ inherrit, tức mang specifility thấp, chỉ dùng giá trị đó nếu bên ngoài k set style gì cho thẻ đó.

--> VD :scope dùng y như & được
@scope (article) to (> figure) {} => áp dụng cho mọi con của article, trừ con trực tiếp là tag figure
Tức @scope(aside) { @scope (article) { ... } }

--> Dùng trong HTML tag: k cần định nghĩa scope cho thẻ nào, tự hiểu là dùng cho thẻ bao sát thẻ style chứa nó, ở đây là @scope (article) { } nhưng chỉ với duy nhất thẻ article bao style này chứ k ảnh hưởng các article ngoài
<article>
  <style>
    @scope {
      & {
        color: red;
      }
    }
  </style>
  <p>Affected tag</p>
</article>
<article>
  <p>Not affected</p>
</article>

-> Specifility (0,1,1) theo thứ tự là: 
Số ID selector
Số class / pseudo class / attribute selector 
Số type selector / pseudo elements như :after, :first-letter
=> Thực ra là có 4 giá trị, còn 1 cái inline style mạnh hơn cả id selector css nữa. Chỉ có !important mới mạnh hơn inline style thôi.

Dùng & sẽ tính specifility chuẩn, dùng :scope sẽ coi cả cục :scope như 1 class, không tính các selector trước đó
VD: 
@scope (main .text) to (button.xxx) {
  :scope img { } // (0, 1, 1)
}
@scope (main .text) to (button.xxx) {
  & img { } // (0, 1, 2)
}
=> Vì & coi là thế từ cục trên vào thành "main .text img {}" => dùng & thì y hệt nested bth, còn dùng :scope thì y như khi k có :scope

VD: @scope (.parent) to (.content) {
  /* Styles written here will only affect .parent but skip .content*/
}

--> Bản chất specifility => càng specific, càng quan trọng
URL: https://specificity.keegan.st/
Cascade là đinh nghĩa sau sẽ đè lên định nghĩa trước. VD ta link file css sau <style> thì css trong file sẽ đè lên css trong tag <style>. Cascade chỉ đúng khi cùng specifility, nếu khác thì specifility cao hơn ở bên phải qua sẽ override. VD (1,0,0) đè lên (0,1,10)
VD: 2 cái cùng !important thì cái khai báo sau sẽ đè lên trước
=> Nên luôn dùng class, tránh dùng !important, #id, nested selector nhiều nhất có thể

-> Có 3 loại layer theo thứ tự đè nhau: user agent styles -> user styles -> author styles
user agent styles có sẵn style cho các thẻ theo setting kỹ thuật của browser, ta k thể đụng vào. Ta chỉ có thể tác động vào layer cuối là author style.
@layer giúp định nghĩa thêm các layer trong layer author styles.
Các layer sẽ có specifility độc lập, ngoại trừ 3 layer có sẵn, các layer tự tạo có specifility theo thứ tự định nghĩa. Cái khai báo sau đè cái trước, bất chấp specifility của các phần tử bên trong.

VD: viết style layer1 -> viết style layer2 -> viết thêm style cho layer1 => style layer2 sẽ đè lên mọi thứ của layer1 vì thứ tự khai báo layer2 sau layer1
VD: @layer framework, reset, base, layout, components; => nhét ở đầu file để khai báo thứ tự, thì khai báo bên dưới thế nào vẫn luôn tuân theo thứ tự này
=> Giải quyết TH khi cần custom style của framework sử dụng nhưng nó specifility k đủ để đổi, buộc phải thêm !important rất dở. Nếu thêm được style của framework vào @layer thì sửa ok

-> Code bên ngoài sẽ override code trong custom layer tự tạo ra, vì code bên ngoài thuộc author styles, còn code trong custom layer thuộc 1 layer con của author styles có spec nhỏ hơn
@layer có thể lồng trong @layer khác và quy tắc vẫn tương tự
@layer định nghĩa list thứ tự layer buộc phải để đầu file mới có tác dụng. 

@layer dùng trong scss như bth, cứ cho vào file là compile ra
Nhưng scss dùng @use phải luôn on top nên k thể định nghĩa @layer trước nó được, buộc phải nhét @layer vào 1 file scss riêng rồi @use nó ở đầu để xuất hiện ở đầu
1 case đặc biệt là @import có thể dùng bên trong @layer, nhưng @use thì không. Cách khác là:
@use 'sass:meta';
@layer base, components, utilities;
@layer components {
  @include meta.load-css('components'); // Thế cho @use 'components'
}



# Dùng @import trong css
@import trong css không sợ bị trùng code vì tuy trùng nhưng css tự có cơ chế override style cái sau đè cái trước. Cần tự code cẩn thận để k import nh lần.
@import của css cũng phải để ở top mới có tác dụng
@import trong css sẽ chạy tuần tự nên làm chậm quá trình tải trang => Do đó khi dev có thể dùng @import, còn production nên dùng bundler gom lại thành 1 file index.css và minify nó chứ k chia ra nhiều file. VD parcel build tự làm luôn
***@import url("./2.css") layer(base); => nhét mọi code trong 1 file css nằm trong 1 layer



# Dark mode thực tế có sẵn mà k cần phải code thủ công, trừ khi có màu nào phức tạp.
Vào web default sẽ theo setting của browser. Khi ấn đổi mode sẽ lưu localStorage và theo settings đó và luôn ghi đè setting browser.

-> Có 2 cách để set theme mode là dùng html { color-scheme: light dark; } tương đương với <meta name="color-scheme" content="light dark"> => Bỏ k dùng
Khi dùng cả 2 giá trị "light dark" như này là theo setting của browser.
Nếu set rõ ràng color-scheme: light; hay color-scheme: dark; sẽ dùng đúng mode đó.
Hàm light-dark(màu light, màu dark); sẽ trả về màu tương ứng tuỳ vào setting browser. Để dùng ligh-dark, phải có "color-scheme: light dark;" trong :root

-> style trong @media (prefers-color-scheme: dark) { } sẽ được áp dụng khi settings của browser là dark hoặc color-scheme trên là dark => Bỏ k dùng
K ổn vì nếu browser set dark thật thì style bên trong k thể mất, tức đổi sang light éo được. Buộc trong nó lại phải định nghĩa màu của cả 2 mode

-> Mặc định Canvas là màu của background, CanvasText là màu của text tự được thay đổi tuỳ vào mode hiện tại => Bỏ k dùng
VD có thể set trong từng thẻ để bảo 1 thẻ dùng mode nào
Để thêm sáng tối cho màu có thể dùng color-mix(in oklab, Canvas 75%, RebeccaPurple);

-> Cách tốt nhất là dùng JS: Check darkmode browser với window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; rồi lưu vào localStorage.



# Đỉnh cao dùng conic gradient tạo hình zigzag 
.loader {
  height: 47px; /* control the size */
  aspect-ratio: 5;
  background:
    conic-gradient(from 135deg at top,#000 90deg,#0000 0) top,
    conic-gradient(from 135deg at top,#0000 90deg,#000 0) bottom;
  background-size: 20% 50%;
  background-repeat: repeat-x;
}



# Tạo tab a11y
Khi chuyển trang, ưu tiên dùng thẻ a thay vì button. Còn single page thì dùng <a href="#idofelement"/>
Thay vì add event click vào từng thẻ, ta chỉ cần add vào thẻ container sẽ tự phát khi các phần bên trong bị click

-> Các thẻ chi tiết phải luôn dán nhãn, nhất là các thẻ chỉ có icon k có text mô tả:
Dùng với aria-label được: <button aria-label="Tìm kiếm">
Dùng với aria-labeledby khi cần 1 hoặc nhiều thẻ khác làm nhãn cho thẻ hiện tại. VD:
<p id="label1">Giỏ hàng:</p>
<p id="label2">Bạn có 3 sản phẩm.</p>
<div role="region" aria-labelledby="label1 label2">
  <!-- Nội dung -->
</div>

-> Để có a11y tốt khi dùng tab, đảm bảo ấn tab và mũi tên là có thể navigate được.
Cách dùng aria cho tabs: https://www.w3.org/WAI/ARIA/apg/patterns/tabs/

role="tablist", role="presentation", tabindex, role="tab", role="tabpanel"
Thuộc tính role sẽ loại bỏ ý nghĩa senmatic của thẻ, VD role="presentation" cho thẻ li chỉ định rằng phần tử có mục đích trình bày (decorative), không mang ý nghĩa semantic hay chức năng trong ngữ cảnh hiện tại, khiến cho thẻ li không còn biểu hiện cho list nữa, thẻ sẽ bị bỏ qua trong accessibility tree, công cụ hỗ trợ screen reader không đọc hoặc thông báo về nó.

Mặc định ấn key tab sẽ navigate qua mọi thẻ a trên page. Nếu dùng tabindex="-1" cho 1 thẻ sẽ bị bỏ qua khi nhảy tab. Nếu dùng tabindex="0" cho các thẻ khác như div thì nó sẽ nhảy vào cả các thẻ đó. Điều này tiện cho việc ấn key tab vào 1 tab, và ấn key tab tiếp sẽ vào content của tab kể cả div đó chứ k nhảy qua
Set bằng JS, ta cho mọi tab k active có tabindex="-1", tab đang active và nội dùng của nó có tabindex="0"

Thuộc tính hidden k chỉ ẩn thẻ đi mà cũng ẩn nó khỏi accessibility tree, tương tự display none. Còn visibility: hidden chỉ ẩn trên UI mà k ẩn trên accessibility tree. 
VD dùng display none / hidden + aria-hidden="false" => k hoạt động, sẽ ẩn khỏi tree. Dùng visibility hidden + aria-hidden="false" ok UI k có mà a11y vẫn hđ

aria-selected="true" bảo screen reader biết hiện đang ở tab nào, nó cũng tác động vào style tag nào là tag đang được chọn

aria-controls k nên dùng, nếu muốn thêm thông tin mô tả cho tab thì có thể dùng: aria-describedby="idofelement" và dùng 1 thẻ <div id="idofelement" aria-hidden="false" style="visibility:hidden;"></div> để thêm nếu cần. Nội dung của thuộc tính này được sử dụng khi ngừoi dùng vào tab đó và screen reader đọc nó lên cho ngừoi dùng nghe.

Ấn key left right để switch tab thì phải tự custom tạo hàm riêng thao tác với DOM thôi. Bắt sự kiện keydown.
Điều đặc biệt là khi ta add event keydown cho tabContainer thì chỉ khi ấn tab focus vào tabContainer thì keydown của nó mới bắt chứ ngoài màn hình gõ sẽ k ảnh hưởng

-> Tạo tab html thuần
- Mỗi tab nên ở cùng pages và k chuyển pages. Vì chỉ đổi tab nhưng mọi phần code html chung lại phải copy ra nhiều file.
Cũng phải lưu lại vị trí scroll với các state data khác vào sessionStorage, trước khi chuyển, và khi page onload phải lấy lại data rất rối.
- Đơn giản có thể viết nội dung tab hết 1 file rồi xử lý JS để display none hay hiện ra khi ngừoi dùng ấn vào tab
- Để chuyển tab có thể dùng label checkbox để bắt và hiển thị content bằng HTML CSS thuần, hoặc dùng JS luôn được. Có thể animation content hiện ra ok.
Có thể tạo animation slide từ 2 hướng khi chuyển tab, buộc phải dùng JS khi đó để xác định hướng cho animation, mỗi animation 1 keyframe riêng.
- Có thể dùng window.history.pushState để đổi url mà k chuyển page, kèm xử lý onload. Để khi chuyển page sẽ đổi url, gõ url vào sẽ hiển thị đúng đang là tag nào.
- Dùng kèm view transition api là thành animation đỉnh chóp

-> Nhanh chỉ cần set: aria-label, aria-labelledby, aria-describedby, aria-hidden, aria-selected, aria-controls, aria-current, aria-autocomplete (kèm input autocomplete), title, alt, role, aria-expanded
Icon thì nên có aria-hidden hoặc mô tả bằng aria label cho tag bao nó
aria-controls xác định quan hệ điều khiển, phần tử này điều khiển phần tử khác. Vd 1 button điều khiển dialog, menu, tab panel. Dùng label for để toggle thì k cần
VD: <button aria-controls="idofdialog">. Tương tự aria-expanded cho button ấn button là mở rộng gì đó, cập nhật bằng JS khi mở và đóng là true và false, nó thể hiện trạng thái hiện tại của dialog

--> Bộ 3 aria-errormessage, aria-invalid dùng cho thẻ input khi bị lỗi, aria-required báo input này k thể để trống:
<input id="email" type="email" aria-invalid="true" aria-errormessage="email-error" aria-required="true">
<span id="email-error" role="alert">Email không hợp lệ</span>
Bộ 3 aria-controls, aria-expand và aria-haspopup cho button thể hiện có menu hay danh sách thả hay hộp thoại:
<button aria-haspopup="dialog" aria-controls="login-dialog">
  Đăng nhập
</button>
<div id="login-dialog" role="dialog" hidden>
  <p>Vui lòng nhập thông tin đăng nhập.</p>
</div>
Bộ 2 aria-selected và aria-multiselectable báo có thể chọn nhiều options:
<ul role="listbox" aria-multiselectable="true">
  <li role="option" aria-selected="true">Mục 1</li>
  <li role="option" aria-selected="false">Mục 2</li>
  <li role="option" aria-selected="true">Mục 3</li>
</ul>
aria-readonly là 1 phần tử chỉ đọc k thể tương tác:
<label for="username">Tên đăng nhập:</label>
<input id="username" type="text" aria-readonly="true" value="user123">

-> pointer-events: none; sẽ cản sự kiện của 1 thẻ. VD ứng dụng navigation bar đang ở tab .active thì ấn vào sẽ k load lại chính trang hiện tại nữa có thể dùng.

-> Trong devtool browser có Elements Accessibility tool



# Tự tạo dialog css thuần hiện ra
-> <dialog> có thể mở đóng bằng HTML, CSS để style nhưng sẽ k có animation.
Dùng css thuần @starting-style và transition-behavior allow-discrete sẽ có animation nhưng k hoạt động với safari
Dialog là 1 loại popover và có thể dùng kèm API của popover => tạo ra dialog tự có click outside to close nhưng k hđ với safari.

--> Cách tốt nhất hoạt động với safari:
Dùng @keyframes và js event animationend thay vì @styles transition.
Ấn ra ngoài ẩn dialog thì bắt sự kiện click global rồi check target khác dialog để close dialog thay vì dùng dialog + popup.

-> Vấn đề mở dialog thì cản scroll, vị trí scroll ngoài phải giữ nguyên khi tắt dialog, content k bị di chuyển sang trái khi mở, hoạt động trên cả mobile.
- Dùng <dialog> vốn tự cản scroll rồi
- VD: html:has(dialog[open]){
  overflow: hidden;
  padding-right: 15px;
}
=> padding-right bằng kích thước scrollbar, default là 15px nhưng nên set width ::-webkit-scrollbar để đảm bảo cũng bằng kích thước 15px => Giải quyết vấn đề 3 nhưng 2 thì vẫn mất vị trí scroll, trên safari iOS vẫn bị lỗi content dịch chuyển
- VD: html:has(dialog[open]){
  position: fixed;
}
=> Tương tự nhưng safari iOS chạy ngon. Vấn đề duy nhất là mất vị trí scrollbar.
- Cách hoàn hảo nhất là làm như VD trên nhưng thêm 1 biến css lưu vị trí scroll bằng event "scroll", khi đóng dialog thì dùng JS jump tới là được.

-> Scrollbar hiển thị: nên cho background transparent chỉ hiện mỗi thumb
Nếu muốn scrollbar luôn hiện "overflow: scroll;" => ok
Nếu muốn scrollbar luôn chiếm kích thước kể cả khi k hiện "scrollbar-gutter: stable". Điều đb là nó bằng đúng kích thước width set của ::-webkit-scrollbar => k dùng vì khi kết hợp position fixed dialog khiến scrollbar-gutter k chiếm nx
Tối ưu là khi k overflow thì k hiện scrollbar nhưng scrollbar vẫn chiếm kích thước bth kể cả position fixed dialog => k làm được trừ khi tự tạo thẻ scroll



# How to design website
https://teleporthq.io/ai-website-builder => AI giúp thiết kế website basic
Hocoos AI Website Builder => AI cực mạnh tạo website và có code luôn, có hosting luôn, multiple pages
Leia AI website builder => AI tạo website, k có code, hosting luôn
Pineapple AI => AI tạo website và hosting, k có code, nhưng free plan chỉ tạo được 1 
KLeap AI Website Builder => AI tạo website, k có code, có hsosting, tạo responsive mobile luôn

Cắp ý tưởng trên figma hoặc các trang web đã có, nhưng website thiết kế ra phải đảm bảo có 1 theme đồng bộ giữa các pages. Có tool chuyển website to figma.
Tuân thủ color rules

-> Exp: Phần header phải dóng được xuống phía content bên dưới, hoặc content ngay bên dưới là fullscreen, nếu không sẽ rất xấu. Tương tự các section cần align theo chiều dọc bằng nhau
Hero section: Chữ nên được tương phản với ảnh background và có kích thước vị trí nổi bật, có thể phóng to thu nhỏ từng phần, uppercase chữ nổi bật, cho núp sau ảnh object. Ảnh nên được upscale rõ, ít khi cho tối hay mờ đi, có thể dùng gradient nếu cần nổi bật chữ
Navigation: text navigation và logo nên cùng màu, logo nên gọn gàng vào
Các phần phải đồng bộ nhau. VD trang có 3 cái header thì cả 3 nên có cùng 1 style
Cân bằng giữa lượng ảnh và text, k nên để text dài cả 1 dòng, nếu buộc có đoạn văn dài thì nên chia ra nhiều paragraphs nhỏ thôi, nên vắn tắt ít chữ nhất có thể
Nếu có nhiều card đi kèm nhau, các card nên có cùng size, k nên cái cao cái thấp. Tạo độ tương phản cho heading text và details text bằng color, fontsize, fontweight
Button trong card thường đồng bộ và nằm ở 1 phía, k chiếm full kích thước

-> AI giúp design component như figma: https://www.youtube.com/watch?v=iSReYz7B4i0
URL: https://creatie.ai/files/home

-> New morphism : kiểu design tạo clean effect rất ảo
Glass morphism dùng với backdrop-filter blur + 1 lớp kính rgba mỏng
Skeuomorphism hình thực tế => k dùng
Flat design: web như 1 mặt phẳng với hình vẽ đơn giản, k có shadow hay hiệu ứn nổi lên gì cả
Material design mở rộng của flat design, có hiệu ứng nổi lên mọi nơi. Màu và shape cần thay đổi. Mọi chuyển động phải liên tục, k đột ngột ẩn hiện.
Retro/Vintage Styles: web phong cách tinh tế, cổ kính, sang trọng, quý tộc, cổ điển. 
Brutalism design: web hiệu ứng mạnh, thô mộc, tương phản cao, font chữ nhiều lúc rất ảo
Minimalism: chỉ hiển thị các thứ cần thiết, k có gì thừa thãi, đơn giản, có thể đơn sắc, là loại web dễ tạo và dễ nhìn nhất.
Vaporwave design: web dùng tông màu neon như hồng, tím, xanh dương kiểu biển hiệu quảng cáo điện tử, video game, hoài cổ. VD thena.fi mới chỉ có 1 chút vaporwave thôi
Memphis design: dùng màu sắc sống động với các dạng hình học, ký tự đa dạng không đối xứng sắp xếp trừu tượng ngẫu hứng, trông như được xếp ngẫu nhiên. 



# Dừng
{ display: list-item; list-style-position: inside; } để hiển thị thẻ dạng list. Còn có display: table;
Tạo polygon responsive thuần: https://css-tricks.com/hexagons-and-beyond-flexible-responsive-grid-patterns-sans-media-queries/
@property và css houdini can thiệp sâu vào animation, view-timeline-axis, view-timeline-direction
https://www.frontendmentor.io/ => học Fremaster
https://courses.kevinpowell.co/view/courses/conquering-responsive-layouts/233002-introduction/1007804-intro-why-the-course-is-formatted-in-this-way => khoá học responsive uy tín (hieucuopbien123@gmail.com - 180101)
Design trend: Hover chuột thì card glowing border, sáng card đó và tối cả container, nghiêng card, vật thể to lên tràn ra ngoài card. https://glow-cards.webflow.io/
https://css-tricks.com/positioning-text-around-elements-with-css-offset/ => tạo text di chuyển xung quanh element với offset
https://www.youtube.com/watch?v=qTfQUXCPA2o => inverted border dùng thêm tag
https://www.youtube.com/watch?v=dbaOq7F5msU => inverted border dùng mask phải có ảnh
https://www.youtube.com/watch?v=Fu4Pl5k-3yQ => dùng mix-blend-mode để đè các layer ảnh, animation ảnh như đang chuyển động, tạo layer và animation với layer bằng clip-path
@function in css và if()
https://www.youtube.com/watch?v=VA975GOUFmM => css new feature
https://www.youtube.com/watch?v=tNBufpGQihY => selectedcontent css new feature

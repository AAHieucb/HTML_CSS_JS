# Dark mode 
Ta nên để default vào web sẽ theo setting của browser. Khi ấn đổi mode sẽ lưu localStorage và theo settings đó và luôn ghi đè setting browser.

-> Css có sẵn darkmode là dùng html { color-scheme: light dark; } tương đương với <meta name="color-scheme" content="light dark"> => Bỏ k dùng
Khi dùng cả 2 giá trị "light dark" như này là theo setting của browser.
Nếu set rõ ràng color-scheme: light; hay color-scheme: dark; sẽ dùng đúng mode đó.
Hàm light-dark(màu light, màu dark); sẽ trả về màu tương ứng tuỳ vào setting browser. Để dùng ligh-dark, phải có "color-scheme: light dark;" trong :root

-> style trong @media (prefers-color-scheme: dark) { } sẽ được áp dụng khi settings của browser là dark hoặc color-scheme trên là dark => Bỏ k dùng
K ổn vì nếu browser set dark thật thì style bên trong k thể mất, tức đổi sang light éo được. Buộc trong nó lại phải định nghĩa màu của cả 2 mode

-> Mặc định Canvas là màu của background, CanvasText là màu của text tự được thay đổi tuỳ vào mode hiện tại => Bỏ k dùng
VD có thể set trong từng thẻ để bảo 1 thẻ dùng mode nào
Để thêm sáng tối cho màu có thể dùng color-mix(in oklab, Canvas 75%, RebeccaPurple);

-> Cách tốt nhất là dùng JS: Check darkmode browser với window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; rồi lưu vào localStorage.



# Tự tạo dialog css thuần hiện ra
-> <dialog> có thể mở đóng bằng HTML, CSS để style nhưng sẽ k có animation.
Dùng css thuần @starting-style và transition-behavior allow-discrete sẽ có animation nhưng k hoạt động với safari
Dialog là 1 loại popover và có thể dùng kèm API của popover => tạo ra dialog tự có click outside to close nhưng k hđ với safari.

--> Cách tốt nhất hoạt động với safari:
Dùng @keyframes và js event animationend thay vì @styles transition.
Ấn ra ngoài ẩn dialog thì bắt sự kiện click global rồi check target khác dialog để close dialog thay vì dùng dialog + popup.

-> Vấn đề mở dialog thì cản scroll, vị trí scroll ngoài phải giữ nguyên khi tắt dialog, content k bị di chuyển sang trái khi mở, hoạt động trên cả mobile.
- Dùng <dialog> vốn tự cản scroll rồi
- VD: html:has(dialog[open]){
  overflow: hidden;
  padding-right: 15px;
}
=> padding-right bằng kích thước scrollbar, default là 15px nhưng nên set width ::-webkit-scrollbar để đảm bảo cũng bằng kích thước 15px => Giải quyết vấn đề 3 nhưng 2 thì vẫn mất vị trí scroll, trên safari iOS vẫn bị lỗi content dịch chuyển
- VD: html:has(dialog[open]){
  position: fixed;
}
=> Tương tự nhưng safari iOS chạy ngon. Vấn đề duy nhất là mất vị trí scrollbar.
- Cách hoàn hảo nhất là làm như VD trên nhưng thêm 1 biến css lưu vị trí scroll bằng event "scroll", khi đóng dialog thì dùng JS jump tới là được.

-> Scrollbar hiển thị: nên cho background transparent chỉ hiện mỗi thumb
Nếu muốn scrollbar luôn hiện "overflow: scroll;" => ok
Nếu muốn scrollbar luôn chiếm kích thước kể cả khi k hiện "scrollbar-gutter: stable". Điều đb là nó bằng đúng kích thước width set của ::-webkit-scrollbar => k dùng vì khi kết hợp position fixed dialog khiến scrollbar-gutter k chiếm nx
Tối ưu là khi k overflow thì k hiện scrollbar nhưng scrollbar vẫn chiếm kích thước bth kể cả position fixed dialog => k làm được trừ khi tự tạo thẻ scroll

->*** Với dialog, nên cho dialog trên điện thoại thì full màn hình or bottom sheet, dialog trên máy tính thì có 1 popup ở giữa. 
Trong react cho kiểu fullWidth={isMobile} sẽ ok hơn. Khi đó dialog buộc có 1 nút bấm để out ra chứ điện thoại k thể bấm ra ngoài.

-> Chốt: tạo dialog ấn ra ngoài là tắt
Bản gọn nhất là dùng css only với dialog + popover + @starting style cho dialog và ::backdrop => nhưng k tương thích mọi browser
HTML thuần dùng JS thì thêm class và bắt event animationend, tạo từng animation cho từng step bằng css. Dùng popover hoặc bắt event click window mà k click dialog thì ẩn đi
Trong react nên dùng thư viện tạo bottom sheet or dialog sẽ tự dùng portal. Hoặc tự custom div thay cho dialog và dùng portal. Nếu dùng css only với @keyframes, có thể tạo animation lúc mở chứ đóng thì éo được. Muốn tạo animation đóng buộc phải thêm JS y như html thuần thì k chuẩn trong react.



# Custom timeout cho fetch k hỗ trợ sẵn
const timeout = (ms, promise) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => { reject(new Error("Request timed out")) }, ms);
    promise.then(resolve, reject);
  })
}
const response = await timeout(1000, fetch("<url>"));
=> Thực tế các api cần xác thực nên dùng axios, còn các api allow anonymous thì dùng fetch luôn cho nhanh => nên thêm abort controller



# Dừng
{ display: list-item; list-style-position: inside; } để hiển thị thẻ dạng list. Còn có display: table;
css houdini can thiệp sâu vào animation, rendering, view-timeline-axis, view-timeline-direction mà trước đây k thể làm dược với css
https://www.frontendmentor.io/ => học Fremaster
https://courses.kevinpowell.co/view/courses/conquering-responsive-layouts/233002-introduction/1007804-intro-why-the-course-is-formatted-in-this-way => khoá học responsive uy tín (hieucuopbien123@gmail.com - 180101)
Design trend: Hover chuột thì card glowing border, sáng card đó và tối cả container, nghiêng card, vật thể to lên tràn ra ngoài card. https://glow-cards.webflow.io/
https://css-tricks.com/positioning-text-around-elements-with-css-offset/ => tạo text di chuyển xung quanh element với offset
https://www.youtube.com/watch?v=Fu4Pl5k-3yQ => dùng mix-blend-mode để đè các layer ảnh, animation ảnh như đang chuyển động, tạo layer và animation với layer bằng clip-path
@function in css và if()
https://www.youtube.com/watch?v=VA975GOUFmM => css new feature
https://www.youtube.com/watch?v=tNBufpGQihY => selectedcontent css new feature
https://css-tricks.com/worlds-collide-keyframe-collision-detection-using-style-queries/ => css thuần detect collision, animation với thẻ input range của html, @container theo style, tạo game thuần bằng css, @property
https://css-tricks.com/css-carousels/ => ::scroll-button tạo carousel bằng css only => nên dùng css only nhiều nhất có thể cho mọi thứ


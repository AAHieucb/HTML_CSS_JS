# Basic
script tới file js ở cuối page để đảm bảo mọi component đã load xong, hoặc dùng defer

-> Thao tác với file json:
Có thể dùng JSON làm nguồn cung data, lưu file config xong import vào file js dùng trực tiếp dưới dạng object
Có thể dùng JSON lưu function bằng function constructor

-> Biến global BOM (Browser Object Model) cho ta thao tác với browser như cookies, history, window, screen, navigator, location.

-> mousemove, mouseenter, mouseleave, mouseover (phát ra cả khi mới di chuyển vào child)

-> IntersectionObserver
Cho 1 biến IntersectionObserver lắng nghe 1 thẻ bất kỳ thì nó sẽ check nếu thẻ đó có giao với viewport thì gọi hàm tương ứng.
Chú ý nó chỉ tính phần hiển thị trên màn so với height của nó, tức VD thẻ lớn hơn màn hình thì không bao giờ đạt threshold 100% được. 
VD có 1 element cực dài và muốn làm kiểu scroll element xuống bao xa thì chạy hàm buộc phải làm thủ công window.onscroll
Nó cũng gọi callback ngay lúc đầu mới tạo dù k giao gì cả



# Chuyển hết về async await
-> Hàm callback
X(a, callback); => khi hàm X thực hiện xong sẽ truyền kết quả vào hàm callback ở cuối để xử lý. 
Thường hàm từ thư viện sẽ có sẵn phiên bản khác là async await. Vd: const x = await X(a); callback(x);

Nếu không có phiên bản async await, buộc phải truyền callback vào bth. Nếu callback là async, nó sẽ đi tiếp luôn và thực hiện song song hàm callback. Có thể ép chờ callback xong mới chạy xuống dưới:
const x = await new Promise((resolve, reject) => {
  X(a, async (err, result) => {
    if(err) reject(err);
    resolve(result);
  })
})
=> Bản chất: promise kbh kết thúc nếu như cái cục cuối cùng của nó k gọi resolve or reject. Vd ở đây ta xóa resolve hay reject đi thì hàm promise này sẽ kbh kết thúc. Ta dựa vào nó để ép hàm này dùng được await.

-> Promise: await X().then();
Chú ý promise khi call resolve hay reject, nó vẫn chạy tiếp phần code bên dưới, do đó ta nên return để tránh nó đi tiếp
=> Trong callback phải check if(err) tuỳ lib, promise vẫn phải .then().catch, còn async await phải có try catch. Do đó chuyển sang async await phải luôn nhớ try catch error

-> Event với on
Ta có thể biến thành Promise để dùng với async. Bằng cách cho resolve khi onsucess, reject với onerror:
new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    resolve(reader.result);
  };
  reader.onerror = (error) => {
    reject(error);
  };
  reader.readAsDataURL(file);
});



# Load file JS với async và defer
Browser load nếu thấy file js or script, sẽ dừng vc parse HTML để lý xử JS, gọi là Parse Blocking => default
Script attributes: async sẽ tải script bất đồng bộ trên 1 thread khác và tiếp tục parse trang, tải xong JS sẽ chạy; defer chỉ chạy khi html parse xong.
VD: Đang parse HTML CSS thì gặp 1 script async -> tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì vẫn chạy script luôn
VD: Đang parse HTML CSS thì gặp 1 script defer -> Tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì script k được exec -> parse HTML xong mới exec script 
Điểm lợi dùng defer là để script load ở đầu file vẫn đảm bảo thực hiện sau khi DOM load
=> Dùng defer là ok nhất, đặt script ở đầu thoải mái.

-> Nhanh: defer js tải song song với html và thực thi sau khi html parse xong; async tải và thực thi song song; Mặc định k có thì parseblocking tải và thực thi xong mới chạy tiếp

-> Nếu không xác định type="module" trong thẻ <script>, file JS sẽ được xử lý như một script thông thường, k có tính năng của module. Sự khác biệt:
Scope: Trong module, biến và hàm được khai báo sẽ có scope riêng, không bị rò rỉ ra toàn cục. Trong script thông thường, chúng sẽ nằm trong scope toàn cục.
Không thể sử dụng import và export trong script thông thường. Chỉ module mới hỗ trợ tính năng này.
Module đảm bảo tối ưu k bị tải nhiều lần dù import 1 module vào nhiều lần.
Module luôn chạy trong chế độ strict, trong khi script thông thường thì không => kqtr

-> Dùng type="module" đổi cách viết JS: Mặc định mọi thứ là toàn cục. Biến ta khai báo ở file JS này sẽ truy cập được ở file js khác miễn là script tới cả 2 file và script file khai báo được load xong trước
type="module" thì biến trong file đó k thể truy cập ở file khác, muốn là gì phải export import => nên luôn dùng type module, chỉ có code kiểu cũ mới k dùng



# URLSearchParams và URL
-> const myURL = new URL('https://example.com/path?name=chatgpt&age=25');
myURL.hostname => "example.com"
myURL.pathname => "/path"
myURL.search => "?name=chatgpt&age=25"
myURL.searchParams là URLSearchParams

-> const params = new URLSearchParams('?name=chatgpt&age=25');
params.get('name')
params.set('name', 'gpt-4');
params.append('lang', 'en'); => append sẽ thêm value vào key như mảng, set sẽ thay thế giá trị nếu đã có
params.getAll("lang");



# Thao tác với string
-> VD string find 1 string khác: 
str1.trim().replaceAll(",","").replaceAll(".","").toLowerCase().includes(str2.trim().replaceAll(",","").replaceAll(".","").toLowerCase());
Thay vì dùng str1 + str2, nên dùng `${str1}${str2}`

-> Regexp: 
.: Khớp với bất kỳ ký tự nào (trừ newline).
^: Khớp với đầu chuỗi.
$: Khớp với cuối chuỗi.
*: Khớp với 0 hoặc nhiều lần của ký tự trước.
+: Khớp với 1 hoặc nhiều lần của ký tự trước.
?: Khớp với 0 hoặc 1 lần của ký tự trước.
{n}: Khớp với đúng n lần của ký tự trước. {2,} là từ 2 trở lên
[]: Khớp với bất kỳ ký tự nào trong dấu ngoặc vuông.
|: Hoặc (OR).
VD lọc mail: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

--> Check string có thoả mãn 1 regexp hay không: 
const str = "Hello, World!";
const regex = /Hello/i; // Biểu thức chính quy để kiểm tra "Hello"
const isMatch = regex.test(str); // Kiểm tra



# Dùng mảng và object và hàm 
Chuyển từ string sang array: [..."Hello"];
Cách khác lấy params của function ít dùng là dùng for(var x of arguments) {<>}
Các hàm biến hóa mạnh: splice, copyWithin, flat

-> Tạo array:
Array(10).fill(undefined)
Array.from({ length: 10 });
VD: const numbers = [1, 2, 3];
const squares = Array.from(numbers, x => x * x);
console.log(squares); // [1, 4, 9]

Có thể ss 2 array chấp cả nested với: JSON.stringify(a1) == JSON.stringify(a2) => trừ TH undefined và null se coi là giống nhau

-> Sort array giảm dần: arr.sort(function(a, b){return b-a});
Cách nhớ: trả true thì giữ thứ tự(a, b) tức a < b, trả false thì đổi b < a

-> Cách shuffle 1 array
Lodash có hàm shuffle
Dùng 0.5 - Math.random() k hoàn toàn random nhưng có thể dùng nếu k yêu cầu khắt khe
Dùng Fisher-Yates alg, cơ chế là sinh số random nguyên để hoán đổi vị trí các phần tử trong array

-> Vòng for of chỉ dùng với các biến iterable. Vd k dùng được với object vì object không iterable, phải dùng hàm Object.entries.
Vòng for in dùng được với biến và mảng bình thường nhưng 1 số kiểu IterableIterator như entries, values của Map hay Set lại k dùng được
forEach chỉ dùng cho mảng vì nó thuộc Array.prototype

-> Hàm map tạo ra 1 mảng mới và k thay đổi trên mảng cũ nên phải gán bằng. 
2 tham số: 1 là function(currentValue, index, array), 2 là thisValue là giá trị pass vào function để dùng từ khóa this. Tuy nhiên để dùng được đối số 2 thì đối số 1 k được dùng arrow function, nếu k this sẽ luôn là cái bao ngoài hàm. 
VD: var object = { id: 1 }; const item = [1,2,3].map(function(currentVal, index, arr){ return currentVal + this.id + arr[index]; }, object); // [3, 5, 7]

-> Dùng tagged template
function tag(strings, ...values) {
  console.log("Chuỗi tĩnh:", strings);
  console.log("Giá trị nội suy:", values);
  return "Kết quả được tùy chỉnh!";
}
const name = "Minh";
const age = 25;
const result = tag`Xin chào ${name}, bạn ${age} tuổi.`;
console.log(result);
// Output:
// Chuỗi tĩnh: [ 'Xin chào ', ', bạn ', ' tuổi.' ]
// Giá trị nội suy: [ 'Minh', 25 ]
// Kết quả được tùy chỉnh!



# Dùng postMessage
Là API có sẵn giúp truyền message giữa trang web gốc với iframe dùng bên trong nó, hoặc mở 1 popup hay tab của web khác và truyền message giữa popup và web gốc khác host.

Bên gửi: targetWindow.postMessage(message, targetOrigin);
Bên nhận: window.addEventListener("message", function (event) {
  if (event.origin !== "http://localhost:8001/window-1") return;        
  alert(event.data);
});

window.opener giúp lấy trang gốc mở ra cửa sổ hiện tại
window.parent giúp lấy trang gốc chứa iframe hiện tại
=> Nhưng truy cập DOM phải cùng host vì browser có same site policy cản cả API và tương tác DOM. Muốn giao tiếp phải dùng postMessage



# Dùng Map thay if else và switch case:
if else là cấu trúc bậc thang
switch case nhanh hơn if else đáng kể khi số lượng điều kiện lớn. Mỗi điều kiện k phụ thuộc vào điều kiện trước đó nên thực hiện như mạch logic sẽ nhanh hơn.
=> Tuy nhiên trong Js khi muốn search theo key nên dùng new Map là nhanh nhất. Map là 1 instanceof Object nhưng sinh ra để search nhanh hơn, nên dùng thay thế



# Cơ chế WeakMap dọn rác
Các biến k thể truy cập được sẽ tự bị GC dọn. VD: user = { name: "John" }; user = null; thì object {name: "John"} k còn được ref bởi biến nào khác sẽ tự giải phóng vùng nhớ
GC sẽ tự được scheduled và dọn rác vào lúc rảnh.

-> WeakMap và WeakSet
Do cơ chế dọn rác, nếu mảng có 1 phần tử là 1 object chẳng hạn thì dù object mất reference nhưng mảng vẫn còn phần tử đó thì object vẫn k bị giải phóng vì vẫn refer được với array[index]. Điều này là đúng nhưng trong TH dùng map với set, có thể ta muốn nó tự động bị xóa với WeakMap, WeakSet
- WeakMap thì key buộc là object và khi reference đến object bởi 1 biến khác k còn thì sẽ tự bị xóa.
Do GC k rõ thời gian chạy nên k thể truy cập vào số lượng phần tử hay duyệt các phần tử của WeakMap. Chỉ có has delete get set. 
- WeakSet giống set nhưng chỉ nhận object, tự bị xóa khi k còn reference từ ngoài, cũng k hỗ trợ size keys hay các kiểu duyệt
VD 1 biến WeakMap lưu thông tin của người dùng, khi người dùng leave thì tự xóa, nếu dùng map bth phải xóa thủ công hoặc chờ biến map giải phóng. Tức là ta dùng khi cần dùng map với set, mà k cần dùng length hay duyệt, mất reference bên ngoài là tự xóa tối ưu bộ nhớ.



# Closure function
Function 1 return ra function 2, thì function 2 dùng biến khởi tạo trong function 1 được dù function 1 đã kết thúc, biến đó là 1 single instance phạm vi sẽ thuộc về function 2
Function trong 1 class, return 1 function khác. Biến this trong function sẽ k còn là class bao ngoài nữa, phải dùng bind hoặc arrow function để this dính sát cái bao nó

-> this mặc định global là window
Trong mọi TH, dùng arrow function thì this sẽ trỏ cái bao ngoài cái hiện tại(object, class, window,..)
bind call apply sẽ xác định rõ biến this nhưng vẫn cùi hơn arrow function
this dùng bth trong hàm or class sẽ trỏ vào đối tượng đó như 1 object có constructor
Truyền this vào sự kiện trong code html thì this là code thẻ tag đó
with(this) { ... }

-> Dùng call bind apply
Dùng bind có điểm lơi là return 1 function mới với giá trị biến this xác định mà có thể tái sử dụng gọi function đó nhiều lần
call và apply giống nhau chỉ khác cú pháp: o.call(this, args1, args2) và o.apply(this, [args1, args2]); là khi gọi mới gán giá trị this là gì, k thể tái sử dụng.

--> Bind chia được tham số kiểu này
function greet(greeting, punctuation) {
    console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'John' };
const greetPerson = greet.bind(person, 'Hello');
greetPerson('!');



# Dùng sự kiện JS
Sự kiện hay dùng: https://freetuts.net/su-kien-event-trong-javascript-368.html
3 cách: dùng ở tag html; code js là element.onclick = () => { }; element.addEventListener("click", () => { });

-> onmouseenter khi hover vào element(dùng thay thế :hover tạo animation cho React được); onmouseover cũng tương tự nhưng điểm khác là onmouseenter k bubble bắn ra again khi mouse trỏ vào child element, onmouseover thì có.

-> addEventListener: Khi addEventListener cùng 1 sự kiện nhiều lần sẽ chạy theo thứ tự được thêm vào chứ không đồng thời, nếu dùng các hàm async mới k chờ nhau mà chạy liên tục
Tham số 3 là useCapture, ngược với bubbling. Khi 1 event trigger luôn chạy theo thứ tự Capture phase (từ window đến đúng ptu đó) rồi đến Bubbling phase (từ phần tử đó lên cha), nó check sự kiện nào useCapture true sẽ xử lý trong capture phase, false mặc định sẽ chỉ xử lý bubbling phase. Có thể dùng object { capture: true, once: true }

removeEventListener cũng chạy Capture phase trước rồi đến Bubbling phase. Tham số thứ 3 boolean tương tự.

passive: true => Báo là sẽ k chạy event.preventDefault() và browser có thể xử lý ngay lập tức, cải thiện hiệu suất. Mặc định hiệu suất bị giảm khi browser xử lý event vì luôn phải đợi xem event.preventDefault có được gọi hay không.

event.stopPropagation() => dùng ở 1 sự kiện ở 1 thẻ sẽ cản trở event tiếp tục bubble up quá thẻ này trong bubbling phase



# OOP trong JS
Nếu có thể nên dùng class thay vì function hay object trong JS 
VD: 
function Animal() { this.name= "a"; }
Animal.prototype.test = () => { console.log("test"); }
Tương đương với:
class Animal {
  constructor(){ this.name = "a"; }
  test = () => { console.log("test"); }
}



# Dùng FormData
-> Có thể upload multiple file lên server với tag <input type="file" multiple>
Nạp nội dung vào thẻ input -> tạo 1 form -> lấy nội dung files trong thẻ input -> nhét files đo vào form -> nhét nó vào phần body vói method POST lên server. VD:
var formData = new FormData();
var photos = document.querySelector("input[type='file'][multiple]");
formData.append('title', 'My Vegas Vacation');
formData.append('photos', photos.files);
fetch('https://example.com/posts', {
  method: 'POST',
  body: formData
})
.then(response => response.json())
.then(response => console.log('Success:', JSON.stringify(response)))
.catch(error => console.error('Error:', error));
=> refer tới "Projects / Tinkerbellgarden"



# Fetch API trong JS thuần
Dùng XMLHttpRequest có sẵn của JS ít dùng
Dùng fetch của JS được tích hợp sẵn trong browser. Check fetch có dùng được k với: if(!('fetch' in window)){ }

fetch('<link có dữ liệu cần xử lý>', {optional object}); VD object { method: POST, headers: {"Content-Type:application/<>; charset=UTF-8"}, body: '<foo=bar>' }
VD Để xác thực thông tin: đối số 2 thêm { credentials: "include(same-origin/ omit)" } => là đi kèm cookie; same-origin là gửi request cùng nhà, omit thì k cho trình duyệt gửi thông tin xác thực. VD:
fetch(url, { 
  credentials: 'include'; // include là có gửi kèm thông tin xác thực cookie
})

-> Các response.type: 
basic nếu ứng dụng gửi request cho server cùng nhà, k có giới hạn vc xem thông tin trên response. Hoặc request mode "no-cors" và phản hồi là 1 simple origin
cors: Khi yêu cầu cross origin và server đã cấu hình CORS để cho phép truy cập.
"opaqueredirect" hoặc "opaque": éo xem được response, chỉ xem được vài header cơ bản

-> Trong fetch có option mode:
cors: mặc định, cho phép yêu cầu từ một nguồn khác (cross-origin) và gửi kèm header CORS. Nếu server không cho phép yêu cầu từ nguồn đó, trình duyệt sẽ chặn phản hồi => luôn dùng
no-cors: gửi yêu cầu đến một nguồn khác mà không cần kiểm tra CORS nhưng sẽ không thể đọc response. Chỉ dùng cho các yêu cầu đến các API không hỗ trợ CORS.
same-origin: Chế độ này chỉ cho phép gửi yêu cầu đến cùng một nguồn (same-origin). Nếu gửi yêu cầu đến một nguồn khác thì sẽ bị chặn.



# Dùng yield
Dùng yield chạy 1 hàm * nhiều lần thì chạy liên tiếp, còn k có * thì yield trả lấy được gì.
Nếu function* có return thì nó sẽ kết thúc luôn nên có thể dùng return để dừng hàm * vĩnh viễn khi thỏa mãn đk gì nhưng giá trị return về sẽ k được lấy ra.
function* gọi là generator function
yield* dùng được với mọi type iterative
Có thể dùng vòng for để duyệt yield function sẽ chạy liên tiếp mà k cần gọi next. Đây cũng là cơ chế của redux-saga, k cần gọi next mà đưa vào loop duyệt liên tiếp



# Dùng promise 
Promise chỉ coi là kết thúc khi gọi resolve hoặc reject.
Gọi new Promise(<>) thì bên trong promise sẽ thực hiện bất đồng bộ ngay khi được gọi tới. Chú ý phân biệt điều này với var a = function() và bên trong function mới return new Promise thì promise sẽ k thực hiện ngay vì function k được thực hiện.

-> Promise all trả về mảng kết quả đúng thứ tự với mảng input truyền vào, 1 cái failed sẽ lỗi và dừng luôn. Bản chất nó nhận các promise và trả ra 1 promise mới. Nếu 1 promise con bị failed thì promise ngoài sẽ reject luôn, k lấy được kết quả các promise thành công còn lại nữa.
Promise.allSettled tương tự Promise.all nhưng trả hết, error 1 cái cũng k dừng 
Promise.race trả về cái đầu tiên bất kể thành công hay lỗi
Promise.any trả vể cái thành công đầu tiên, nếu tất cả đều lỗi mới trả lỗi

Chú ý gọi resolve(new Promsie(<hàm>)); chạy được đến resolve sẽ thực hiện hàm luôn

-> Chốt khi nào chạy promise:
Function trả ra promise thì khi gọi function sẽ thực hiện promise luôn. 
Khi 1 promise lồng nhiều promise bên trong kiểu new Promise(<promise lồng>) thì cái ngoài thực hiện sẽ thực hiện hết các cái Trong
Biến gán = new Promise luôn thì gọi ngay lập tức khi chạy tới
Function trả ra function con, fucntion con trả ra promise thì khi nào gọi function con mới chạy promise như bth

-> Usecase: tìm best url trong list url
VD có 1 list rpc như nhau, cần chọn ra best url để gọi vào, rpc có thể chết bất cứ lúc nào.
Mỗi khi user vào trang web sẽ query thử 1 lệnh đơn giản (như getBlockNumber) cả list rpc với Promise.any xem cái nào trả nhanh nhất thì lấy
Nếu có lỗi mạng thì sẽ tự chọn second-best url query lại, ở FE thì khi refresh lại pages sẽ chọn lại url luôn.
=> ref tới projects "Vatra"



# setTimeout, setInterval, setImmediate
Nếu tham số 2 lơn hơn 2147483647 hoặc nhỏ hơn 1 thì sẽ tự động set về 1

-> Dùng setTimeout để sort => bỏ
const arr = [10, 50, 100, 500, 0, 200]; var arr1 = [];
function sortIt() {
  for (let i of arr) {
    setTimeout(()=> console.log(i), i);
    setTimeout(()=> {	
      arr1.push(i);
      arr.splice(arr.indexOf(i), 1);
      if(arr.length === 0)
        console.log(arr1);
     }, i);
  }
}

Vd: setTimeout(function(){
  alert("Chào mừng bạn đến với freetuts.net");
});
=> Thực hiện bất đồng bộ hàm sau 0s, thực tế nó k thực hiện ngay sau 0s mà phải chờ thực hiện Ct hiện tại đến khi stack trống để đẩy event vào và thực hiện callback event đó. Event Loop chỉ nhặt event từ queue vào stack khi stack trống.

-> Dùng setImmediate: tương tự setTimeout với 0s
setImmediate(<function>);
process.nextTick(<function>); => chỉ có trong NodeJS
Như nhau cả, chỉ là thứ tự thực hiện ưu tiên là process.nextTick > setImmediate > setTimeout 0s



# Web worker



# Dùng service worker
-> Dùng lưu cache offline, tắt browser bật lại vẫn có data, thậm chí là offline.
- Bắt sự kiện fetch, nếu request có trong cache thì lấy từ cache
- Bắt sự kiện install, lưu files nào vào cache.
- Bắt sự kiện activate xoá các cache không liên quan, chỉ để lại cache hiện tại. Ta cũng có thể update worker service bằng cách tạo 1 key mới và xoá cache key cũ.

Khi reload lại pages, sẽ k trigger lại event install và activate để setup lại worker, trừ khi file service-worker bị thay đổi. 
Tắt đi bật lại thì luôn setup lại worker, tức mỗi lần vào web lần đầu, đều setup lại service worker. Nói chung là file này cứ đổi là tự áp dụng nên k cần lo cũ.

-> Push notification: 
App request permission cho phép hiện thông báo, rồi bắt sự kiện push là khi có thông báo đến thì service worker show ra. Thông báo có cả trên máy tính hoặc mobile. Trên macos yêu cầu người dùng phải biến web thành ứng dụng ở homescreen r cấp quyền mới được.
Nếu chỉ FE, ấn nút hay làm gì thì gọi registration.showNotification để phát sự kiện push thôi.
Thực tế dùng server, có thể gửi thông báo bất cứ lúc nào. Server gửi thông báo đến PushService của trình duyệt (VD: Firebase Cloud Messaging cho Chrome), đăng ký API key. Rồi tuỳ ý trigger notification cho user từ server. Client có mạng sẽ tự nhận được thông báo.



# Other
-> Typescript sẽ ngăn các trường hợp kỳ lạ xảy ra, đảm bảo operator phải cùng type. Vd: ("b" + "a" + + "a" + "a").toLowerCase(); => banana

-> Polyfill là một đoạn mã (thường là JavaScript trên Web) được dùng để cung cấp chức năng hiện đại trên các trình duyệt cũ hơn vốn không hỗ trợ nó
VD IE8 k có hàm Array.prototype.includes, ta phải tự viết polyfill riêng để thực hiện chức năng đó. VD:
if (!Array.prototype.includes) {
  Array.prototype.includes = function includes(searchElement) {
    return this.indexOf(searchElement) !== -1
  }
}
Tương tự các hàm như Object.assign cũng nên check như v nếu ứng dụng yêu cầu tương thích nhiều trình duyệt rồi dùng như bth. Trên mạng đôi khi có thu viện polyfill để tải về dùng sẵn or nhờ chat GPT viết hộ

-> Cách che giấu source code frontend: Đang ở trang webA, khi load ta cho history.pushState sang đường dẫn khác (cùng host) thì khi mở view page source sẽ ra html của đường dẫn đó. Để đánh lừa thì ta nên cho 2 đường dẫn na ná nhau với chữ i viết hoa giống chữ l viết thường
Bắt khi người dùng vào devtool bằng JS và cho ẩn phần code JS đi là được. 
Dev khác vào web sẽ thấy source code là của web kia và k có code js nào cả

-> try catch error, hoặc có thể tạo wrapper function dùng then catch để custom trả ra [undefined, T] | [Error] cũng được (T là type của data).

-> Tạo unique id với Date.now() trả ra milisecond từ epoch time nếu k quá khắt khe vì vẫn có xs trùng nếu có quá nhiều request lấy id cùng 1 lúc


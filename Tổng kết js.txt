# Vanilla JS 
Best practice là chia mỗi page 1 file html css js. CSS dùng BEM.

-> Các cách chạy dự án vanillajs
Dùng HTML thuần với live server. Host thì đẩy file trực tiếp lên.
Dùng html thuần với live server nhưng tùy biến tự cài node_modules quản lý version hoặc cài qua CDN => phức tạp
Dùng bundler hỗ trợ hết như vite. Host phải chạy build => khó dùng vì code html trong JS.
Dùng bundler parcel như live server nhưng thêm đủ các tính năng build và start ở 1 port, cài package vào node_modules và import vào file js => best practice

-> Tối ưu cache fetched data để k fetch lại trong phạm vi 1 page
VD:
var MyApp = MyApp || {};
MyApp.globalData = {
  fetchedData: null
};
MyApp.fetchData = async function() {
  if (!MyApp.globalData.fetchedData) {
    const response = await fetch('your-data-source-url');
    MyApp.globalData.fetchedData = await response.json();
  }
  return MyApp.globalData.fetchedData;
};

-> Tối ưu load lần đầu:
document.addEventListener('DOMContentLoaded', ...); => khi toàn bộ HTML đã được tải xong, k chờ tài nguyên như ảnh, stylesheet.
window.onload => khi tất cả, bao gồm cả hình ảnh, stylesheet, và iframe tải xong.
=> useEffect chạy lần đầu tiên tương đương với DOMContentLoaded, cũng k chờ script và ảnh tải xong.

Ta muốn fetch data sớm nhất có thể, khi nào DOM load xong thì show ra thôi. DOM chưa xong thì chưa show, DOM xong và fetch chưa xong thì show loading. K được cho vào DOMContentLoaded vì khi đó, DOM phải load xong mới bắt đầu fetch.
VD để script js ở cuối:
<div id="data-container">Loading data...</div>
<script>
  let dataFetched = false;
  let domContentLoaded = false;
  let fetchedData = null;
  fetch('https://api.example.com/data')
    .then(response => {
      if (!response.ok) throw new Error('Network response was not ok');
      return response.json();
    })
    .then(data => {
      fetchedData = data;
      dataFetched = true;
      displayDataIfReady();
    })
    .catch(error => {
      document.getElementById('data-container').textContent = 'Failed to load data: ' + error.message;
    });
  document.addEventListener('DOMContentLoaded', function() {
    domContentLoaded = true;
    displayDataIfReady();
  });
  function displayDataIfReady() {
    if (dataFetched && domContentLoaded) {
      const dataContainer = document.getElementById('data-container');
      dataContainer.innerHTML = '<pre>' + JSON.stringify(fetchedData, null, 2) + '</pre>';
    }
  }
</script>

-> Convert React to Vanilla
--> React có onChange tương đương với event "input" trong vanilla trigger mọi lúc value gõ vào đổi. K dùng "change" chỉ trigger khi k còn focus vào ô input.
--> Dùng cơ chế pubsub tạo store để thực hiện hành động khi state đổi, tương đương useEffect
VD:
const store = {
  _value: { },
  effects: [],
  get value() {
    return this._value;
  },
  set value(newValue) {
    this._value = { ...this._value, ...newValue };
    this.effects.forEach(fn => fn(this._value));
  },
  subscribe(fn) {
    this.effects.push(fn);
  }
};
export default store;

-> Nhanh:
Dùng parcel
onload, DomContentLoaded
event input



# Load file JS với async và defer
Browser load nếu thấy file js or script, sẽ dừng vc parse HTML để lý xử JS, gọi là Parse Blocking => default
<script>: async sẽ tải script bất đồng bộ trên 1 thread khác và tiếp tục parse trang, tải xong JS sẽ chạy bth; defer chỉ chạy khi html parse xong.
VD: Đang parse HTML CSS thì gặp 1 script async -> tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì vẫn chạy script luôn
VD: Đang parse HTML CSS thì gặp 1 script defer -> Tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì script k được exec -> parse HTML xong mới exec script 
=> Best practice là đặt script ở đầu và dùng defer để đảm bảo exec sau khi DOM load.

-> Nếu không xác định type="module" trong thẻ <script>, file JS sẽ được xử lý như một script thông thường, k có tính năng của module.
- Trong module, biến và hàm được khai báo trong scope đó. Còn script bth thì biến không khai báo trong 1 block, sẽ là toàn cục, dùng mọi nơi miễn biến đã load xong.
- Module trao đổi biến qua export, tự tối ưu k tải nhiều lần dù import 1 module nhiều lần. Module cũng luôn trong chế độ strict, còn script thông thường thì không.
dynamic import cũng chỉ dùng trong module: await import("../index.js");

-> Nhanh:
default block, async, defer
type module có thể export biến local



# Bản chất repaint và reflow
Khi đổi thuộc tính element bằng js, browser sẽ tự nhận ra thay đổi này và tính toán lại styles cho phần tử bị thay đổi và các con của nó nếu cần.
- Reflow: nếu CSS đổi có ảnh hưởng đến bố cục (layout) của trang, browser sẽ thực hiện "reflow" để tính toán lại vị trí và kích thước các elements.
VD: box.style.width = '200px'; // Thay đổi kích thước (gây reflow và repaint)
- Repaint: sau khi reflow, nếu css đổi ảnh hưởng đến sự xuất hiện của các phần tử (như màu sắc, ảnh, đường viền), browser sẽ thực hiện "repaint" để vẽ lại các phần tử.
VD: box.style.backgroundColor = 'blue'; // Thay đổi màu sắc (chỉ gây repaint)
=> Chú ý là browser không repaint và reflow cả page mà chỉ với các phần tử cần thiết.

Reflow tốn tài nguyên, nên hạn chế số lần reflow bằng cách gộp:
VD: // Thay vì:
element.style.width = '200px';
element.style.height = '200px';
element.style.backgroundColor = 'blue';
// Dùng:
element.classList.add('new-style');



# Dùng promise và async
Luồng promise: khi gọi new Promise() sẽ chạy ngay, kết thúc khi gọi resolve/reject và cũng chỉ gọi resolve/reject được 1 lần thôi, sau đó vẫn chạy hết phần code bên dưới mới trả giá trị, nên nếu muốn dừng luôn phải thêm return sau đó.
VD resolve(new Promsie(<hàm>)) thì chạy đến resolve cũng thực hiện hàm luôn; khi promise lồng kiểu new Promise(<promise>) thì cái ngoài chạy sẽ thực hiện hết các cái trong.

-> Promise.all nhận input list promise, trả ra 1 promise mới trả 1 mảng kết quả đúng thứ tự input. Nếu 1 promise con bị failed thì promise tổng reject luôn.
Promise.allSettled tương tự Promise.all nhưng trả hết, error 1 cái cũng k dừng 
Promise.race trả về cái đầu tiên bất kể thành công hay lỗi
Promise.any trả vể cái thành công đầu tiên, nếu tất cả đều lỗi mới trả lỗi

VD usecase tìm best url trong list url: có 1 list rpc như nhau, cần chọn ra best url để gọi vào, rpc có thể chết bất cứ lúc nào => ref tới projects "Vatra"
Mỗi khi user vào web sẽ query thử 1 lệnh đơn giản trên cả list rpc với Promise.any, cái nào trả nhanh nhất thì lấy. Nếu có lỗi mạng thì sẽ call tìm url lại.

-> Chuyển hết về async await
- Hàm callback
X(a, callback); => khi hàm X thực hiện xong sẽ truyền kết quả vào hàm callback ở cuối để xử lý. 
Thường hàm từ thư viện sẽ có sẵn phiên bản khác dùng async await. Vd: const x = await X(a); callback(x);
Nếu không có sẵn phiên bản async await, có thể ép chờ callback xong mới chạy xuống dưới, vì promise kbh kết thúc nếu cái cục cuối cùng k gọi resolve or reject:
const x = await new Promise((resolve, reject) => {
  X(a, async (err, result) => { // Tuỳ lib
    if(err) reject(err); 
    resolve(result);
  })
})

- Promise: await X().then().catch()
Promise có thể await trực tiếp, sẽ chờ cả .then .catch tương tự try catch khi dùng async await.

-> Event với on
Ta có thể biến thành Promise để dùng với async. Bằng cách cho resolve khi onsucess, reject với onerror:
new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    resolve(reader.result);
  };
  reader.onerror = (error) => {
    reject(error);
  };
  reader.readAsDataURL(file);
});

-> Nhanh:
Luồng new Promise và resolve reject
Promise.all allSettled race any
Chuyển về async await



# setTimeout, setInterval, setImmediate
Nếu tham số 2 lơn hơn 2147483647 hoặc nhỏ hơn 1 thì sẽ tự động set về 1

-> Thứ tự ưu tiên là process.nextTick > setImmediate > setTimeout 0s
- setTimeout(function(){
  alert("Chào mừng bạn đến với freetuts.net");
});
=> Thực hiện bất đồng bộ hàm sau 0s, thực tế nó k thực hiện ngay sau 0s mà phải chờ thực hiện Ct hiện tại đến khi stack trống để đẩy event vào và thực hiện callback event đó. Event Loop chỉ nhặt event từ queue vào stack khi stack trống.
- process.nextTick(<function>); => chỉ có trong NodeJS
=> Chỉ cần dùng setImmediate



# OOP
function và class trong JS đều hỗ trợ đủ OOP => nên dùng class
VD: 
function Animal() { 
  let count = 0;
  this.name= "a";
}
Animal.prototype.test = () => { console.log("test"); }
Animal.staticMethod = () => { }
Tương đương với:
class Animal {
  #count = 0;
  constructor() { 
    this.name = "a"; 
  }
  test = () => { console.log("test"); }
  static staticMethod = () => { }
}



# Closure function
func1 return ra func2, thì func2 dùng biến khởi tạo trong func1 được dù func1 đã kết thúc.

-> this bth trong hàm or class sẽ trỏ chính đối tượng đó, this ở ngoài là window. this trong code html truyền vào event thì chính là thẻ tag đó.
Dùng arrow function thì this trong func sẽ là cái bao ngoài cái hiện tại (object, class, window) ở mọi case, vì arrow function k có this, bind call apply k tác dụng.
Còn có with(this) { ... }

-> Dùng call bind apply:
- call và apply chỉ khác cú pháp: o.call(this, args1, args2) và o.apply(this, [args1, args2]);
- bind có thể tái sử dụng vì nó return 1 function mới với this xác định.
VD: function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'John' };
const greetPerson = greet.bind(person, 'Hello');
greetPerson('!');

-> Nhanh: 
Biến this
Dùng bind có thể tái sử dụng



# Dùng event JS
URL event: https://freetuts.net/su-kien-event-trong-javascript-368.html
3 cách: dùng ở tag html; code js là element.onclick = () => { }; element.addEventListener("click", () => { });

-> 1 tag addEventListener cùng 1 event nhiều lần thì khi trigger sự kiện tới element đó sẽ chạy lần lượt theo thứ tự được thêm vào chứ không đồng thời.
Tham số 3 là boolean useCapture. Khi 1 event trigger sẽ luôn chạy theo thứ tự Capture phase (từ window đến đúng ptu đó) rồi đến Bubbling phase (từ phần tử đó lên cha). Nếu useCapture true sẽ xử lý trong capture phase, false mặc định sẽ chỉ xử lý trong bubbling phase.
removeEventListener cũng chạy Capture phase trước rồi đến Bubbling phase, có tham số 3 tương tự.

event.stopPropagation() => mặc định event chạy từ window đến tag sâu nhất rồi chạy từ nó đến window, trên đường đi tag nào catch event tương ứng sẽ chạy handler. Dùng như này cho 1 tag thì khi trigger tới tag đó sẽ dừng propagateluôn.

-> onmouseenter phát 1 lần mỗi khi hover vào element, dùng thay :hover tạo animation được.
onmouseover tương tự nhưng điểm khác là onmouseenter k bubble event again khi mouse hover vào child element, onmouseover thì có.
onmousemove phát liên tục khi di chuyển trong element
onmouseleave phát 1 lần khi rời khỏi element
onmouseout phát khi chuột rời khỏi element hoặc rời khỏi 1 child element sang 1 child element khác.

-> Nhanh:
3 cách gán event
Chạy event ở capture phase và bubbling phase. Khi stopPropagation nữa.



# Fetch API
Không còn dùng XMLHttpRequest nữa mà dùng fetch có sẵn của browser.
Dùng top-level statement fetch api được.

-> Các response.type: 
basic: khi gửi request cho server cùng origin, k có giới hạn vc xem thông tin trên response. Hoặc request mode "no-cors" và phản hồi là 1 simple origin
cors: Khi yêu cầu cross origin và server đã cấu hình CORS để cho phép truy cập.
"opaqueredirect" hoặc "opaque": éo xem được response, chỉ xem được vài header cơ bản. Khi cross-origin request mà server k cấu hình cors hợp lệ

-> Có thể dùng AbortController custom timeout cho fetch với setTimeout gọi cùng với hàm fetch truyền vào signal



# FormData và URLSearchParams, URL
-> FormData có thể upload multiple files lên server => refer tới "Projects / Tinkerbellgarden"
VD: var formData = new FormData();
var photos = document.querySelector("input[type='file'][multiple]");
formData.append('title', 'My Vegas Vacation');
formData.append('photos', photos.files);
fetch('https://example.com/posts', {
  method: 'POST',
  body: formData
})
.then(response => response.json())
.then(response => console.log('Success:', JSON.stringify(response)))
.catch(error => console.error('Error:', error));

-> const myURL = new URL('https://example.com/path?name=chatgpt&age=25');
myURL.hostname => "example.com"
myURL.pathname => "/path"
myURL.search => "?name=chatgpt&age=25"
myURL.searchParams là URLSearchParams

-> const params = new URLSearchParams('?name=chatgpt&age=25');
params.get('name')
params.set('name', 'gpt-4'); => thêm key-value, nếu key đã có sẽ thay thế
params.append('lang', 'en'); => thêm key-value, nếu key đã có vẫn thêm, khiến key đó là 1 mảng
params.getAll("lang");




-> Highlight API rất mạnh giúp tô màu xuyên tag 

-> Web worker giúp chạy multi thread trên browser


# Navigation
HTML navigate bằng <a>
JS đổi window.location

-> Đổi url k chuyển trang: history.pushState(null, "", url); 
Tốt hơn là dùng replaceState hơn pushState để nó replace url hiện tại chứ không lưu vào lịch sử.
VD: window.history.replaceState(null, "", document.querySelector("link[rel=canonical]").getAttribute("href")); => Mẹo là gọi hàm này mỗi khi load xong chính khiến cho url luôn là canonical rất gọn dù thực tế nó có params các thứ. Còn muốn preserve state trên url thì lưu vào localstorage.

-> Navigation trong dự án MPA:
Khi chuyển page MPA thì global state bị reset, có thể lưu vào sessionStorage, localStorage, indexed db, url params để lấy lại state cũ khi chuyển pages.
Các file js, css, html k cần lo tải lại vì browser có cache để chỉ tải 1 lần.



# IntersectionObserver
1 biến IntersectionObserver có thể lắng nghe 1 thẻ có giao với viewport không thì chạy 1 hàm tương ứng. Nó cũng gọi callback ngay lúc đầu mới tạo dù k giao gì cả

Bản chất nó chỉ tính phần hiển thị trên màn so với height của nó, tức VD thẻ lớn hơn màn hình thì không bao giờ đạt threshold 100% được.
VD usecase có 1 element cực dài và muốn làm kiểu scroll element xuống bao xa thì chạy hàm buộc phải làm thủ công window.onscroll, k thể dùng IntersectionObserver



# ResizeObserver
Thay vì window addEventListener resize để bắt khi window đổi kích thước, ta dùng ResizeObserver để bắt khi nào kích thước của các objects nào bị thay đổi thì làm gì chẳng hạn.



# Drag Animation với JS



# Thao tác với string
-> VD string find 1 string khác: 
str1.trim().replaceAll(",","").replaceAll(".","").toLowerCase().includes(str2.trim().replaceAll(",","").replaceAll(".","").toLowerCase());
Thay vì dùng str1 + str2, nên dùng `${str1}${str2}`

-> Regexp: 
.: Khớp với bất kỳ ký tự nào (trừ newline).
^: Khớp với đầu chuỗi.
$: Khớp với cuối chuỗi.
*: Khớp với 0 hoặc nhiều lần của ký tự trước.
+: Khớp với 1 hoặc nhiều lần của ký tự trước.
?: Khớp với 0 hoặc 1 lần của ký tự trước.
{n}: Khớp với đúng n lần của ký tự trước. {2,} là từ 2 trở lên
[]: Khớp với bất kỳ ký tự nào trong dấu ngoặc vuông.
|: Hoặc (OR).
VD lọc mail: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

--> Check string có thoả mãn 1 regexp hay không: 
const str = "Hello, World!";
const regex = /Hello/i; // Biểu thức chính quy để kiểm tra "Hello"
const isMatch = regex.test(str); // Kiểm tra



# Dùng mảng và object và hàm 
Chuyển từ string sang array: [..."Hello"];
Cách khác lấy params của function ít dùng là dùng for(var x of arguments) {<>}
Các hàm biến hóa mạnh: splice, copyWithin, flat

-> Tạo array:
Array(10).fill(undefined)
Array.from({ length: 10 });
VD: const numbers = [1, 2, 3];
const squares = Array.from(numbers, x => x * x);
console.log(squares); // [1, 4, 9]

Có thể ss 2 array chấp cả nested với: JSON.stringify(a1) == JSON.stringify(a2) => trừ TH undefined và null se coi là giống nhau

-> Sort array giảm dần: arr.sort(function(a, b){return b-a});
Cách nhớ: trả true thì giữ thứ tự(a, b) tức a < b, trả false thì đổi b < a

-> Cách shuffle 1 array
Lodash có hàm shuffle
Dùng 0.5 - Math.random() k hoàn toàn random nhưng có thể dùng nếu k yêu cầu khắt khe
Dùng Fisher-Yates alg, cơ chế là sinh số random nguyên để hoán đổi vị trí các phần tử trong array

-> Vòng for of chỉ dùng với các biến iterable. Vd k dùng được với object vì object không iterable, phải dùng hàm Object.entries.
Vòng for in dùng được với biến và mảng bình thường nhưng 1 số kiểu IterableIterator như entries, values của Map hay Set lại k dùng được
forEach chỉ dùng cho mảng vì nó thuộc Array.prototype

--> for await (const value of promises) { console.log(value); } => chờ lần lượt từng promies thực hiện xong

-> Hàm map tạo ra 1 mảng mới và k thay đổi trên mảng cũ nên phải gán bằng. 
2 tham số: 1 là function(currentValue, index, array), 2 là thisValue là giá trị pass vào function để dùng từ khóa this. Tuy nhiên để dùng được đối số 2 thì đối số 1 k được dùng arrow function, nếu k this sẽ luôn là cái bao ngoài hàm. 
VD: var object = { id: 1 }; const item = [1,2,3].map(function(currentVal, index, arr){ return currentVal + this.id + arr[index]; }, object); // [3, 5, 7]

-> Dùng tagged template
function tag(strings, ...values) {
  console.log("Chuỗi tĩnh:", strings);
  console.log("Giá trị nội suy:", values);
  return "Kết quả được tùy chỉnh!";
}
const name = "Minh";
const age = 25;
const result = tag`Xin chào ${name}, bạn ${age} tuổi.`;
console.log(result);
// Output:
// Chuỗi tĩnh: [ 'Xin chào ', ', bạn ', ' tuổi.' ]
// Giá trị nội suy: [ 'Minh', 25 ]
// Kết quả được tùy chỉnh!



# Dùng postMessage
Là API có sẵn giúp truyền message giữa trang web gốc với iframe dùng bên trong nó, hoặc mở 1 popup hay tab của web khác và truyền message giữa popup và web gốc khác host.

Bên gửi: targetWindow.postMessage(message, targetOrigin);
Bên nhận: window.addEventListener("message", function (event) {
  if (event.origin !== "http://localhost:8001/window-1") return;        
  alert(event.data);
});

window.opener giúp lấy trang gốc mở ra cửa sổ hiện tại
window.parent giúp lấy trang gốc chứa iframe hiện tại
=> Nhưng truy cập DOM phải cùng host vì browser có same site policy cản cả API và tương tác DOM. Muốn giao tiếp phải dùng postMessage



# Dùng Map thay if else và switch case:
if else là cấu trúc bậc thang
switch case nhanh hơn if else đáng kể khi số lượng điều kiện lớn. Mỗi điều kiện k phụ thuộc vào điều kiện trước đó nên thực hiện như mạch logic sẽ nhanh hơn.
=> Tuy nhiên trong Js khi muốn search theo key nên dùng new Map là nhanh nhất. Map là 1 instanceof Object nhưng sinh ra để search nhanh hơn, nên dùng thay thế



# Cơ chế WeakMap dọn rác
Các biến k thể truy cập được sẽ tự bị GC dọn. VD: user = { name: "John" }; user = null; thì object {name: "John"} k còn được ref bởi biến nào khác sẽ tự giải phóng vùng nhớ
GC sẽ tự được scheduled và dọn rác vào lúc rảnh.

-> WeakMap và WeakSet
Do cơ chế dọn rác, nếu mảng có 1 phần tử là 1 object chẳng hạn thì dù object mất reference nhưng mảng vẫn còn phần tử đó thì object vẫn k bị giải phóng vì vẫn refer được với array[index]. Điều này là đúng nhưng trong TH dùng map với set, có thể ta muốn nó tự động bị xóa với WeakMap, WeakSet
- WeakMap thì key buộc là object và khi reference đến object bởi 1 biến khác k còn thì sẽ tự bị xóa.
Do GC k rõ thời gian chạy nên k thể truy cập vào số lượng phần tử hay duyệt các phần tử của WeakMap. Chỉ có has delete get set. 
- WeakSet giống set nhưng chỉ nhận object, tự bị xóa khi k còn reference từ ngoài, cũng k hỗ trợ size keys hay các kiểu duyệt
VD 1 biến WeakMap lưu thông tin của người dùng, khi người dùng leave thì tự xóa, nếu dùng map bth phải xóa thủ công hoặc chờ biến map giải phóng. Tức là ta dùng khi cần dùng map với set, mà k cần dùng length hay duyệt, mất reference bên ngoài là tự xóa tối ưu bộ nhớ.



# Dùng yield
Dùng yield chạy 1 hàm * nhiều lần thì chạy liên tiếp, còn k có * thì yield trả lấy được gì.
Nếu function* có return thì nó sẽ kết thúc luôn nên có thể dùng return để dừng hàm * vĩnh viễn khi thỏa mãn đk gì nhưng giá trị return về sẽ k được lấy ra.
function* gọi là generator function
yield* dùng được với mọi type iterative
Có thể dùng vòng for để duyệt yield function sẽ chạy liên tiếp mà k cần gọi next. Đây cũng là cơ chế của redux-saga, k cần gọi next mà đưa vào loop duyệt liên tiếp





# Dùng service worker
-> Dùng lưu cache offline, tắt browser bật lại vẫn có data, thậm chí là offline.
- Bắt sự kiện fetch, nếu request có trong cache thì lấy từ cache
- Bắt sự kiện install, lưu files nào vào cache.
- Bắt sự kiện activate xoá các cache không liên quan, chỉ để lại cache hiện tại. Ta cũng có thể update worker service bằng cách tạo 1 key mới và xoá cache key cũ.

Khi reload lại pages, sẽ k trigger lại event install và activate để setup lại worker, trừ khi file service-worker bị thay đổi. 
Tắt đi bật lại thì luôn setup lại worker, tức mỗi lần vào web lần đầu, đều setup lại service worker. Nói chung là file này cứ đổi là tự áp dụng nên k cần lo cũ.

-> Push notification: 
App request permission cho phép hiện thông báo, rồi bắt sự kiện push là khi có thông báo đến thì service worker show ra. Thông báo có cả trên máy tính hoặc mobile. Trên macos yêu cầu người dùng phải biến web thành ứng dụng ở homescreen r cấp quyền mới được.
Nếu chỉ FE, ấn nút hay làm gì thì gọi registration.showNotification để phát sự kiện push thôi.
Thực tế dùng server, có thể gửi thông báo bất cứ lúc nào. Server gửi thông báo đến PushService của trình duyệt (VD: Firebase Cloud Messaging cho Chrome), đăng ký API key. Rồi tuỳ ý trigger notification cho user từ server. Client có mạng sẽ tự nhận được thông báo.



# Other
- FE kbh dùng window.name, vì nó sẽ share giữa các website với nhau bị XSS.
- Có thể lưu function vào file json với function constructor
- Thay vì viết try catch ở từng hàm async, ta nên viết 1 hàm trả ra [result, error] để wrap hàm async. Hiện custom error, lỗi lạ thì hiện message slice ngắn đi.
- Tạo random nhanh có thể dùng Date.now() + Math.random() cho seed phụ thuộc vào thời gian, xác suất bị trùng cực thấp.


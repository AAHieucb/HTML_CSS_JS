# Vanilla JS 
Best practice là chia mỗi page 1 file html css js. CSS dùng BEM.

-> Các cách chạy dự án vanillajs
Dùng HTML thuần với live server. Host thì đẩy file trực tiếp lên.
Dùng html thuần với live server nhưng tùy biến tự cài node_modules quản lý version hoặc cài qua CDN => phức tạp
Dùng bundler hỗ trợ hết như vite. Host phải chạy build => khó dùng vì code html trong JS.
Dùng bundler parcel như live server nhưng thêm đủ các tính năng build và start ở 1 port, cài package vào node_modules và import vào file js => best practice

-> Tối ưu cache fetched data để k fetch lại trong phạm vi 1 page
VD:
var MyApp = MyApp || {};
MyApp.globalData = {
  fetchedData: null
};
MyApp.fetchData = async function() {
  if (!MyApp.globalData.fetchedData) {
    const response = await fetch('your-data-source-url');
    MyApp.globalData.fetchedData = await response.json();
  }
  return MyApp.globalData.fetchedData;
};

-> Tối ưu load lần đầu:
document.addEventListener('DOMContentLoaded', ...); => khi toàn bộ HTML đã được tải xong, k chờ tài nguyên như ảnh, stylesheet.
window.onload => khi tất cả, bao gồm cả hình ảnh, stylesheet, và iframe tải xong.
=> useEffect chạy lần đầu tiên tương đương với DOMContentLoaded, cũng k chờ script và ảnh tải xong.

Ta muốn fetch data sớm nhất có thể, khi nào DOM load xong thì show ra thôi. DOM chưa xong thì chưa show, DOM xong và fetch chưa xong thì show loading. K được cho vào DOMContentLoaded vì khi đó, DOM phải load xong mới bắt đầu fetch.
VD để script js ở cuối:
<div id="data-container">Loading data...</div>
<script>
  let dataFetched = false;
  let domContentLoaded = false;
  let fetchedData = null;
  fetch('https://api.example.com/data')
    .then(response => {
      if (!response.ok) throw new Error('Network response was not ok');
      return response.json();
    })
    .then(data => {
      fetchedData = data;
      dataFetched = true;
      displayDataIfReady();
    })
    .catch(error => {
      document.getElementById('data-container').textContent = 'Failed to load data: ' + error.message;
    });
  document.addEventListener('DOMContentLoaded', function() {
    domContentLoaded = true;
    displayDataIfReady();
  });
  function displayDataIfReady() {
    if (dataFetched && domContentLoaded) {
      const dataContainer = document.getElementById('data-container');
      dataContainer.innerHTML = '<pre>' + JSON.stringify(fetchedData, null, 2) + '</pre>';
    }
  }
</script>

-> Convert React to Vanilla
--> React có onChange tương đương với event "input" trong vanilla trigger mọi lúc value gõ vào đổi. K dùng "change" chỉ trigger khi k còn focus vào ô input.
--> Dùng cơ chế pubsub tạo store để thực hiện hành động khi state đổi, tương đương useEffect
VD:
const store = {
  _value: { },
  effects: [],
  get value() {
    return this._value;
  },
  set value(newValue) {
    this._value = { ...this._value, ...newValue };
    this.effects.forEach(fn => fn(this._value));
  },
  subscribe(fn) {
    this.effects.push(fn);
  }
};
export default store;

-> Nhanh:
Dùng parcel
onload, DomContentLoaded
event input



# Load file JS với async và defer
Browser load nếu thấy file js or script, sẽ dừng vc parse HTML để lý xử JS, gọi là Parse Blocking => default
<script async> sẽ tải script bất đồng bộ trên 1 thread khác và tiếp tục parse trang, tải xong JS sẽ chạy bth; defer chỉ chạy khi html parse xong.
VD: Đang parse HTML CSS thì gặp 1 script async -> tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì vẫn chạy script luôn
VD: Đang parse HTML CSS thì gặp 1 script defer -> Tiếp tục parse HTML CSS trong khi tải script -> Parse HTML chưa xong nhưng tải xong script thì script k được exec -> parse HTML xong mới exec script 
=> Best practice là đặt script ở đầu và dùng defer để đảm bảo exec sau khi DOM load.

-> Nếu không xác định type="module" trong thẻ <script>, file JS sẽ được xử lý như một script thông thường, k có tính năng của module.
- Trong module, biến và hàm được khai báo trong scope đó. Còn script bth thì biến không khai báo trong 1 block, sẽ là toàn cục, dùng mọi nơi miễn biến đã load xong.
- Module trao đổi biến qua export, tự tối ưu k tải nhiều lần dù import 1 module nhiều lần. Module cũng luôn trong chế độ strict, còn script thông thường thì không.
dynamic import cũng chỉ dùng trong module: await import("../index.js");

-> Nhanh:
default block, async, defer
type module có thể export biến local



# Bản chất repaint và reflow
Khi đổi thuộc tính element bằng js, browser sẽ tự nhận ra thay đổi này và tính toán lại styles cho phần tử bị thay đổi và các con của nó nếu cần.
- Reflow: nếu CSS đổi có ảnh hưởng đến bố cục (layout) của trang, browser sẽ thực hiện "reflow" để tính toán lại vị trí và kích thước các elements.
VD: box.style.width = '200px'; // Thay đổi kích thước (gây reflow và repaint)
- Repaint: sau khi reflow, nếu css đổi ảnh hưởng đến sự xuất hiện của các phần tử (như màu sắc, ảnh, đường viền), browser sẽ thực hiện "repaint" để vẽ lại các phần tử.
VD: box.style.backgroundColor = 'blue'; // Thay đổi màu sắc (chỉ gây repaint)
=> Chú ý là browser không repaint và reflow cả page mà chỉ với các phần tử cần thiết.

Reflow tốn tài nguyên, nên hạn chế số lần reflow bằng cách gộp:
VD: // Thay vì:
element.style.width = '200px';
element.style.height = '200px';
element.style.backgroundColor = 'blue';
// Dùng:
element.classList.add('new-style');



# Dùng promise và async
Luồng promise: khi gọi new Promise() sẽ chạy ngay, kết thúc khi gọi resolve/reject và cũng chỉ gọi resolve/reject được 1 lần thôi, sau đó vẫn chạy hết phần code bên dưới mới trả giá trị, nên nếu muốn dừng luôn phải thêm return sau đó.
VD resolve(new Promsie(<hàm>)) thì chạy đến resolve cũng thực hiện hàm luôn; khi promise lồng kiểu new Promise(<promise>) thì cái ngoài chạy sẽ thực hiện hết các cái trong.

-> Promise.all nhận input list promise, trả ra 1 promise mới trả 1 mảng kết quả đúng thứ tự input. Nếu 1 promise con bị failed thì promise tổng reject luôn.
Promise.allSettled tương tự Promise.all nhưng trả hết, error 1 cái cũng k dừng 
Promise.race trả về cái đầu tiên bất kể thành công hay lỗi
Promise.any trả vể cái thành công đầu tiên, nếu tất cả đều lỗi mới trả lỗi

VD usecase tìm best url trong list url: có 1 list rpc như nhau, cần chọn ra best url để gọi vào, rpc có thể chết bất cứ lúc nào => ref tới projects "Vatra"
Mỗi khi user vào web sẽ query thử 1 lệnh đơn giản trên cả list rpc với Promise.any, cái nào trả nhanh nhất thì lấy. Nếu có lỗi mạng thì sẽ call tìm url lại.

-> Chuyển hết về async await
- Hàm callback
X(a, callback); => khi hàm X thực hiện xong sẽ truyền kết quả vào hàm callback ở cuối để xử lý. 
Thường hàm từ thư viện sẽ có sẵn phiên bản khác dùng async await. Vd: const x = await X(a); callback(x);
Nếu không có sẵn phiên bản async await, có thể ép chờ callback xong mới chạy xuống dưới, vì promise kbh kết thúc nếu cái cục cuối cùng k gọi resolve or reject:
const x = await new Promise((resolve, reject) => {
  X(a, async (err, result) => { // Tuỳ lib
    if(err) reject(err); 
    resolve(result);
  })
})

- Promise: await X().then().catch()
Promise có thể await trực tiếp, sẽ chờ cả .then .catch tương tự try catch khi dùng async await.

-> Event với on
Ta có thể biến thành Promise để dùng với async. Bằng cách cho resolve khi onsucess, reject với onerror:
new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => {
    resolve(reader.result);
  };
  reader.onerror = (error) => {
    reject(error);
  };
  reader.readAsDataURL(file);
});

-> Nhanh:
Luồng new Promise và resolve reject
Promise.all allSettled race any
Chuyển về async await



# setTimeout, setInterval, setImmediate
Nếu tham số 2 lơn hơn 2147483647 hoặc nhỏ hơn 1 thì sẽ tự động set về 1

-> Thứ tự ưu tiên là process.nextTick > setImmediate > setTimeout 0s
- setTimeout(function(){
  alert("Chào mừng bạn đến với freetuts.net");
});
=> Thực hiện bất đồng bộ hàm sau 0s, thực tế nó k thực hiện ngay sau 0s mà phải chờ thực hiện Ct hiện tại đến khi stack trống để đẩy event vào và thực hiện callback event đó. Event Loop chỉ nhặt event từ queue vào stack khi stack trống.
- process.nextTick(<function>); => chỉ có trong NodeJS
=> Chỉ cần dùng setImmediate, lưu ý nó k chạy tuần tự như gọi trực tiếp luôn mà vẫn để vào queue



# OOP
function và class trong JS đều hỗ trợ đủ OOP => nên dùng class
VD: 
function Animal() { 
  let count = 0;
  this.name= "a";
}
Animal.prototype.test = () => { console.log("test"); }
Animal.staticMethod = () => { }
Tương đương với:
class Animal {
  #count = 0;
  constructor() { 
    this.name = "a"; 
  }
  test = () => { console.log("test"); }
  static staticMethod = () => { }
}



# Closure function
func1 return ra func2, thì func2 dùng biến khởi tạo trong func1 được dù func1 đã kết thúc.

-> this bth trong hàm or class sẽ trỏ chính đối tượng đó, this ở ngoài là window. this trong code html truyền vào event thì chính là thẻ tag đó.
Dùng arrow function thì this trong func sẽ là cái bao ngoài cái hiện tại (object, class, window) ở mọi case, vì arrow function k có this, bind call apply k tác dụng.
Còn có with(this) { ... }

-> Dùng call bind apply:
- call và apply chỉ khác cú pháp: o.call(this, args1, args2) và o.apply(this, [args1, args2]);
- bind có thể tái sử dụng vì nó return 1 function mới với this xác định.
VD: function greet(greeting, punctuation) {
  console.log(greeting + ', ' + this.name + punctuation);
}
const person = { name: 'John' };
const greetPerson = greet.bind(person, 'Hello');
greetPerson('!');

-> Nhanh: 
Biến this
Dùng bind có thể tái sử dụng



# Dùng event JS
URL event: https://freetuts.net/su-kien-event-trong-javascript-368.html
3 cách: dùng ở tag html; code js là element.onclick = () => { }; element.addEventListener("click", () => { });

-> 1 tag addEventListener cùng 1 event nhiều lần thì khi trigger sự kiện tới element đó sẽ chạy lần lượt theo thứ tự được thêm vào chứ không đồng thời.
Tham số 3 là boolean useCapture. Khi 1 event trigger sẽ luôn chạy theo thứ tự Capture phase (từ window đến đúng ptu đó) rồi đến Bubbling phase (từ phần tử đó lên cha). Nếu useCapture true sẽ xử lý trong capture phase, false mặc định sẽ chỉ xử lý trong bubbling phase.
removeEventListener cũng chạy Capture phase trước rồi đến Bubbling phase, có tham số 3 tương tự.

event.stopPropagation() => mặc định event chạy từ window đến tag sâu nhất rồi chạy từ nó đến window, trên đường đi tag nào catch event tương ứng sẽ chạy handler. Dùng như này cho 1 tag thì khi trigger tới tag đó sẽ dừng propagateluôn.

-> onmouseenter phát 1 lần mỗi khi hover vào element, dùng thay :hover tạo animation được.
onmouseover tương tự nhưng điểm khác là onmouseenter k bubble event again khi mouse hover vào child element, onmouseover thì có.
onmousemove phát liên tục khi di chuyển trong element
onmouseleave phát 1 lần khi rời khỏi element
onmouseout phát khi chuột rời khỏi element hoặc rời khỏi 1 child element sang 1 child element khác.

-> Nhanh:
3 cách gán event
Chạy event ở capture phase và bubbling phase. Khi stopPropagation nữa.



# Fetch API
Dùng fetch có sẵn của browser thay cho XMLHttpRequest, dùng ở top-level statement cũng được.

-> Các response.type: 
basic: khi gửi request cho server cùng origin hoặc request mode "no-cors" và phản hồi là 1 simple origin. K có giới hạn vc xem thông tin trên response.
cors: khi yêu cầu cross origin và server đã cấu hình CORS để cho phép truy cập.
"opaqueredirect" hoặc "opaque": khi cross-origin request mà server k cấu hình cors hợp lệ. K xem được response, chỉ xem được vài header cơ bản.

-> Custom timeout cho fetch k hỗ trợ sẵn
VD: const timeout = (ms, promise) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => { reject(new Error("Request timed out")) }, ms);
    promise.then(resolve, reject);
  })
}
const response = await timeout(1000, fetch("<url>"));
=> Các api cần xác thực nên dùng axios, còn các api allow anonymous thì dùng fetch cho nhanh
=> Nên dùng AbortController truyền signal vào fetch để dừng ok hơn.



# FormData và URLSearchParams, URL
-> FormData có thể upload multiple files lên server
VD: var formData = new FormData();
var photos = document.querySelector("input[type='file'][multiple]");
formData.append('title', 'My Vegas Vacation');
formData.append('photos', photos.files);
fetch('https://example.com/posts', {
  method: 'POST',
  body: formData
})
.then(response => response.json())
.catch(error => console.error('Error:', error));

-> const myURL = new URL('https://example.com/path?name=chatgpt&age=25');
myURL.hostname => "example.com"
myURL.pathname => "/path"
myURL.search => "?name=chatgpt&age=25"
myURL.searchParams là URLSearchParams

-> const params = new URLSearchParams('?name=chatgpt&age=25');
params.get('name')
params.set('name', 'gpt-4'); => thêm key-value, nếu key đã có sẽ thay thế
params.append('lang', 'en'); => thêm key-value, nếu key đã có vẫn thêm, khiến key đó là 1 mảng
params.getAll("lang");



# Thao tác với string
-> VD check include string: str1.trim().replaceAll(",","").replaceAll(".","").toLowerCase().includes(str2.trim().replaceAll(",","").replaceAll(".","").toLowerCase());
Thay vì dùng str1 + str2, nên dùng `${str1}${str2}`
Hàng loạt hàm slice, padEnd, padStart

-> Regexp: 
.: Khớp với bất kỳ ký tự nào (trừ newline).
^: Khớp với đầu chuỗi.
$: Khớp với cuối chuỗi.
*: Khớp với 0 hoặc nhiều lần của ký tự trước.
+: Khớp với 1 hoặc nhiều lần của ký tự trước.
?: Khớp với 0 hoặc 1 lần của ký tự trước.
{n}: Khớp với đúng n lần của ký tự trước. {2,} là từ 2 trở lên
[]: Khớp với bất kỳ ký tự nào trong dấu ngoặc vuông.
|: Hoặc (OR).
VD lọc mail: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
VD: Check string có thoả mãn 1 regexp hay không: const str = "Hello, World!"; const regex = /Hello/i; const isMatch = regex.test(str);

->*** Security bypass input validation (duck-typing):
Khi check userInput.length <= 100, cần check typeof(userInput) == "string" vì nếu user input 1 object { input: <rất dài>, length: 100 } sẽ bypass.
Giả sử BE check rồi hash password lưu vào server, sẽ hash nhầm object lớn đó để lưu vào server. Hash là hàm nặng nếu hash 1 triệu data, server sẽ collapse.

-> FE kbh dùng window.name, vì nó sẽ share giữa các website với nhau bị XSS.



# Dùng mảng object hàm 
-> Array:
- Remove duplicate [...new Set(<array>)]
- Lấy params function với for(var x of arguments) {<>}
- Có slice, splice, copyWithin, flat(Infinity)
- Tạo array:
Array(10).fill(undefined)
Array.from({ length: 10 });
Array.from(<array>, x => x * x);
- So sánh 2 array kể cả nested: JSON.stringify(a1) == JSON.stringify(a2) => trừ TH undefined và null sẽ coi là = nhau
- Sort array giảm dần: arr.sort(function(a, b){return b-a}); => Cách nhớ: trả true thì giữ thứ tự (a, b) tức a < b, trả false thì đổi (b, a)
- Cách shuffle 1 array: 
Dùng lodash
Dùng 0.5 - Math.random() k hoàn toàn random nhưng có thể dùng nếu k yêu cầu khắt khe, or Date.now() + Math.random()
Dùng Fisher-Yates alg, cơ chế là sinh số random nguyên để hoán đổi vị trí các phần tử trong array
- Hàm map: tạo ra mảng mới và k thay đổi trên mảng cũ nên phải gán bằng. 
Tham số 1 là function(currentValue, index, array), 2 thisValue là giá trị pass vào function để dùng this. Để dùng được 2 thì 1 k được dùng arrow function => kbh dùng

-> Dùng for loop:
for of chỉ dùng với các biến iterable. Vd k dùng được với object vì object không iterable, phải dùng hàm Object.entries.
for in dùng được với biến và mảng bình thường chứ 1 số kiểu IterableIterator như entries, values của Map hay Set lại k dùng được
forEach chỉ dùng cho mảng vì nó thuộc Array.prototype
for await (const value of promises) { console.log(value); } => chờ lần lượt từng promies thực hiện xong

-> Dùng tagged template gọi hàm:
function tag(strings, ...values) {
  console.log("Chuỗi tĩnh:", strings);
  console.log("Giá trị nội suy:", values);
  return "Kết quả được tùy chỉnh!";
}
const name = "Minh";
const age = 25;
const result = tag`Xin chào ${name}, bạn ${age} tuổi.`;
console.log(result);
// Output:
// Chuỗi tĩnh: [ 'Xin chào ', ', bạn ', ' tuổi.' ]
// Giá trị nội suy: [ 'Minh', 25 ]
// Kết quả được tùy chỉnh!

-> Có thể lưu function vào file json với function constructor



# Cơ chế WeakMap dọn rác
Các biến k thể truy cập sẽ tự bị GC dọn. VD: user = { name: "John" }; user = null; thì object {name: "John"} k còn được ref bởi biến nào khác sẽ tự giải phóng vùng nhớ
GC tự được scheduled và dọn rác vào lúc rảnh.

-> WeakMap và WeakSet: Do cơ chế dọn rác, nếu mảng có 1 phần tử là 1 object chẳng hạn thì dù object mất reference nhưng mảng vẫn còn phần tử đó thì object vẫn k bị giải phóng vì vẫn refer được với array[index]. Điều này là đúng nhưng trong TH dùng Map và set, có thể ta muốn nó tự động bị xóa với WeakMap, WeakSet
- WeakMap thì key buộc là object và khi reference đến object bởi 1 biến khác k còn thì sẽ tự bị xóa.
Do GC k rõ thời gian chạy nên k thể truy cập vào số lượng phần tử hay duyệt các phần tử của WeakMap. Chỉ có has delete get set. 
- WeakSet giống Set nhưng chỉ nhận object, tự bị xóa khi k còn reference từ ngoài, cũng k hỗ trợ size keys hay các kiểu duyệt.
Nếu dùng Set bth phải xóa thủ công hoặc chờ biến set giải phóng => chỉ dùng khi cần dùng Map với Set nhưng k cần length hay duyệt, mất reference ngoài sẽ tự xóa tối ưu bộ nhớ.



# Dùng Map thay if else và switch case
if else là cấu trúc bậc thang
switch case nhanh hơn if else đáng kể khi số lượng điều kiện lớn. Mỗi điều kiện k phụ thuộc vào điều kiện trước đó nên thực hiện như mạch logic sẽ nhanh hơn.
=> Tuy nhiên trong JS khi muốn search theo key nên dùng new Map là nhanh nhất. Map là 1 instanceof Object nhưng sinh ra để search nhanh hơn, luôn dùng



# Navigation
- HTML navigate bằng <a>
- JS đổi window.location
- Đổi url k chuyển trang với history.pushState(null, "", url); 
Dùng replaceState tốt hơn pushState để nó replace url hiện tại chứ không lưu vào lịch sử.
VD: window.history.replaceState(null, "", document.querySelector("link[rel=canonical]").getAttribute("href")); => có thể gọi hàm này mỗi khi load xong khiến cho url luôn là canonical dù thực tế nó có params, còn state trên url thì lưu vào localstorage.

-> Navigation trong dự án MPA: global state bị reset, có thể lưu vào sessionStorage, localStorage, indexed db, url params để lấy lại state cũ khi chuyển pages.
Browser tự cache các file js css html là static để k tải lại nh lần.



# Cookie string
document.cookie = "username=John; path=/; max-age=3600"; => set ở FE sẽ đặt các tham số HttpOnly, SameSite, Secure là default value
document.cookie = "username=John; Secure;" => set thêm option Secure là true chỉ https
Lưu ý càng nhiều cookie, request càng nặng.



# Thao tác UI basic
- Trạng thái load của document:
window.addEventListener("DOMContentLoaded", () => {
  console.log("Tải xong JS::", document.readyState);
});
window.onload = () => {
  console.log("Tải xong ảnh::", document.readyState);
}

- Tình trạng pin
navigator.getBattery().then(battery => {
  battery.addEventListener("levelchange", () => { console.log(battery.level); });
  battery.addEventListener("chargingchange", () => { console.log(battery.charging); });
})

- Tốc độ internet:
window.addEventListener("offline", () => {});
window.addEventListener("online", () => {});

- Handle global error:
window.onerror = (message, source, lineno, colno, error) => {
  console.log("Thông điệp lỗi: " + message);
  console.log("Nguồn: " + source);
  console.log("Dòng: " + lineno);
  console.log("Cột: " + colno);
  console.log("Đối tượng lỗi: ", error);
}

- Check chuyển tab
document.addEventListener("visibilitychange", () => {
  console.log(document.visibilityState);
})
window.addEventListener("blur", () => {});
window.addEventListener("focus", () => {});

- Trigger gì khi bật devtool: k check đóng
Cơ chế là console.log 1 class Error, nó sẽ gọi hàm message của class chỉ khi devtool được bật, chưa bật sẽ chờ tới khi bật.
class DevToolsChecker extends Error {
  toString(){ }
  get message () {
    // Làm gì khi devtool bật
    setTimeout(console.clear.bind(console));
  }
}
console.log(new DevToolsChecker());

- Highlight API giúp highlight xuyên tag
- Drag animation với JS



# Dùng postMessage
API có sẵn giúp truyền message giữa web gốc với iframe bên trong nó, hoặc mở 1 popup hay tab web khác và truyền message giữa popup và web gốc khác host.

Bên gửi: targetWindow.postMessage(message, targetOrigin);
Bên nhận: window.addEventListener("message", function (event) {
  if (event.origin !== "http://localhost:8001/window-1") return;        
  alert(event.data);
});
window.opener lấy trang gốc mở ra cửa sổ hiện tại
window.parent lấy trang gốc chứa iframe hiện tại



# IntersectionObserver ResizeObserver
-> IntersectionObserver:
- 1 biến IntersectionObserver có thể lắng nghe 1 thẻ giao với viewport hay k thì chạy 1 hàm tương ứng. Nó cũng gọi callback ngay lúc đầu mới tạo dù k giao gì cả
- Bản chất nó chỉ tính phần hiển thị trên màn so với height của nó, tức VD thẻ lớn hơn màn hình thì không bao giờ đạt threshold 100% được.
VD usecase có 1 element cực dài và muốn làm kiểu scroll element xuống bao xa thì chạy hàm buộc phải làm thủ công window.onscroll, k dùng IntersectionObserver
- Dùng tag.getBoundingClientRect(); lấy toạ độ, kích thước, vị trí trên viewport

-> ResizeObserver:
Thay vì window.addEventListener resize để bắt khi window đổi kích thước, ta dùng ResizeObserver để bắt khi kích thước của các objects nào thay đổi thì làm gì.



# Service worker và web worker
-> Service worker
- Dùng lưu cache offline, tắt browser bật lại vẫn có data dù offline
Bắt sự kiện fetch, nếu offline và request có trong cache thì lấy từ cache. 
Bắt sự kiện install, lưu files nào vào cache.
Bắt sự kiện activate xoá các cache không liên quan, chỉ để lại cache hiện tại, hoặc update worker service bằng cách tạo 1 key mới và xoá cache key cũ.

Khi reload lại pages, sẽ k trigger lại event install và activate để setup lại worker, trừ khi file service-worker bị thay đổi. 
Tắt đi bật lại thì luôn setup lại worker, tức mỗi lần vào web lần đầu, đều setup lại service worker. Nói chung là file này cứ đổi là tự áp dụng nên k cần lo bị stale.

- Push notification
App request permission cho phép hiện thông báo, rồi bắt sự kiện push là khi có thông báo đến thì service worker show ra. Thông báo có cả trên máy tính hoặc mobile. Trên macos yêu cầu người dùng phải biến web thành ứng dụng ở homescreen r cấp quyền mới được.
Nếu chỉ làm phía FE, ấn nút hay làm gì thì gọi registration.showNotification để phát sự kiện push thôi.
Thường sẽ dùng server có thể gửi thông báo bất cứ lúc nào. Server gửi thông báo đến PushService của trình duyệt (VD: Firebase Cloud Messaging cho Chrome), đăng ký API key. Rồi tuỳ ý trigger notification cho user từ server. Client có mạng sẽ tự nhận được thông báo.

-> Web worker giúp chạy multi thread trên browser



# Dùng yield
Dùng yield chạy 1 function* (generator function) nhiều lần thì chạy liên tiếp, còn k có * thì yield trả lấy được gì. yield* dùng được với mọi type iterative
Nếu function* có return thì nó sẽ kết thúc luôn nên có thể dùng return để dừng function* vĩnh viễn khi thỏa mãn đk gì nhưng giá trị return về sẽ k được lấy ra.
Có thể dùng vòng for để duyệt yield function sẽ chạy liên tiếp mà k cần gọi next. Đây cũng là cơ chế của redux-saga, k gọi next mà đưa vào loop duyệt liên tiếp


